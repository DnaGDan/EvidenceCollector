<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Site Evidence Capture (PWA)</title> <!-- CHANGED: removed v1.2 -->
<meta name="theme-color" content="#0f172a" />
<!-- Favicons from ./icons -->
<link rel="icon" type="image/png" sizes="32x32" href="./icons/favicon-32.png" />
<link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
<link rel="apple-touch-icon" sizes="180x180" href="./icons/apple-touch-icon.png" />
<link rel="manifest" href="./manifest.webmanifest" />
<!-- removed static manifest link so dynamic manifest below is used -->
<style>
  :root{
    --bg:#0f172a;--card:#111827;--muted:#1f2937;--text:#e5e7eb;--accent:#22c55e;--danger:#ef4444;--warn:#f59e0b;
    --border:#333; --header-bg:rgba(15,23,42,.95); --input-bg:#111827; --thumb-bg:#0b1220;
  }
  [data-theme="light"]{
    --bg:#f8fafc;--card:#ffffff;--muted:#f1f5f9;--text:#0f172a;--accent:#16a34a;--danger:#ef4444;--warn:#f59e0b;
    --border:#cbd5e1; --header-bg:rgba(255,255,255,.95); --input-bg:#ffffff; --thumb-bg:#e2e8f0;
  }
  *{box-sizing:border-box}
  /* CHANGED: Added overscroll-behavior-y:none to prevent pull-to-refresh */
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial;overscroll-behavior-y:none}
  header{position:sticky;top:0;z-index:10;background:var(--header-bg);backdrop-filter:blur(6px);border-bottom:1px solid var(--border)}
  .wrap{max-width:1040px;margin:0 auto;padding:16px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;width:100%}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px}
  button,.btn{cursor:pointer;border:1px solid var(--border);background:var(--muted);color:var(--text);padding:10px 14px;border-radius:12px}
  button:disabled{opacity:.5;cursor:not-allowed}
  .primary{background:#16a34a;border-color:#15803d}
  .danger{background:#991b1b;border-color:#7f1d1d}
  .warn{background:#b45309;border-color:#92400e}
  /* CHANGED: Added input[type="datetime-local"] to selector so it inherits theme colors */
  select,input[type="number"],input[type="text"],input[type="datetime-local"]{background:var(--input-bg);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
  
  /* NEW: Zoom levels - Adjusted for distinct steps */
  /* Default (Zoom 0): minmax(240px, 1fr) -> Large cards */
  /* Zoom 1: Medium cards */
  .grid.zoom-1 { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
  /* Zoom 2: Small cards (dense) */
  .grid.zoom-2 { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
  .grid.zoom-2 .meta { font-size: 10px; line-height: 1.2; }
  .grid.zoom-2 .badge { display: none; }

  .gallery-actions {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 8px;
    margin: 6px 0;
  }
  .gallery-actions .btn { padding: 8px 12px; }

  .selection-floating {
    position: fixed;
    right: 16px;
    bottom: 136px;
    display: none;
    flex-direction: column;
    gap: 8px;
    align-items: flex-end;
    z-index: 1300;
  }
  .selection-floating.visible { display: flex; }
  .selection-floating .panel {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 220px;
  }
  .selection-floating .summary { font-weight: 700; }
  .selection-floating small { opacity: 0.8; }
  .selection-floating .actions { display: flex; gap: 8px; justify-content: flex-end; flex-wrap: wrap; }

  /* NEW: Floating Zoom Button - Fixed to bottom-left to avoid layout shift issues */
  .floating-zoom {
    position: fixed;
    left: 16px;
    bottom: 88px; /* Positioned above the footer area */
    z-index: 50;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 999px;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    cursor: pointer;
    color: var(--text);
    transition: all 0.2s ease;
  }
  .floating-zoom:hover { transform: scale(1.1); background: var(--muted); }
  .floating-zoom:active { transform: scale(0.95); }

  .thumb{position:relative;border-radius:12px;overflow:hidden;border:1px solid var(--border);background:var(--thumb-bg)}
  .select-mode .thumb { cursor: pointer; }
  .thumb.selected { border-color:#10b981; box-shadow:0 0 0 2px rgba(16,185,129,0.45); }
  .thumb.unselected { opacity:0.9; filter:saturate(0.8); }
  .select-indicator {
    position:absolute;
    top:auto;
    right:10px;
    bottom:10px;
    width:32px;
    height:32px;
    border-radius:999px;
    border:2px solid rgba(255,255,255,0.8);
    background:rgba(0,0,0,0.45);
    color:#fff;
    display:grid;
    place-items:center;
    font-weight:800;
    font-size:14px;
    font-variant-numeric: tabular-nums;
    box-shadow:0 4px 12px rgba(0,0,0,0.35);
    transition:all 0.15s ease;
    z-index:6;
  }
  .thumb.selected .select-indicator { background:#10b981; border-color:#10b981; transform:scale(1.05); }
  .select-mode .thumb .select-indicator { opacity:1; }
  .select-mode .thumb.unselected .select-indicator { opacity:0.7; }
  .thumb canvas{width:100%;height:auto;display:block}
  .meta{padding:8px 10px;border-top:1px solid var(--border);font-size:14px}
  .meta small{opacity:.7}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#0b4; font-size:12px; margin-left:6px}
  .footer{opacity:.8;font-size:13px}
  dialog{border:none;border-radius:16px;padding:0;max-width:520px;width:90%;background:var(--thumb-bg);color:var(--text)}
  dialog header{padding:16px;border-bottom:1px solid var(--border)}
  dialog .content{padding:16px}
  dialog .actions{display:flex;gap:10px;justify-content:flex-end;padding:16px;border-top:1px solid var(--border)}
  .count{font-variant-numeric: tabular-nums}
  .hint{opacity:.7;font-size:12px}

  /* Slide-out panel for sessions */
  .section {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    transition: transform 0.28s ease; /* Smooth slide-in/out */
    z-index: 1000;
    box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
    border-right: 1px solid var(--border);
    overflow: auto;
    background: var(--card);
    padding: 16px;
    transform: translateX(-110%); /* Hidden by default */
  }
  .section.open {
    transform: translateX(0); /* Slide in when open */
  }
  .tab-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .tab {
    flex: 1;
    padding: 10px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--card);
    color: var(--text);
    cursor: pointer;
    transition: background .2s;
  }
  .tab:hover {
    background: #1f2937;
  }
  .tab.active {
    background: #15803d;
    color: #fff;
  }
  .close {
    background: none;
    border: none;
    color: #ef4444;
    font-size: 18px;
    cursor: pointer;
  }

  /* Session Manager styles */
  .sessions-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    background: var(--card);
    color: var(--text);
    border-right: 1px solid var(--border);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
    padding: 16px;
    overflow-y: auto;
    z-index: 1000;
    transform: translateX(-110%); /* Hidden by default */
    transition: transform 0.28s ease;
  }
  .sessions-panel.open {
    transform: translateX(0); /* Visible when open */
  }
  body.sessions-open #sessionsToggle {
    opacity: 1; /* Ensure the button is fully visible */
    pointer-events: auto; /* Allow interaction */
  }
  .sessions-header-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .sessions-title {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
  }
  .flex-spacer {
    flex: 1;
  }
  .sessions-hint {
    margin-top: 6px;
    font-size: 0.9rem;
    color: var(--muted, #8b93b8);
  }
  .sessions-new-btn-row {
    margin-top: 8px;
  }
  .sessions-list {
    list-style: none;
    padding: 0;
    margin-top: 10px;
  }
  .session-tab {
    display: flex; /* CHANGED from inline-flex */
    align-items: center;
    justify-content: space-between;
    width: 100%;
    gap: 8px;
    padding: 8px 10px;
    margin-bottom: 8px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: var(--card);
    color: var(--text);
    font-weight: 600;
    text-align: left;
    cursor: pointer;
  }
  .session-tab.active {
    outline: 3px solid var(--focus-ring, #7aa9f6);
    outline-offset: 0;
  }
  /* NEW: Group actions to prevent squashing */
  .session-actions {
    display: flex;
    align-items: center;
    gap: 2px;
    flex-shrink: 0; /* Prevent buttons from shrinking */
    margin-left: auto;
  }
  /* NEW: Unified style for session action buttons */
  .session-actions .btn-action {
    background: transparent;
    border: 1px solid transparent;
    color: var(--muted, #8b93b8);
    cursor: pointer;
    padding: 6px;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s;
  }
  .session-actions .btn-action:hover {
    background: var(--muted);
    color: var(--text);
    border-color: #333;
  }
  .session-actions .btn-action.delete:hover {
    background: rgba(239, 68, 68, 0.15);
    color: #ef4444;
    border-color: rgba(239, 68, 68, 0.3);
  }
  .session-actions .btn-action svg {
    width: 18px;
    height: 18px;
    stroke: currentColor;
    fill: none;
    pointer-events: none;
  }
  
  /* NEW: Input styling to play nice with flex */
  .session-tab .tab-name {
    flex: 1;
    min-width: 0; /* Allow shrinking */
    margin: 0 4px;
    background: transparent; /* Blend in */
    border: 1px solid transparent;
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--text);
  }
  .session-tab .tab-name:focus {
    background: var(--input-bg);
    border-color: var(--border);
  }
  .session-tab .tab-name:hover {
    border-color: var(--border); /* Hint it's editable */
  }
  
  .session-summary-chip {
    display: inline-block;
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--muted);
    border: 1px solid var(--border);
    background: rgba(127, 146, 190, 0.08);
    border-radius: 999px;
    padding: 2px 8px;
    max-width: 40vw;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Update styles for the renamed Collections panel */
  .collections-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    background: var(--card);
    color: var(--text);
    border-right: 1px solid var(--border);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
    padding: 16px;
    overflow-y: auto;
    z-index: 1000;
    transform: translateX(-110%); /* Hidden by default */
    transition: transform 0.28s ease;
  }
  .collections-panel.open {
    transform: translateX(0); /* Slide in when open */
  }
  /* body.collections-open #collectionsToggle {
    opacity: 1;
    pointer-events: auto;
  } */

  /* Collection Parameters slide-out (left) */
  .params-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    background: var(--card);
    color: var(--text);
    border-right: 1px solid var(--border);
    box-shadow: 8px 0 24px rgba(0,0,0,0.6);
    padding: 16px;
    transform: translateX(-110%);
    transition: transform 0.28s ease;
    z-index: 1200;
    overflow-y: auto;
  }
  .params-panel.open { transform: translateX(0); }
  .params-panel h3 { margin:0 0 8px; font-size:1rem; font-weight:600; }
  .params-panel .field { display:flex; flex-direction:column; gap:6px; margin-bottom:12px; }

  /* location button state colours */
  .btn.loc-on { background:#16a34a !important; border-color:#15803d !important; color:#fff; }
  .btn.loc-off { background:#991b1b !important; border-color:#7f1d1d !important; color:#fff; }

  /* make svg inside control inherit button foreground */
  .btn svg { vertical-align: middle; fill: none; stroke: currentColor; }

  /* icon-only button style (tight square for header icons) */
  .btn.icon-btn { width:40px; height:40px; padding:6px; display:inline-flex; align-items:center; justify-content:center; border-radius:10px; }

  /* export button: inline icon + label, slightly tighter */
  .btn.export { display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px; font-weight:600; }
  .btn.export svg { width:18px; height:18px; }

  /* group two buttons so they look related (export + settings) */
  .btn.group-left { border-top-right-radius:0; border-bottom-right-radius:0; margin-left:8px; }
  .btn.group-right { border-top-left-radius:0; border-bottom-left-radius:0; margin-left:0; border-left:1px solid rgba(0,0,0,0.25); }
  /* NEW: middle-group style for 3-button groups */
  .btn.group-mid { border-radius:0; margin-left:0; border-left:1px solid rgba(0,0,0,0.25); }

  /* keep grouped header buttons together on small screens */
  .btn-group {
    display: inline-flex;
    flex-wrap: nowrap;
    gap: 0;
    align-items: center;
    white-space: nowrap;
  }
  .btn-group .btn {
    flex: 0 0 auto; /* do not grow or shrink */
  }
  /* Header logo sizing (prevents huge rendering on mobile) */
  .brand-logo {
    height: 64px; /* CHANGED: was 32px */
    width: auto;
    margin-right: 12px;
    display: inline-block;
  }

  /* Album icon button in Collections list (restore visible strokes and active colour) */
  .album-btn {
    background: transparent;
    border: 0;
    padding: 0 4px 0 0;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
  }
  .album-btn svg {
    width: 20px;
    height: 20px;
    stroke: #a7acc4; /* light grey stroke on dark panel */
    fill: none;
    transition: stroke .2s, fill .2s;
  }
  .album-btn:hover svg { stroke: #e5e7eb; }
  .album-btn.active svg {
    stroke: var(--accent); /* #22c55e */
    fill: rgba(34,197,94,0.18);
  }

  /* header collection chip */
  .collection-chip {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 4px 10px;
    border-radius: 999px;
    background: rgba(34,197,94,0.12);
    border: 1px solid rgba(34,197,94,0.33);
    color: var(--text); /* CHANGED: use theme text color */
    font-weight: 700;
    cursor: pointer;
    user-select: none;
  }
  .collection-chip:hover {
    background: rgba(34,197,94,0.18);
    border-color: rgba(34,197,94,0.55);
  }
  .collection-chip svg {
    width: 16px;
    height: 16px;
    stroke: #22c55e;
    fill: rgba(34,197,94,0.15);
  }

  .app-footer {
    position: sticky;
    bottom: 0;
    background: var(--header-bg);
    border-top: 1px solid var(--border);
    z-index: 10;
    width: 100%;
  }
  .app-footer .wrap {
    padding: 10px 16px;
    font-size: 12px;
    opacity: .9;
    display: flex;
    justify-content: flex-start;
    align-items: center;
  }
  /* Footer status chip */
  .footer-chip {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 4px 10px;
    border-radius: 999px;
    background: rgba(148,163,184,0.12); /* slate-300-ish */
    border: 1px solid rgba(148,163,184,0.35);
    color: var(--text); /* CHANGED: use theme text color */
    font-weight: 600;
    white-space: nowrap;
  }
  .footer-chip .dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: #94a3b8; /* default grey */
    box-shadow: 0 0 0 2px rgba(148,163,184,0.25);
  }
  .footer-chip.installed {
    background: rgba(34,197,94,0.12);
    border-color: rgba(34,197,94,0.45);
    color: #d1fae5;
  }
  /* NEW: Light theme override for installed chip */
  [data-theme="light"] .footer-chip.installed {
    color: #14532d; /* CHANGED: Darker green (green-900) for better contrast */
    background: rgba(34,197,94,0.2);
    border-color: rgba(34,197,94,0.5);
  }
  .footer-chip.installed .dot {
    background: #22c55e;
    box-shadow: 0 0 0 3px rgba(34,197,94,0.2);
  }
  .footer-chip.not-installed {
    background: rgba(148,163,184,0.12);
    border-color: rgba(148,163,184,0.35);
    color: #e5e7eb;
  }
  /* NEW: Light theme override for not-installed chip */
  [data-theme="light"] .footer-chip.not-installed {
    color: #0f172a; /* Slate-900 */
    border-color: #94a3b8;
    background: rgba(148,163,184,0.25);
  }
  /* NEW: Distinct style for when install is available */
  .footer-chip.install-ready {
    background: rgba(37, 99, 235, 0.15); /* blue-600 */
    border-color: rgba(37, 99, 235, 0.4);
    color: #bfdbfe;
    cursor: pointer;
    animation: pulse-border 2s infinite;
  }
  @keyframes pulse-border {
    0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.4); }
    70% { box-shadow: 0 0 0 6px rgba(37, 99, 235, 0); }
    100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
  }

  /* Base action button (icon + label) */
  .btn.action {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 12px;
    font-weight: 600;
  }
  .btn.action svg { width: 18px; height: 18px; }

  /* Make capture group a full-width toolbar with tall, stacked buttons */
  /* REMOVED old #captureGroup styles */

  /* Small warning chip shown in header when location is OFF */
  .loc-warning {
    display: none;
    margin-left: 8px;
    padding: 2px 8px;
    border-radius: 999px;
    background: rgba(239,68,68,0.15); /* red-500 bg */
    border: 1px solid rgba(239,68,68,0.35);
    color: #fecaca; /* red-200 text */
    font-size: 12px;
    font-weight: 700;
    white-space: nowrap;
  }
  /* NEW: Light theme override for location warning */
  [data-theme="light"] .loc-warning {
    color: #991b1b;
    background: rgba(254, 202, 202, 0.5);
    border-color: #f87171;
  }
  /* NEW: Active state for location chip (Green) */
  .loc-warning.active {
    background: rgba(34,197,94,0.15);
    border-color: rgba(34,197,94,0.35);
    color: #bbf7d0;
  }
  [data-theme="light"] .loc-warning.active {
    color: #14532d;
    background: rgba(34,197,94,0.2);
    border-color: rgba(34,197,94,0.5);
  }

  /* NEW: Action button row styles */
  .button-row {
    display: flex;
    gap: 0.75rem;
    width: 100%;
  }
  .button-row .btn {
    flex: 1 1 0%;
    min-width: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.85rem 1rem;
    border-radius: 999px;
    border: none;
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--text); /* CHANGED: use theme text color */
    cursor: pointer;
    transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.15s;
  }
  .button-row .btn-photo {
    flex: 2; /* Two thirds of the space */
    color: #ffffff !important; /* CHANGED: Force white text for photo button */
  }
  .button-row .btn-params {
    flex: 1; /* One third of the space */
  }
  .button-row .btn .icon svg {
    width: 18px;
    height: 18px;
  }
  .button-row .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  }
  .button-row .btn:active {
    transform: translateY(1px);
    box-shadow: none;
    opacity: 0.9;
  }
  /* NEW: Header rows styling */
  .header-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 8px; /* Space between rows */
  }
  .header-row-1 {
    justify-content: space-between;
    overflow: hidden;
    max-height: 80px;
    margin-bottom: 8px;
    transition: opacity 0.3s ease, transform 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
  }
  .header-row-1.is-hidden {
    opacity: 0;
    transform: translateY(-16px);
    max-height: 0;
    margin-bottom: 0;
    pointer-events: none;
  }
  .header-row-2 .left-group {
    display: flex;
    align-items: center;
    gap: 8px; /* Space between button and chip */
  }
  .header-row-2 .right-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* NEW: floating actions bottom-right */
  .floating-actions {
    position: fixed;
    right: 24px;
    bottom: 24px;
    display: inline-flex;
    flex-direction: row;
    gap: 0;
    z-index: 60;
  }
  .floating-actions .btn-group {
    display: inline-flex;
    flex-wrap: nowrap;
  }
  .floating-actions .btn {
    box-shadow: 0 12px 24px rgba(0,0,0,0.35);
    border-radius: 999px;
    padding: 10px 16px;
  }
  /* override header spacing so the group joins tightly */
  .floating-actions .btn.group-left { margin-left: 0; }
  .floating-actions .btn svg { pointer-events: none; }
  @media (max-width: 640px) {
    .floating-actions { right: 16px; bottom: 16px; }
  }

  /* HEIC processing toast */
  .heic-processing {
    position: fixed;
    top: 16px;
    right: 16px;
    z-index: 2000;
    background: rgba(17,24,39,0.92);
    color: #e5e7eb;
    padding: 10px 14px;
    border-radius: 10px;
    border: 1px solid var(--border);
    box-shadow: 0 6px 20px rgba(0,0,0,0.35);
    display: none;
    align-items: center;
    gap: 10px;
    font-weight: 700;
  }
  [data-theme="light"] .heic-processing {
    background: rgba(255,255,255,0.96);
    color: #0f172a;
  }
  /* Debug meta console (compact, optional) */
  .debug-meta {
    position: fixed;
    bottom: 16px;
    left: 16px;
    z-index: 2000;
    min-width: 220px;
    max-width: 320px;
    background: rgba(17,24,39,0.92);
    color: #e5e7eb;
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid var(--border);
    box-shadow: 0 6px 20px rgba(0,0,0,0.35);
    font-size: 12px;
    line-height: 1.4;
    display: none;
    pointer-events: none;
  }
  [data-theme="light"] .debug-meta {
    background: rgba(255,255,255,0.96);
    color: #0f172a;
  }
  /* Added: delete button styling */
  .thumb .delete-btn {
    position:absolute;
    top:6px;
    right:6px;
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .delete-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .delete-btn:focus {
    outline:2px solid #f87171;
    outline-offset:2px;
  }
  .thumb .delete-btn svg {
    width:16px;
    height:16px;
    stroke:#f87171;
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }

  /* NEW: replace button styling (top-left) */
  .thumb .replace-btn {
    position:absolute;
    top:6px;
    left:6px;
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .replace-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .replace-btn:focus {
    outline:2px solid #22c55e;
    outline-offset:2px;
  }
  .thumb .replace-btn svg {
    width:16px;
    height:16px;
    stroke:#22c55e; /* accent */
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }

  /* NEW: rotate button styling (top-left, next to replace) */
  .thumb .rotate-btn {
    position:absolute;
    top:6px;
    left:42px; /* 6px + 30px width + 6px gap */
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .rotate-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .rotate-btn:focus {
    outline:2px solid #3b82f6;
    outline-offset:2px;
  }
  .thumb .rotate-btn svg {
    width:16px;
    height:16px;
    stroke:#3b82f6;
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }
  /* NEW: swap-dimensions button styling (top-left, next to rotate) */
  .thumb .swap-btn {
    position:absolute;
    top:6px;
    left:78px; /* 6px + (30px+6px) * 2 */
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .swap-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .swap-btn:focus {
    outline:2px solid #f59e0b;
    outline-offset:2px;
  }
  .thumb .swap-btn svg {
    width:16px;
    height:16px;
    stroke:#f59e0b;
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }

  /* Empty gallery placeholder */
  .gallery-placeholder {
    grid-column: 1 / -1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 28px 16px;
    border: 1px dashed #334155;
    border-radius: 12px;
    color: #94a3b8;
    background: rgba(2, 6, 23, 0.35);
    text-align: center;
  }
  .gallery-placeholder svg {
    width: 36px;
    height: 36px;
    stroke: #64748b;
    fill: none;
  }
  .gallery-placeholder small { opacity: 0.8; }

  /* MODE STYLES: green (camera) / blue (gallery) */
  #btnSnap { position:relative; overflow:hidden; }
  #btnSnap.mode-camera {
    background:#16a34a !important;
    border-color:#15803d !important;
  }
  #btnSnap.mode-camera:hover { background:#18b152 !important; }
  #btnSnap.mode-gallery {
    background:#1d4ed8 !important;
    border-color:#1e40af !important;
  }
  #btnSnap.mode-gallery:hover { background:#235ae8 !important; }

  /* Long-press visual progress (leftâ†’right fade) */
  #btnSnap .press-progress {
    position:absolute;
    top:0; left:0;
    height:100%;
    width:0;
    background:linear-gradient(90deg,rgba(255,255,255,0.15),rgba(255,255,255,0.35));
    pointer-events:none;
  }
  #btnSnap.progressing .press-progress {
    animation: pressFill 1s linear forwards;
  }
  @keyframes pressFill {
    from { width:0; }
    to { width:100%; }
  }

  /* When mode changes flash subtle overlay */
  #btnSnap.mode-switch-flash::after {
    content:'';
    position:absolute; inset:0;
    background:radial-gradient(circle at 30% 50%, rgba(255,255,255,0.35), rgba(255,255,255,0));
    animation: flashFade .5s ease;
    pointer-events:none;
  }
  @keyframes flashFade { from { opacity:1; } to { opacity:0; } }

  .mode-hint { font-style: italic; }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <!-- Row 1: Logo left, title right -->
    <div class="header-row header-row-1">
      <div style="display:flex;align-items:center;font-weight:700;font-size:15px;letter-spacing:.2px">
        <img src="./brownfield_logo.png" alt="Brownfield Solutions" loading="lazy" class="brand-logo" />
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <button id="btnTheme" class="btn icon-btn" title="Toggle theme" aria-label="Toggle theme">ðŸŒ™</button>
        <img src="./icons/icon-512.png" alt="Site Evidence Capture" loading="lazy" style="height: 64px; width: auto;" />
      </div>
    </div>
    
    <!-- Row 2: Collection button + count chip left, location right -->
    <div class="header-row header-row-2">
      <div class="left-group">
        <div id="tabsSummary" style="font-weight: 500; opacity: 0.8;"></div>
        <span class="count-chip" id="count">0 items</span>
      </div>
      <div class="right-group">
        <span id="locWarning" class="loc-warning" role="status" aria-live="polite">Location OFF</span>
        <button id="btnEnableLoc" class="btn loc-off icon-btn" title="Enable location" aria-pressed="false" style="margin-right:0">
          <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 2C8.686 2 6 4.686 6 8c0 5.25 6 12 6 12s6-6.75 6-12c0-3.314-2.686-6-6-6z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
            <circle cx="12" cy="8" r="2.2" stroke="currentColor" stroke-width="1.2" fill="none"/>
          </svg>
        </button>
      </div>
    </div>
  </div>
</header>

<main class="wrap" style="padding-top:14px;padding-bottom:72px">
  <section class="card">
    <div class="row">
      <input id="fileInput" type="file" accept="image/*,.heic,.HEIC,.heif,.HEIF,.hif,.HIF" capture="environment" style="display:none" /> <!-- CHANGED: accept HEIC -->
      <!-- REPLACED: button group with new structure and styles -->
      <div class="button-row" id="captureGroup">
        <button id="btnSnap" class="btn btn-photo" title="Take or select photo" aria-label="Take or select photo" data-mode="camera">
          <span class="press-progress" aria-hidden="true"></span>
          <span class="icon">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M9 4l1.5-2h3L15 4h3a2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h3z"/>
              <circle cx="12" cy="12" r="3.25"/>
            </svg>
          </span>
          <span>Photo</span>
          <span class="mode-hint" id="captureModeHint">Camera</span>
        </button>
      
        <!-- Parameters -->
        <button id="paramsToggle" class="btn btn-params" title="Open collection parameters" aria-label="Open collection parameters">
          <span class="icon">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M9 3h6a2 2 0 012 2h1a2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V7a2 2 0 012-2h1a2 2 0 012-2z"/>
              <path d="M10 3h4v2h-4z"/>
              <path d="M9 10h6"/>
              <path d="M9 13h6"/>
              <path d="M9 16h4"/>
            </svg>
          </span>
          <span>Project Details</span>
        </button>
      </div>

      <!-- location control moved to header; status text removed (indicator is the icon colour) -->

      <!-- layout/orientation moved into Settings panel -->
      <input id="collectionTitle" type="hidden" value="Site Evidence Photos" />
    </div>

    <!-- New: Client, Project Title, and Photographer fields (moved to slide-out panel â€” keep hidden fields for compatibility) -->
    <div style="display:none;">
      <input id="clientName" type="hidden" value="" />
      <input id="projectTitle" type="hidden" value="" />
      <input id="photographerName" type="hidden" value="" />
    </div>

    <!-- Slide-out settings panel -->
    <div id="settingsPanel" style="position:fixed;right:-320px;top:0;width:320px;max-width:90vw;height:100%;background:var(--card);border-left:1px solid var(--border);padding:16px;box-shadow:-8px 0 24px rgba(0,0,0,.6);transition:right .25s ease;z-index:1200;overflow-y:auto;-webkit-overflow-scrolling:touch;">
      <!-- CHANGED: added header row with close button -->
      <div class="settings-header" style="display:flex;align-items:center;justify-content:space-between;margin:0 0 12px">
        <h3 style="margin:0">Export Settings</h3>
        <button id="btnCloseSettings" class="btn icon-btn" aria-label="Close settings" title="Close settings" style="width:36px;height:36px;padding:4px;display:flex;align-items:center;justify-content:center">&times;</button>
      </div>
      <div style="display:flex;flex-direction:column;gap:10px">
        
        <label>Layout:
          <select id="layout" style="width:100%">
            <option value="2">2 per A4 page</option>
            <option value="4" selected>4 per A4 page</option>
          </select>
        </label>
        <label>Orientation:
          <select id="orientation" style="width:100%">
            <option value="portrait">Portrait (A4)</option>
            <option value="landscape" selected>Landscape (A4)</option>
          </select>
        </label>
        
        <!-- NEW: Auto Sort Checkbox -->
        <div style="margin-top:8px;padding:8px;border:1px solid var(--border);border-radius:10px;background:rgba(0,0,0,0.1)">
          <label style="display:flex;align-items:center;gap:8px;font-size:13px;font-weight:600;cursor:pointer">
            <input id="chkAutoSort" type="checkbox" /> 
            Automatic Image Sorting
          </label>
          <small class="hint" style="display:block;margin-top:4px;line-height:1.3">
            Groups images by shape (Landscape/Portrait) to minimize white space gaps on pages.
          </small>
          
          <!-- NEW: No Mix Checkbox (Dependent on AutoSort) -->
          <div style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border)">
            <label id="lblNoMix" style="display:flex;align-items:center;gap:8px;font-size:13px;font-weight:600;cursor:pointer;opacity:0.5">
              <input id="chkNoMix" type="checkbox" disabled /> 
              Don't Mix Orientations
            </label>
            <small class="hint" style="display:block;margin-top:4px;line-height:1.3">
              Starts a new page when image orientation changes (prevents mixing Landscape/Portrait on one slide).
            </small>
          </div>
        </div>
        
        <!-- NEW: PPTX attribute toggles -->
        <div style="display:flex;flex-direction:column;gap:6px;margin-top:4px;padding:8px;border:1px solid var(--border);border-radius:10px;">
          <strong style="font-size:13px">PPTX Caption Attributes</strong>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrTimestamp" type="checkbox" checked /> Timestamp
          </label>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrPosition" type="checkbox" checked /> Position (BNG / Lat,Lon)
          </label>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrAccuracy" type="checkbox" checked /> Accuracy (Â± m)
          </label>
          <!-- NEW: Photographer toggle (input removed from here) -->
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrPhotographer" type="checkbox" checked /> Photographer initials
          </label>
        </div>
        <div style="margin-top:6px"><small class="hint">These affect exports (A4 sizing)</small></div>

        <div style="margin-top:12px; padding-top:12px; border-top:1px solid var(--border); display:flex; flex-direction:column; gap:10px;">
          <small style="opacity:0.8;">Tip: If none are selected, export will use all photos.</small>
          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <button id="btnSelectMode" class="btn" type="button" title="Select photos to export">Select photos</button>
            <span id="selectionCountInline" class="count-chip" aria-live="polite">All photos</span>
            <button id="btnClearSelection" class="btn" type="button" title="Clear current selections">Clear selection</button>
          </div>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button id="btnConfirmExport" class="btn primary" style="flex:1; padding:12px; font-weight:bold; display:flex; align-items:center; justify-content:center; gap:8px;">
              <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
              Generate PowerPoint
            </button>
            <button id="btnExportZip" class="btn" type="button" style="flex:1; padding:12px; display:flex; align-items:center; justify-content:center; gap:8px;" title="Export photos as .zip of JPGs">
              <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M14 3h3a2 2 0 0 1 2 2v3M14 21h3a2 2 0 0 0 2-2v-3M10 3H7a2 2 0 0 0-2 2v3M10 21H7a2 2 0 0 1-2-2v-3M10 7h4M10 11h4M10 15h4"/></svg>
              Export photos (.zip)
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- REMOVED: Footer text paragraph as requested -->
  </section>

  <section id="gallery" class="grid" style="margin-top:14px"></section>

  <!-- NEW: Bulk Upload Area -->
  <div style="margin-top: 32px; margin-bottom: 20px; text-align: center;">
    <input id="bulkInput" type="file" accept="image/*,.heic,.HEIC,.heif,.HEIF,.hif,.HIF" multiple style="display:none" /> <!-- CHANGED: accept HEIC -->
    <button id="btnBulkUpload" class="btn" style="width: 100%; padding: 16px; border: 2px dashed #334155; background: rgba(15, 23, 42, 0.6); color: #94a3b8;">
      <div style="font-weight:600; font-size:1.1em; margin-bottom:4px;">+ Bulk Upload Photos</div>
      <div style="font-size:0.85em; opacity:0.8;">GPS metadata will be imported if available</div>
    </button>
  </div>
</main>

<!-- NEW: floating primary actions -->
<div class="floating-actions" role="region" aria-label="Primary actions">
  <span class="btn-group">
    <!-- CHANGED: Removed group-left class, removed btnSettings -->
    <button id="btnExportPPTX" class="btn danger export" title="Export Options" aria-label="Export Options">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" stroke="currentColor" stroke-width="1.2" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="4" width="18" height="14" rx="2" />
        <path d="M8 9h8M8 13h5" />
        <path d="M12 18v3" />
      </svg>
      <span>PPT Export</span>
    </button>
  </span>
</div>

<!-- NEW: Floating Zoom Button -->
<button id="btnZoom" class="floating-zoom" title="Change zoom level" aria-label="Change zoom level">
  <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="11" cy="11" r="8"></circle>
    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
    <line x1="11" y1="8" x2="11" y2="14"></line>
    <line x1="8" y1="11" x2="14" y2="11"></line>
  </svg>
</button>

<div id="selectionFloating" class="selection-floating" aria-live="polite" aria-label="Selection actions">
  <div class="panel">
    <div id="selectionSummary" class="summary">0 selected</div>
    <div class="actions">
      <button id="btnExportSelected" class="btn primary" type="button" disabled>Confirm selected</button>
      <button id="btnCancelSelection" class="btn" type="button">Cancel</button>
    </div>
  </div>
</div>


<!-- HEIC processing toast -->
<div id="heicProcessing" class="heic-processing" role="status" aria-live="polite">
  <span id="heicProcessingText">Processing HEIC/HEIFâ€¦</span>
</div>

<!-- Debug meta console (hidden by default) -->
<div id="debugMeta" class="debug-meta" role="status" aria-live="polite"></div>

<!-- Description dialog -->
<dialog id="descDialog">
  <header style="display:flex;justify-content:space-between;align-items:center">
    <strong>Add description</strong>
    <button id="btnUnlockMeta" type="button" class="btn icon-btn" title="Unlock metadata" style="width:32px;height:32px;padding:4px;display:none;border:none;background:transparent">
      <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
    </button>
  </header>
  <div class="content">
    <p style="margin:0 0 8px">Describe the evidence in one or two lines (who/what/where/why).</p>
    <textarea id="descText" rows="4" style="width:100%;resize:vertical;background:var(--input-bg);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px" placeholder="e.g., TP03: Sub-base compaction adjacent to gridline Câ€“D. Roller: Bomag BW120."></textarea>
    <div class="row" style="margin-top:8px">
      <label>Date/time:
        <input id="descWhen" type="datetime-local" step="1" />
      </label>
      <label style="flex:1;min-width:100px">Initials:
        <input id="descInitials" type="text" placeholder="DG" style="width:100%" />
      </label>
    </div>
    <div style="margin-top:8px">
      <label style="display:block;font-size:13px;margin-bottom:6px">Position (device â†’ BNG) <span class="hint" style="font-size:12px">(*) approximate</span></label>
      <input id="descPosition" type="text" readonly style="width:100%;background:var(--input-bg);color:var(--text); border:1px solid var(--border);border-radius:8px;padding:8px" />
      <div style="margin-top:6px;font-size:12px;opacity:0.75;">Imported photos work best on desktop browser; some mobile galleries can redact metadata.</div>
    </div>
  </div>
  <div class="actions">
    <button id="descCancel">Cancel</button>
    <button id="descOK" class="primary">Save</button>
  </div>
</dialog>

<!-- NEW: Bulk Upload Confirmation Dialog -->
<dialog id="bulkDialog">
  <header><strong>Bulk Upload</strong></header>
  <div class="content">
    <p id="bulkMsg" style="margin:0 0 12px">Selected 0 photos.</p>
    <div style="background:rgba(255,255,255,0.05);padding:10px;border-radius:8px;margin-bottom:12px">
      <label style="display:flex;align-items:center;gap:8px;font-weight:600;cursor:pointer">
        <input id="chkBulkRotate" type="checkbox" /> Force landscape
      </label>
      <small style="display:block;margin-top:4px;opacity:0.7;margin-left:24px">Rotates portrait images 90Â° clockwise to fit layout.</small>
    </div>
    <p class="hint" style="margin:0">Note: Descriptions are skipped during bulk upload.</p>
  </div>
  <div class="actions">
    <button id="btnBulkCancel">Cancel</button>
    <button id="btnBulkOk" class="primary">Upload</button>
  </div>
</dialog>

<!-- NEW: Zip Export Confirmation Dialog -->
<dialog id="zipConfirmDialog">
  <header><strong>Confirm Export</strong></header>
  <div class="content">
    <p id="zipConfirmText" style="margin:0 0 12px">Are you sure you want to export all photos from this collection?</p>
    <label style="display:flex;align-items:center;gap:8px;font-weight:600;cursor:pointer">
      <input id="chkZipIncludePPTX" type="checkbox" checked />
      Include PowerPoint (.pptx)
    </label>
    <small class="hint" style="display:block;margin-top:6px;line-height:1.3">Uses current export settings (layout, orientation, captions).</small>
  </div>
  <div class="actions">
    <button id="btnZipCancel" type="button">Cancel</button>
    <button id="btnZipConfirm" type="button" class="primary">Export</button>
  </div>
</dialog>

<!-- Rename the slide-out panel for managing collections -->
<div id="collections" class="collections-panel" aria-hidden="true">
  <div class="collections-header-row" style="display:flex;align-items:center;gap:8px;">
    <button id="collectionsClose" class="btn" type="button">Close</button>
    <h2 class="collections-title" style="margin:0;font-size:1rem;font-weight:600;">Collections</h2>
    <div class="flex-spacer" style="flex:1;"></div>
  </div>
  <p class="collections-hint">Manage active collections. Click one to switch to it.</p>
  <div class="collections-new-btn-row" style="margin-top:8px; display:flex; gap:8px;">
    <button id="newCollectionBtn" class="btn" type="button">ï¼‹ New Collection</button>
    <!-- NEW: Import label triggers native file picker -->
    <label for="importCollectionInput" class="btn" style="cursor:pointer;">Import Collection</label>
    <input type="file" id="importCollectionInput" accept=".json,application/json" style="display:none" />
  </div>
  <ul id="collectionsList" class="collections-list" style="list-style:none;padding:0;margin-top:10px;"></ul>
</div>

<!-- Add the params panel markup (place near other slide-out panels) -->
<div id="paramsPanel" class="params-panel" aria-hidden="true">
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
    <button id="paramsClose" class="btn" type="button">Close</button>
    <h3 style="margin:0">Project Details</h3>
  </div>

  <div style="margin-top:8px">
    <div class="field">
      <label style="font-size:12px">Job Name</label>
      <input id="params_collectionTitle" type="text" placeholder="Job Name" />
    </div>
    <div class="field">
      <!-- CHANGED label from Job No. to Client -->
      <label style="font-size:12px">Client</label>
      <input id="params_clientName" type="text" placeholder="Client" />
    </div>
    <div class="field">
      <label style="font-size:12px">Job No.</label>
      <input id="params_projectTitle" type="text" placeholder="Job No." />
    </div>
    <div class="field">
      <label style="font-size:12px">Photoboard Title</label>
      <input id="params_photographerName" type="text" placeholder="Photoboard Title" />
    </div>
    <div style="margin-top:12px;text-align:right">
      <button id="paramsSave" class="btn primary">Save</button>
    </div>

    <!-- NEW: Moved Force Landscape button here -->
    <hr style="border:0;border-top:1px solid var(--border);margin:20px 0 12px" />
    <button id="btnForceLandscape" class="btn warn" style="width:100%;font-size:13px">
      Force all to Landscape
    </button>
    <small class="hint" style="display:block;margin-top:6px;text-align:center;opacity:0.7">Rotates all portrait images in this collection.</small>
  </div>
</div>

<!-- Libraries (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js" crossorigin="anonymous"></script>
<script src="./vendor/exif-js/exif.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/heic-to@1.3.0/dist/iife/heic-to.js"></script> <!-- NEW: robust HEIC converter -->
<script src="./vendor/heic2any/heic2any.min.js"></script> <!-- ADDED: HEIC conversion library (local copy for offline use) -->
<!-- include the helper as an ES module so addBottomRightTable is available -->
<script type="module" src="./pptx_table.js"></script>

<script>
  // Register the static service worker so scope works correctly on GitHub Pages
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js', { scope: './' }).catch(()=>{});
    });
  }
</script>

<script>
/* ---------------- Minimal IndexedDB ---------------- */
const DB_NAME='evidenceDB', STORE='items', SESSIONS_STORE='sessions', FS_HANDLES_STORE = 'fsHandles'; // NEW STORE
function idbOpen(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 3); // DB version 3
    req.onupgradeneeded = (event) => {
      const db = event.target.result;
      // create legacy items store if missing
      if (!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
      }
      // create sessions store if missing (autoIncrement per spec)
      if (!db.objectStoreNames.contains(SESSIONS_STORE)) {
        db.createObjectStore(SESSIONS_STORE, { keyPath: 'id', autoIncrement: true });
      }
      // NEW: create fsHandles store
      if (!db.objectStoreNames.contains(FS_HANDLES_STORE)) {
        db.createObjectStore(FS_HANDLES_STORE);
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
    req.onblocked = () => console.warn('IndexedDB open blocked - close other tabs using this site to upgrade the database.');
  });
}
async function idbAdd(obj){
  const db = await idbOpen();
  const clone = { ...obj };
  delete clone._selected; // transient UI flag
  delete clone._selectedOrder; // transient UI flag
  return new Promise((res,rej)=>{
    const tx=db.transaction(STORE,'readwrite');
    tx.objectStore(STORE).add(clone).onsuccess=e=>res(e.target.result);
    tx.onerror=()=>rej(tx.error);
  });
}
// NEW: IDB Helpers for patching
async function idbPut(store, obj){
  const db = await idbOpen();
  const clone = { ...obj };
  delete clone._selected; // transient UI flag
  delete clone._selectedOrder; // transient UI flag
  return new Promise((res,rej)=>{
    const tx=db.transaction(store,'readwrite');
    tx.objectStore(store).put(clone).onsuccess=e=>res(e.target.result);
    tx.onerror=()=>rej(tx.error);
  });
}
async function idbGet(store, key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readonly'); const req=tx.objectStore(store).get(key); req.onsuccess=()=>res(req.result); tx.onerror=()=>rej(tx.error); }); }
async function idbDelete(store, key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).delete(key).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error); }); }
async function idbAll(){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const req=tx.objectStore(STORE).getAll(); req.onsuccess=()=>res(req.result||[]); req.onerror=()=>rej(req.error); }); }

// New helpers for sessions store
async function idbAddSession(session){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readwrite'); tx.objectStore(SESSIONS_STORE).put(session).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error); }); }
async function idbGetSession(id){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readonly'); const req=tx.objectStore(SESSIONS_STORE).get(id); req.onsuccess=()=>res(req.result||null); req.onerror=()=>rej(req.error); }); }
async function idbAllSessions(){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readonly'); const req=tx.objectStore(SESSIONS_STORE).getAll(); req.onsuccess=()=>res(req.result||[]); req.onerror=()=>rej(req.error); }); }
async function idbDeleteSession(id){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readwrite'); tx.objectStore(SESSIONS_STORE).delete(id).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error); }); }

// NEW: Missing helper for saving individual items
async function saveItem(item) {
  // Create a shallow copy to avoid modifying the in-memory object used by the UI
  const clone = { ...item };
  // Strip transient UI properties that IDB cannot store (like DOM elements)
  delete clone._preview;
  delete clone._loading;
  delete clone._needsPreview;
  delete clone._objectURL;
  delete clone._hasBlob;
  delete clone._selected;
  delete clone._selectedOrder;

  // Preserve stored full-res data when the in-memory copy is thumb-only
  if (!clone.blob && !clone.dataURL && !clone.imageData && clone.id) {
    try {
      const stored = await idbGet(STORE, clone.id);
      if (stored) {
        if (stored.blob) clone.blob = stored.blob;
        if (stored.dataURL) clone.dataURL = stored.dataURL;
        if (stored.imageData) clone.imageData = stored.imageData;
        if (stored.w && !clone.w) clone.w = stored.w;
        if (stored.h && !clone.h) clone.h = stored.h;
      }
    } catch (e) {
      console.warn('saveItem: failed to merge stored blob for', clone.id, e);
    }
  }

  return idbPut(STORE, clone);
}

// NEW: Helpers for File System Access handles
async function saveDirectoryHandle(handle) {
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction(FS_HANDLES_STORE, 'readwrite');
    tx.objectStore(FS_HANDLES_STORE).put(handle, 'directory').onsuccess = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function getDirectoryHandle() {
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction(FS_HANDLES_STORE, 'readonly');
    const req = tx.objectStore(FS_HANDLES_STORE).get('directory');
    req.onsuccess = () => res(req.result || null);
    req.onerror = () => rej(req.error);
  });
}

/* ---------------- App state + UI refs ---------------- */
const state = { items: [], client: '', project: '', photographer: '', photographerInitials: '' };
const fileInput = document.getElementById('fileInput');
const btnSnap = document.getElementById('btnSnap');
const captureModeLabel = document.getElementById('captureModeLabel');
const captureModeHint = document.getElementById('captureModeHint');
const gallery = document.getElementById('gallery');
const collectionTitleInput = document.getElementById('collectionTitle');
const clientNameInput = document.getElementById('clientName'); // New
const projectTitleInput = document.getElementById('projectTitle'); // New
const photographerNameInput = document.getElementById('photographerName'); // New
const descDialog = document.getElementById('descDialog');
const descText = document.getElementById('descText');
const descWhen = document.getElementById('descWhen');
const descInitials = document.getElementById('descInitials'); // NEW REF
const descPosition = document.getElementById('descPosition');
const descOK = document.getElementById('descOK');
const descCancel = document.getElementById('descCancel');
const btnUnlockMeta = document.getElementById('btnUnlockMeta'); // NEW
const btnExportPPTX = document.getElementById('btnExportPPTX');
const btnConfirmExport = document.getElementById('btnConfirmExport'); // NEW
const btnExportZip = document.getElementById('btnExportZip');
const zipConfirmDialog = document.getElementById('zipConfirmDialog');
const zipConfirmText = document.getElementById('zipConfirmText');
const chkZipIncludePPTX = document.getElementById('chkZipIncludePPTX');
const btnZipConfirm = document.getElementById('btnZipConfirm');
const btnZipCancel = document.getElementById('btnZipCancel');
const layoutSel = document.getElementById('layout');
const mainEl = document.querySelector('main');
let isSelecting = false;
const btnSelectMode = document.getElementById('btnSelectMode');
const btnClearSelection = document.getElementById('btnClearSelection');
const selectionFloating = document.getElementById('selectionFloating');
const selectionSummary = document.getElementById('selectionSummary');
const btnExportSelected = document.getElementById('btnExportSelected');
const btnCancelSelection = document.getElementById('btnCancelSelection');
const selectionCountInline = document.getElementById('selectionCountInline');

/* NEW: Unlock metadata handler */
if(btnUnlockMeta){
  btnUnlockMeta.addEventListener('click', () => {
    const isLocked = descWhen.disabled;
    if (isLocked) {
      if (confirm("Unlock metadata fields? Modifying the date or position may overwrite original capture data.")) {
        descWhen.disabled = false;
        descWhen.style.opacity = '1';
        descPosition.disabled = false;
        descPosition.style.opacity = '1';
        descPosition.readOnly = false;
        // Open lock icon
        btnUnlockMeta.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;
      }
    } else {
      // Lock
      descWhen.disabled = true;
      descWhen.style.opacity = '0.5';
      descPosition.disabled = true;
      descPosition.style.opacity = '0.5';
      descPosition.readOnly = true;
      // Closed lock icon
      btnUnlockMeta.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;
    }
  });
}

const orientationSel = document.getElementById('orientation');
const btnForceLandscape = document.getElementById('btnForceLandscape');
const chkAutoSort = document.getElementById('chkAutoSort'); // NEW
const chkNoMix = document.getElementById('chkNoMix'); // NEW
const lblNoMix = document.getElementById('lblNoMix'); // NEW

// NEW: Handle NoMix dependency
if(chkAutoSort && chkNoMix){
  chkAutoSort.addEventListener('change', ()=>{
    const isOn = chkAutoSort.checked;
    chkNoMix.disabled = !isOn;
    if(lblNoMix) lblNoMix.style.opacity = isOn ? '1' : '0.5';
    if(!isOn) chkNoMix.checked = false;
  });
}

function clearSelectionFlags() {
  state.items.forEach(i => {
    if (!i) return;
    if ('_selected' in i) delete i._selected;
    if ('_selectedOrder' in i) delete i._selectedOrder;
  });
}
function normalizeSelectionOrder() {
  const selected = state.items.filter(i => i && i._selected);
  selected.sort((a, b) => (a._selectedOrder || 0) - (b._selectedOrder || 0));
  selected.forEach((item, idx) => { item._selectedOrder = idx + 1; });
  return selected.length;
}
function getSelectedItems() {
  normalizeSelectionOrder();
  const selected = state.items.filter(i => i && i._selected);
  selected.sort((a, b) => (a._selectedOrder || 0) - (b._selectedOrder || 0));
  return selected;
}
function updateSelectionUI() {
  const selectedCount = getSelectedItems().length;
  if (gallery) gallery.classList.toggle('select-mode', isSelecting);
  if (selectionFloating) selectionFloating.classList.toggle('visible', isSelecting && state.items.length > 0);
  if (selectionSummary) selectionSummary.textContent = isSelecting ? `${selectedCount} selected` : '0 selected';
  if (btnExportSelected) btnExportSelected.disabled = !isSelecting || selectedCount === 0;
  if (btnSelectMode) btnSelectMode.disabled = state.items.length === 0;
  if (btnExportZip) btnExportZip.disabled = state.items.length === 0;
  if (selectionCountInline) selectionCountInline.textContent = selectedCount ? `${selectedCount} selected` : 'All photos';
  if (btnClearSelection) btnClearSelection.disabled = selectedCount === 0;
  if (mainEl) mainEl.style.paddingBottom = '72px';
}
function enterSelectionMode() {
  if (!state.items.length) return;
  isSelecting = true;
  clearSelectionFlags();
  updateSelectionUI();
  renderGallery();
}
function cancelSelectionMode() {
  isSelecting = false;
  clearSelectionFlags();
  updateSelectionUI();
  renderGallery();
}
if (btnClearSelection) {
  btnClearSelection.addEventListener('click', () => {
    clearSelectionFlags();
    updateSelectionUI();
    renderGallery();
  });
}
function toggleItemSelection(item) {
  if (!isSelecting || !item) return;
  if (item._selected) {
    delete item._selected;
    delete item._selectedOrder;
  } else {
    item._selected = true;
    item._selectedOrder = getSelectedItems().length + 1;
  }
  normalizeSelectionOrder();
  updateSelectionUI();
  renderGallery();
}
function getExportList() {
  const sessionItems = [...state.items];
  const chosen = getSelectedItems();
  if (chosen.length) {
    normalizeSelectionOrder();
    return chosen;
  }
  return sessionItems;
}
function confirmSelection() {
  isSelecting = false;
  updateSelectionUI();
  renderGallery();
  settingsPanel.style.right = '0px';
}
updateSelectionUI();

// NEW: Bulk Dialog Refs
const bulkDialog = document.getElementById('bulkDialog');

/* REMOVED: maxwInput and marginsInput */
/* NEW: PPTX attribute checkboxes */
const attrTimestampChk = document.getElementById('attrTimestamp');
const attrPositionChk  = document.getElementById('attrPosition');
const attrAccuracyChk  = document.getElementById('attrAccuracy');
const attrPhotographerChk = document.getElementById('attrPhotographer');          // NEW
const countEl = document.getElementById('count');

const btnEnableLoc = document.getElementById('btnEnableLoc');
// REMOVED: const btnSettings = document.getElementById('btnSettings');
const settingsPanel = document.getElementById('settingsPanel');
const btnCloseSettings = document.getElementById('btnCloseSettings');
// NEW: folder picker refs
const btnChooseFolder = document.getElementById('btnChooseFolder');
const folderStatus = document.getElementById('folderStatus');
const btnClear = document.getElementById('btnClear'); // NEW: guard missing clear button
// NEW: Bulk upload refs
const btnBulkUpload = document.getElementById('btnBulkUpload');
const bulkInput = document.getElementById('bulkInput');
const btnZoom = document.getElementById('btnZoom'); // NEW
// HEIC processing toast refs
const heicProcessingEl = document.getElementById('heicProcessing');
const heicProcessingText = document.getElementById('heicProcessingText');
let heicProcessingCount = 0;
// Debug meta console
const debugMetaEl = document.getElementById('debugMeta');
let debugMetaEnabled = false; // set true to display pulled EXIF/metadata for debugging
window.enableMetaDebug = () => { debugMetaEnabled = true; if (debugMetaEl) debugMetaEl.style.display = 'block'; };
window.disableMetaDebug = () => { debugMetaEnabled = false; if (debugMetaEl) debugMetaEl.style.display = 'none'; };
let debugMetaPrompted = false;
let debugMetaAuto = false; // auto-show during HEIC toast after user confirmation
// TEMP: lightweight import debug toast + console
let importDebugEl = null;
function showImportDebug(msg, level = 'info') {
  const fn = level === 'error' ? console.error : console.log;
  fn?.('[IMPORT]', msg);
  try {
    if (!importDebugEl) {
      importDebugEl = document.createElement('div');
      importDebugEl.id = 'importDebug';
      Object.assign(importDebugEl.style, {
        position: 'fixed',
        right: '12px',
        bottom: '12px',
        zIndex: 3000,
        maxWidth: '360px',
        background: 'rgba(15,23,42,0.9)',
        color: '#e5e7eb',
        padding: '10px 12px',
        borderRadius: '12px',
        border: '1px solid #334155',
        boxShadow: '0 10px 24px rgba(0,0,0,0.35)',
        fontSize: '13px',
        pointerEvents: 'none'
      });
      document.body.appendChild(importDebugEl);
    }
    const row = document.createElement('div');
    row.textContent = `${new Date().toLocaleTimeString()} ${msg}`;
    row.style.marginBottom = '4px';
    row.style.color = level === 'error' ? '#fca5a5' : '#cbd5e1';
    importDebugEl.appendChild(row);
    setTimeout(() => {
      row.remove();
      if (importDebugEl && importDebugEl.childElementCount === 0) {
        importDebugEl.remove();
        importDebugEl = null;
      }
    }, level === 'error' ? 12000 : 8000);
  } catch (_) {}
}

// NEW: Zoom toggle handler
if(btnZoom){
  let zoomLevel = 0; // 0=Max, 1=Med, 2=Small
  btnZoom.addEventListener('click', () => {
    zoomLevel = (zoomLevel + 1) % 3;
    // Reset classes
    gallery.classList.remove('zoom-1', 'zoom-2');
    if(zoomLevel === 1) gallery.classList.add('zoom-1');
    if(zoomLevel === 2) gallery.classList.add('zoom-2');
  });
}

// params panel refs
const paramsToggle = document.getElementById('paramsToggle');
const paramsPanel = document.getElementById('paramsPanel');
const paramsClose = document.getElementById('paramsClose');
const paramsSave = document.getElementById('paramsSave');
const params_collectionTitle = document.getElementById('params_collectionTitle');
const params_clientName = document.getElementById('params_clientName');
const params_projectTitle = document.getElementById('params_projectTitle');
const params_photographerName = document.getElementById('params_photographerName');

// location state
let pendingCanvas=null;
let pendingBlob=null; // NEW: Explicit declaration
let pendingGPS=null;
let editingItem=null; // NEW: Track item being edited
let locationEnabled = false;      // default to OFF so warning chip shows immediately
let lastKnownPos = null;
let watchId = null;
let dirHandle = null; // NEW: hold the directory handle in memory
let isLocationPending = false; // NEW: Track background location status
let locationTaskID = 0; // NEW: Track active location task
let shutterGPSPromise = null; // NEW: Snapshot GPS captured at shutter press
let heicFallbackLoader = null; // NEW: Lazy loader for legacy HEIC decoder
const HEIC_SCRIPT_LOCAL = './vendor/heic2any/heic2any.min.js'; // Local copy to avoid CDN reliance
const HEIC_SCRIPT_FALLBACK = 'https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js'; // Remote fallback if local fails

/* --- Simple long-press controller (1s) --- */
const MODE = {
  camera:  { capture: true,  label: 'Mode A', hint: 'Camera'  },
  gallery: { capture: false, label: 'Mode B', hint: 'Gallery' }
};
let captureMode = 'camera';
const LONG_MS = 1000;
let lpTimer = null;
let isLongPress = false;  // Flag to track if long press occurred

function setCaptureMode(key){
  captureMode = key;
  btnSnap.dataset.mode = key;
  captureModeHint && (captureModeHint.textContent = MODE[key].hint);
  btnSnap.classList.remove('mode-camera','mode-gallery');
  btnSnap.classList.add('mode-'+key);
  // brief flash effect on mode switch
  btnSnap.classList.add('mode-switch-flash');
  setTimeout(()=>btnSnap.classList.remove('mode-switch-flash'),500);
  if (MODE[key].capture) fileInput.setAttribute('capture','environment');
  else fileInput.removeAttribute('capture');
}
function toggleMode(){ setCaptureMode(captureMode === 'camera' ? 'gallery' : 'camera'); }
function triggerCapture(){
  if (MODE[captureMode].capture) {
    fileInput.setAttribute('capture', 'environment');
    shutterGPSPromise = captureShutterLocation();
  } else {
    fileInput.removeAttribute('capture');
    shutterGPSPromise = null;
  }
  fileInput.click();
}

btnSnap.addEventListener('pointerdown', e => {
  if (!e.isPrimary) return;
  e.preventDefault();
  isLongPress = false;
 clearTimeout(lpTimer);
  btnSnap.classList.add('progressing'); // start visual fill
  lpTimer = setTimeout(() => {
    isLongPress = true;
    toggleMode();
    btnSnap.classList.remove('progressing'); // stop fill once toggled
  }, LONG_MS);
});

btnSnap.addEventListener('pointerup', e => {
  if (!e.isPrimary) return;
  clearTimeout(lpTimer);
  if (!isLongPress) triggerCapture();
  btnSnap.classList.remove('progressing'); // cancel fill
});

// Remove pointerleave and pointercancel listeners (no longer needed)

/* --- end simple long-press controller --- */

if (btnSelectMode) {
  btnSelectMode.addEventListener('click', () => {
    settingsPanel.style.right = '-320px';
    enterSelectionMode();
  });
}
if (btnCancelSelection) {
  btnCancelSelection.addEventListener('click', cancelSelectionMode);
}

/* --- wire up other handlers (remove conflicting click) --- */
// REMOVED: btnSnap.addEventListener('click', ()=> fileInput.click());
btnExportPPTX.addEventListener('click', ()=> { 
  settingsPanel.style.right = (settingsPanel.style.right === '0px') ? '-320px' : '0px'; 
});
btnCloseSettings.addEventListener('click', ()=> { settingsPanel.style.right = '-320px'; });
// also allow closing when panel is open and user clicks outside (optional)
document.addEventListener('keydown', e=>{ if(e.key === 'Escape'){ settingsPanel.style.right='-320px'; descDialog.close?.(); /* NEW: close params panel on Esc */ paramsPanel?.classList.remove('open'); paramsPanel?.setAttribute('aria-hidden','true'); } });

// NEW: params panel open/close/save
paramsToggle?.addEventListener('click', ()=>{
  // populate from current state before showing
  if (params_collectionTitle) params_collectionTitle.value = collectionTitleInput.value || '';
  if (params_clientName) params_clientName.value = state.client || '';
  if (params_projectTitle) params_projectTitle.value = state.project || '';
  if (params_photographerName) params_photographerName.value = state.photographer || '';
  
  paramsPanel?.classList.add('open');
  paramsPanel?.setAttribute('aria-hidden','false');
});
paramsClose?.addEventListener('click', ()=>{
  paramsPanel?.classList.remove('open');
  paramsPanel?.setAttribute('aria-hidden','true');
});
paramsSave?.addEventListener('click', async ()=>{
  // Sync fields back to state/UI
  if (params_collectionTitle && collectionTitleInput) {
    collectionTitleInput.value = params_collectionTitle.value || collectionTitleInput.value;
  }
  if (params_clientName && clientNameInput) {
    clientNameInput.value = params_clientName.value || '';
    state.client = clientNameInput.value.trim();
  }
  if (params_projectTitle && projectTitleInput) {
    projectTitleInput.value = params_projectTitle.value || '';
    state.project = projectTitleInput.value.trim();
  }
  if (params_photographerName && photographerNameInput) {
    photographerNameInput.value = params_photographerName.value || '';
    state.photographer = photographerNameInput.value.trim();
  }
  // Update active session title if shown
  if (collectionTitleInput && activeSessionId && sessions[activeSessionId]) {
    sessions[activeSessionId].name = collectionTitleInput.value.trim() || sessions[activeSessionId].name;
  }
  await saveGlobalsToSession(activeSessionId);
  renderSessions();
  paramsPanel?.classList.remove('open');
  paramsPanel?.setAttribute('aria-hidden','true');
});

// NEW: Force Landscape Handler
if (btnForceLandscape) {
  btnForceLandscape.addEventListener('click', async () => {
    const portraitItems = state.items.filter(i => i.h > i.w);
    if (portraitItems.length === 0) {
      alert('No portrait images found.');
      return;
    }
    if (!confirm(`Rotate ${portraitItems.length} portrait images to landscape?`)) return;

    const originalText = btnForceLandscape.textContent;
    btnForceLandscape.disabled = true;
    
    let count = 0;
    for (const item of portraitItems) {
      count++;
      btnForceLandscape.textContent = `Rotating ${count}/${portraitItems.length}...`;
      
      try {
        await runInImageQueue(async () => {
          const sourceBlob = await fetchBlobForItem(item);
          if (!sourceBlob) throw new Error('Image not available in storage');

          let bitmap = null;
          let thumbCanvas = null;
          const targetEdge = Math.max(item.w || DEFAULT_MAX_EDGE, item.h || DEFAULT_MAX_EDGE, DEFAULT_MAX_EDGE);
          const canvas = document.createElement('canvas');
          try {
            const decoded = await decodeImageDownscaled(sourceBlob, targetEdge);
            bitmap = decoded.bitmap;
            const w = decoded.width;
            const h = decoded.height;

            // Rotate logic (90 degrees clockwise)
            canvas.width = h;
            canvas.height = w;
            const ctx = canvas.getContext('2d');
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(90 * Math.PI / 180);
            ctx.drawImage(bitmap, -w/2, -h/2, w, h);

            // Convert to Blob
            const blob = await canvasToBlob(canvas, 0.9);
            
            // Update item
            item.blob = blob;
            delete item.dataURL; // Remove legacy

            item.w = canvas.width;
            item.h = canvas.height;
            thumbCanvas = createThumbnailFromCanvas(canvas);
            item.thumbData = encodeThumb(thumbCanvas);
            item._preview = null;
            item._needsPreview = false;

            // Save using the fixed helper
            await saveItem(item);
            stripFullImage(item, true);
          } finally {
            cleanupBitmap(bitmap);
            disposeCanvas(thumbCanvas);
            disposeCanvas(canvas);
          }
        });
      } catch (e) {
        console.error('Failed to rotate item', item.id, e);
      } finally {
        await framePause();
      }
    }

    // Refresh UI
    renderGallery();
    btnForceLandscape.textContent = originalText;
    btnForceLandscape.disabled = false;
    
    // Close panel
    paramsPanel?.classList.remove('open');
    paramsPanel?.setAttribute('aria-hidden','true');
  });
}

// NEW: File System Access API logic
if (btnChooseFolder) {
  if ('showDirectoryPicker' in window) {
    btnChooseFolder.addEventListener('click', async () => {
      try {
        const handle = await window.showDirectoryPicker();
        // Request permission. This must be done within the user gesture.
        const permStatus = await handle.requestPermission({ mode: "readwrite" });

        // Explicitly verify the permission state after the request.
        if (permStatus === "granted") {
          // Verify we can actually use the handle (some mobile browsers require this).
          try {
            // `keys()` is a simple async iterator to check usability.
            // We don't need to do anything with the result.
            // If this fails, the handle is stale.
            await handle.keys().next(); 
            dirHandle = handle;
            await saveDirectoryHandle(handle);
            folderStatus.textContent = `Status: Saving to "${handle.name}" folder.`;
            alert(`Successfully linked to folder: ${handle.name}`);
          } catch (e) {
            console.warn('Stale directory handle, re-selection needed.', e);
            folderStatus.textContent = `Status: Re-select "${savedHandle.name}" to grant access.`;
            dirHandle = null;
          }





        } else {
          // Permission was not persisted or was revoked. User must re-grant it.
          folderStatus.textContent = `Status: Permission needed for "${savedHandle.name}". Click "Choose Folder" to re-enable.`;
          dirHandle = null; // Clear the stale handle.
        }
      } catch (err) {
        console.error('Failed to check saved directory handle:', err);
      }
    });
  } else {
    btnChooseFolder.disabled = true;
    folderStatus.textContent = 'Status: Your browser does not support local directory saving.';
  }
}

function isImportedGPS(pos){
  return !!pos && (pos.source === 'exif' || pos.accuracy === 0);
}

function fmtBNGDisplay(pos){
  if(!pos) return '';
  // CHANGED: Handle imported items (accuracy 0 or EXIF source) -> show * and hide accuracy
  const isImport = isImportedGPS(pos);
  const suffix = isImport ? ' *' : '';
  const accText = isImport ? '' : ` (~${Math.round(pos.accuracy||3)} m)`;

  if(typeof pos.bngE !== 'undefined' && typeof pos.bngN !== 'undefined' && typeof pos.lat === 'number' && typeof pos.lon === 'number'){
    return `BNG: E ${pos.bngE} N ${pos.bngN} | Lat ${pos.lat.toFixed(6)}, Lon ${pos.lon.toFixed(6)}${suffix}${accText}`;
  }
  if(typeof pos.lat === 'number' && typeof pos.lon === 'number'){
    return `Lat ${pos.lat.toFixed(6)}, Lon ${pos.lon.toFixed(6)}${suffix}${accText}`;
  }
  return '';
}
// NEW: Missing helper to request location once (prompts permission)
function requestLocationOnce(showPermissionAlert = false) {
  return new Promise((resolve) => {
    if (!navigator.geolocation) return resolve(null);
    navigator.geolocation.getCurrentPosition(
      (pos) => resolve(pos),
      (err) => {
        console.warn('Location request failed', err);
        if (showPermissionAlert && err?.code === 1) {
          alert('Please allow location access to tag photos. Check browser/app permissions.');
        }
        resolve(null);
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
    );
  });
}

// NEW: Capture a one-off GPS fix at shutter time (WGS84 -> BNG)
function captureShutterLocation(){
  const task = (async () => {
    try{
      const pos = await requestLocationOnce();
      if(!pos) return null;
      const { latitude: lat, longitude: lon, accuracy } = pos.coords;
      try{
        const bng = latLonToBNG(lat, lon);
        return { lat, lon, accuracy, bngE: bng.easting, bngN: bng.northing, source: 'shutter' };
      }catch(convErr){
        console.warn('Shutter BNG conversion failed', convErr);
        return { lat, lon, accuracy, source: 'shutter' };
      }
    }catch(err){
      console.warn('Shutter location failed', err);
      return null;
    }
  })();
  shutterGPSPromise = task;
  return task;
}

// CHANGED: Precise WGS84 â†’ OSGB36 conversion + Transverse Mercator
function latLonToBNG(wgsLat, wgsLon) {
  // Quick bounds check (UK extent)
  if (wgsLat < 49 || wgsLat > 61 || wgsLon < -8 || wgsLon > 2) return { easting: null, northing: null };

  // WGS84 ellipsoid
  const aW = 6378137.0, bW = 6356752.3141;
  const e2W = 1 - (bW * bW) / (aW * aW);

  // Airy 1830 ellipsoid (OSGB36)
  const aO = 6377563.396, bO = 6356256.909;
  const e2O = 1 - (bO * bO) / (aO * aO);

  // Convert degrees to radians
  const degToRad = d => d * Math.PI / 180;
  const radToDeg = r => r * 180 / Math.PI;

  const latRad = degToRad(wgsLat);
  const lonRad = degToRad(wgsLon);

  // Height assumed 0
  const h = 0;

  // WGS84 Cartesian
  const sinLat = Math.sin(latRad), cosLat = Math.cos(latRad);
  const sinLon = Math.sin(lonRad), cosLon = Math.cos(lonRad); // CHANGED: was Math.cos(latRad)
  const vW = aW / Math.sqrt(1 - e2W * sinLat * sinLat);
  const xW = (vW + h) * cosLat * cosLon;
  const yW = (vW + h) * cosLat * sinLon;
  const zW = ((1 - e2W) * vW + h) * sinLat;

  // Helmert transform parameters (WGS84 â†’ OSGB36)
  const tx = -446.448, ty = 125.157, tz = -542.060;          // meters
  const rxSec = -0.1502, rySec = -0.2470, rzSec = -0.8421;   // arcâ€‘seconds
  const sPpm = 20.4894;                                      // ppm

  const secToRad = s => s * Math.PI / (180 * 3600);
  const rx = secToRad(rxSec), ry = secToRad(rySec), rz = secToRad(rzSec);
  const s = sPpm * 1e-6;

  // Apply Helmert (small rotations)
  const xO = tx + (1 + s) * xW + (-rz) * yW + (ry) * zW;
  const yO = ty + (rz) * xW + (1 + s) * yW + (-rx) * zW;
  const zO = tz + (-ry) * xW + (rx) * yW + (1 + s) * zW;

  // Convert back to OSGB36 lat/lon (iterative)
  const p = Math.sqrt(xO * xO + yO * yO);
  let latO = Math.atan2(zO, p * (1 - e2O));
  let latPrev;
  for (let i = 0; i < 7; i++) {
    const sinLatO = Math.sin(latO);
    const vO = aO / Math.sqrt(1 - e2O * sinLatO * sinLatO);
    latPrev = latO;
    latO = Math.atan2(zO + e2O * vO * sinLatO, p);
    if (Math.abs(latO - latPrev) < 1e-12) break;
  }
  const lonO = Math.atan2(yO, xO);

  // Transverse Mercator projection constants
  const F0 = 0.9996012717;
  const lat0 = degToRad(49);
  const lon0 = degToRad(-2);
  const N0 = -100000;
  const E0 = 400000;
  const n = (aO - bO) / (aO + bO);
  const sinLatO = Math.sin(latO);
  const cosLatO = Math.cos(latO);
  const nu = aO * F0 / Math.sqrt(1 - e2O * sinLatO * sinLatO);
  const rho = aO * F0 * (1 - e2O) / Math.pow(1 - e2O * sinLatO * sinLatO, 1.5);
  const eta2 = nu / rho - 1;

  // Meridional arc
  function meridionalArc(lat) {
    return bO * F0 * (
      (1 + n + (5/4)*n*n + (5/4)*n*n*n) * (lat - lat0)
      - (3*n + 3*n*n + (21/8)*n*n*n) * Math.sin(lat - lat0) * Math.cos(lat + lat0)
      + ((15/8)*n*n + (15/8)*n*n*n) * Math.sin(2*(lat - lat0)) * Math.cos(2*(lat + lat0))
      - (35/24)*n*n*n * Math.sin(3*(lat - lat0)) * Math.cos(3*(lat + lat0))
    );
  }
  const M = meridionalArc(latO);
  const dLon = lonO - lon0;

  const I = M + N0;
  const II = (nu / 2) * sinLatO * cosLatO;
  const III = (nu / 24) * sinLatO * Math.pow(cosLatO, 3) * (5 - Math.tan(latO) * Math.tan(latO) + 9 * eta2);
  const IIIA = (nu / 720) * sinLatO * Math.pow(cosLatO, 5) * (61 - 58 * Math.tan(latO) * Math.tan(latO) + Math.pow(Math.tan(latO), 4));
  const IV = nu * cosLatO;
  const V = (nu / 6) * Math.pow(cosLatO, 3) * (nu / rho - Math.tan(latO) * Math.tan(latO));
  const VI = (nu / 120) * Math.pow(cosLatO, 5) * (5 - 18 * Math.tan(latO) * Math.tan(latO) + Math.pow(Math.tan(latO), 4) + 14 * eta2 - 58 * Math.tan(latO) * Math.tan(latO) * eta2);

  const N = I + II * dLon * dLon + III * Math.pow(dLon, 4) + IIIA * Math.pow(dLon, 6);
  const E = E0 + IV * dLon + V * Math.pow(dLon, 3) + VI * Math.pow(dLon, 5);

  return { easting: Math.round(E), northing: Math.round(N) };
}

function startWatch(){
  if(!navigator.geolocation || watchId) return;
  try{
    watchId = navigator.geolocation.watchPosition(pos=>{
      try{
        const lat = pos.coords.latitude, lon = pos.coords.longitude, acc = pos.coords.accuracy;
        const bng = latLonToBNG(lat, lon); // latLonToBNG()
        const latestPos = { lat, lon, accuracy: acc, bngE: bng.easting, bngN: bng.northing };
        lastKnownPos = latestPos;
        const gpsLocked = isImportedGPS(pendingGPS) || pendingGPS?.source === 'shutter';
        
        // CHANGED: Only update pendingGPS from live stream if NOT in gallery mode
        if(!gpsLocked && captureMode !== 'gallery'){
          pendingGPS = latestPos;
        }
        // update dialog field if open
        // CHANGED: Do not update position if we are editing an existing item (lock position)
        // NEW: Also do not update if the field shows imported EXIF data (marked with *)
        // CHANGED: Also do not update if in gallery mode (imports should not take live location)
        if(descDialog.open && !editingItem && !gpsLocked && !descPosition.value.includes('*') && captureMode !== 'gallery'){
          descPosition.value = fmtBNGDisplay(latestPos);
        }
        // visual indicator & tooltip include accuracy
        setLocationButtonState(true, Math.round(acc||0));
      }catch(err){
        console.warn('watchPosition -> BNG convert failed', err);
      }
    }, err=>{
      console.warn('watchPosition error', err);
      // turn off visual indicator on errors (permission/unavailable/etc)
      setLocationButtonState(false);
    }, { enableHighAccuracy:true, maximumAge:0, timeout:20000 });
  }catch(e){
    console.warn('startWatch failed', e);
    setLocationButtonState(false);
    watchId = null;
  }
}

function stopWatch(){
  if(watchId !== null && navigator.geolocation){
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
    // visual reset: icon shows disabled
    setLocationButtonState(false);
  }
}

// NEW: Handle visibility change to save battery
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Tab hidden: stop GPS to save battery
    if (watchId) stopWatch();
  } else {
    // Tab visible: restart if user intent was "Enabled"
    if (locationEnabled) startWatch();
   }
});

btnEnableLoc.addEventListener('click', async ()=>{
  // CHANGED: Toggle based on INTENT (locationEnabled flag), not just current watchId status.
  // This fixes the issue where an error state (watchId set but UI red) required double-clicking.
  if(locationEnabled){
    // User wants to disable
    locationEnabled = false;
    stopWatch();
    return;
  }

  // User wants to enable
  // User gesture: do a oneâ€‘shot getCurrentPosition to force browser permission prompt
  btnEnableLoc.setAttribute('title','Requestingâ€¦');
  const pos = await requestLocationOnce(true);
  if(!pos){
    setLocationButtonState(false, 'Denied / unavailable');
    locationEnabled = false;
    return;
  }

  try{
    const lat = pos.coords.latitude, lon = pos.coords.longitude, acc = pos.coords.accuracy;
    const bng = latLonToBNG(lat, lon, acc);
    lastKnownPos = { lat, lon, accuracy: acc, bngE: bng.easting, bngN: bng.northing };
    const gpsLocked = isImportedGPS(pendingGPS) || pendingGPS?.source === 'shutter';
    if(!gpsLocked){
      pendingGPS = lastKnownPos;
      descPosition.value = fmtBNGDisplay(lastKnownPos);
    }
    
    // Set intent flag and start
    locationEnabled = true;
    startWatch();
    setLocationButtonState(true, Math.round(acc||0));
  }catch(err){
    console.warn('Enable location failed', err);
    setLocationButtonState(false, 'Error');
    locationEnabled = false;
    stopWatch();
  }
});

function setLocationButtonState(enabled, accOrMsg){
  const btn = document.getElementById('btnEnableLoc');
  const warn = document.getElementById('locWarning');
  if(btn){
    if(enabled){
      btn.classList.remove('loc-off'); btn.classList.add('loc-on');
      btn.classList.remove('loc-off'); btn.classList.add('loc-on');
           const title = (typeof accOrMsg === 'number') ? `Disable location (~${accOrMsg} m)` : 'Disable location';
      btn.setAttribute('title', title);
      btn.setAttribute('aria-pressed','true');
    }else{
      btn.classList.remove('loc-on'); btn.classList.add('loc-off');
      const title = (typeof accOrMsg === 'string') ? accOrMsg : 'Enable location';
      btn.setAttribute('title', title);
      btn.setAttribute('aria-pressed','false');
    }
  }
  // Toggle header warning chip
  if (warn) {
    if (enabled) {
      // CHANGED: Show accuracy chip when enabled instead of hiding it
      if (typeof accOrMsg === 'number') {
        warn.textContent = `Â± ${accOrMsg}m`;
        warn.classList.add('active');
        warn.style.display = 'inline-flex';

      } else {
        warn.style.display = 'none';
      }
    } else {
      warn.classList.remove('active');
      warn.textContent = 'Location OFF';
      warn.style.display = 'inline-flex';
    }
  }
}

/* initialize location button visual state (off by default) */
document.addEventListener('DOMContentLoaded', ()=> {
  setLocationButtonState(false, 'Enable location');
  setCaptureMode(captureMode); // ensure initial green mode class
});

/* ---------------- Helpers needed by capture / UI ---------------- */
function escapeHTML(s){ return (s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quote;',"'":'&#039;' }[m])); }
function fmtCount(n){ return `${n} item${n===1?'':'s'}`; }
function toDataURL(canvas, quality=0.92){ return canvas.toDataURL('image/jpeg', quality); }

// Simple debounce helper for autosaving text inputs
function debounce(func, wait) {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

// NEW: Blob helpers for memory optimization
function canvasToBlob(canvas, quality=0.92) {
  return new Promise(resolve => {
    try {
      canvas.toBlob(b => {
        if (b) return resolve(b);
        // Fallback: some browsers can return null; use dataURL conversion
        try {
          const dataUrl = canvas.toDataURL('image/jpeg', quality);
          const blob = dataURLtoBlob(dataUrl);
          resolve(blob);
        } catch (_) {
          resolve(null);
        }
      }, 'image/jpeg', quality);
    } catch (err) {
      try {
        const dataUrl = canvas.toDataURL('image/jpeg', quality);
        resolve(dataURLtoBlob(dataUrl));
      } catch (_) {
        resolve(null);
      }
    }
  });
}
function blobToDataURL(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function dataURLtoBlob(dataURL){
  const parts = dataURL.split(',');
  const mime = parts[0].match(/:(.*?);/)[1];
  const binStr = atob(parts[1]);
  const len = binStr.length;
  const u8 = new Uint8Array(len);
  for(let i=0;i<len;i++) u8[i]=binStr.charCodeAt(i);
  return new Blob([u8], {type:mime});
}

const DEFAULT_MAX_EDGE = 1920;
let imageProcessingQueue = Promise.resolve();

function runInImageQueue(task){
  const next = imageProcessingQueue.then(() => task());
  imageProcessingQueue = next.catch(() => {}); // keep chain alive after an error
  return next;
}

const framePause = () => new Promise(resolve => requestAnimationFrame(() => resolve()));

function disposeCanvas(canvas){
  if (!canvas) return;
  try {
    const ctx = canvas.getContext && canvas.getContext('2d');
    if (ctx) ctx.clearRect(0, 0, canvas.width || 0, canvas.height || 0);
  } catch (_) {}
  canvas.width = 0;
  canvas.height = 0;
}

function cleanupBitmap(bitmap){
  if (!bitmap) return;
  if (typeof bitmap.close === 'function') {
    try { bitmap.close(); } catch (_) {}
  } else if (bitmap instanceof Image || bitmap instanceof HTMLImageElement) {
    bitmap.src = '';
  } else if (bitmap instanceof HTMLCanvasElement) {
    disposeCanvas(bitmap);
  }
}

async function sniffImageDimensions(blob){
  if (!blob) return null;
  try {
    const slice = blob.slice(0, 512 * 1024);
    const buffer = await slice.arrayBuffer();
    const view = new DataView(buffer);

    // PNG: width/height stored in IHDR chunk at bytes 16-24
    if (buffer.byteLength >= 24 && view.getUint32(0) === 0x89504e47) {
      const width = view.getUint32(16);
      const height = view.getUint32(20);
      if (width && height) return { width, height };
    }

    // JPEG: walk markers until SOF (also read EXIF orientation if available)
    if (buffer.byteLength > 4 && view.getUint16(0) === 0xffd8) {
      let offset = 2;
      let width = null;
      let height = null;
      let orientation = null;
      while (offset + 9 < view.byteLength) {
        if (view.getUint8(offset) !== 0xFF) { offset++; continue; }
        const marker = view.getUint8(offset + 1);
        const length = view.getUint16(offset + 2);

        if (marker === 0xE1 && orientation === null) {
          const exifStart = offset + 4;
          if (exifStart + 6 <= view.byteLength && view.getUint32(exifStart) === 0x45786966 && view.getUint16(exifStart + 4) === 0x0000) {
            const tiff = exifStart + 6;
            const endian = view.getUint16(tiff);
            const little = endian === 0x4949;
            if (endian === 0x4949 || endian === 0x4D4D) {
              if (view.getUint16(tiff + 2, !little) === 0x002A) {
                const firstIFDOffset = view.getUint32(tiff + 4, !little);
                const ifd = tiff + firstIFDOffset;
                if (ifd + 2 <= view.byteLength) {
                  const entries = view.getUint16(ifd, !little);
                  for (let i = 0; i < entries; i++) {
                    const entryOffset = ifd + 2 + i * 12;
                    if (entryOffset + 12 > view.byteLength) break;
                    const tag = view.getUint16(entryOffset, !little);
                    if (tag === 0x0112) {
                      const type = view.getUint16(entryOffset + 2, !little);
                      const count = view.getUint32(entryOffset + 4, !little);
                      let value = null;
                      if (type === 3 && count >= 1) {
                        value = view.getUint16(entryOffset + 8, !little);
                      } else if (type === 4 && count >= 1) {
                        value = view.getUint32(entryOffset + 8, !little);
                      }
                      if (value && value >= 1 && value <= 8) orientation = value;
                      break;
                    }
                  }
                }
              }
            }
          }
        }

        const isSOF = (marker >= 0xC0 && marker <= 0xC3) || (marker >= 0xC5 && marker <= 0xC7) || (marker >= 0xC9 && marker <= 0xCB) || (marker >= 0xCD && marker <= 0xCF);
        if (isSOF && offset + 7 < view.byteLength) {
          height = view.getUint16(offset + 5);
          width = view.getUint16(offset + 7);
          if (width && height && orientation !== null) return { width, height, orientation };
        }
        if (length < 2) break;
        offset += 2 + length;
      }
      if (width && height) return { width, height, orientation };
    }

    // WEBP (VP8X header)
    if (buffer.byteLength >= 30 && view.getUint32(0, true) === 0x46464952 && view.getUint32(8, true) === 0x50424557) {
      const chunk = String.fromCharCode(view.getUint8(12), view.getUint8(13), view.getUint8(14), view.getUint8(15));
      if (chunk === 'VP8X') {
        const width = 1 + view.getUint8(24) + (view.getUint8(25) << 8) + (view.getUint8(26) << 16);
        const height = 1 + view.getUint8(27) + (view.getUint8(28) << 8) + (view.getUint8(29) << 16);
        if (width && height) return { width, height };
      }
    }
  } catch (e) {
    console.warn('sniffImageDimensions failed', e);
  }
  return null;
}

let warnedMissingDims = false;
function warnMissingDimsOnce(){
  if (warnedMissingDims) return;
  warnedMissingDims = true;
  alert('Some images do not include dimension metadata. The app will decode at native size to preserve aspect ratio.');
}
let warnedAspectMismatch = false;
function warnAspectMismatchOnce(){
  if (warnedAspectMismatch) return;
  warnedAspectMismatch = true;
  alert('Image metadata does not match the decoded dimensions. The app will decode at native size to preserve aspect ratio.');
}

function shouldSwapOrientation(orientation){
  return orientation >= 5 && orientation <= 8;
}

function applyExifOrientation(ctx, orientation, w, h){
  switch (orientation) {
    case 2:
      ctx.transform(-1, 0, 0, 1, w, 0);
      break;
    case 3:
      ctx.transform(-1, 0, 0, -1, w, h);
      break;
    case 4:
      ctx.transform(1, 0, 0, -1, 0, h);
      break;
    case 5:
      ctx.transform(0, 1, 1, 0, 0, 0);
      break;
    case 6:
      ctx.transform(0, 1, -1, 0, h, 0);
      break;
    case 7:
      ctx.transform(0, -1, -1, 0, h, w);
      break;
    case 8:
      ctx.transform(0, -1, 1, 0, 0, w);
      break;
    default:
      break;
  }
}

async function decodeImageDownscaled(blob, targetLongEdge = DEFAULT_MAX_EDGE){
  if (!blob) throw new Error('Missing image blob');
  const maxEdge = targetLongEdge || DEFAULT_MAX_EDGE;
  const sniffed = await sniffImageDimensions(blob);
  const sniffedOrientation = sniffed?.orientation || null;
  const sniffedW = sniffed?.width || null;
  const sniffedH = sniffed?.height || null;
  const sniffedDisplayW = (sniffedW && sniffedH && shouldSwapOrientation(sniffedOrientation)) ? sniffedH : sniffedW;
  const sniffedDisplayH = (sniffedW && sniffedH && shouldSwapOrientation(sniffedOrientation)) ? sniffedW : sniffedH;
  const hasExifOrientation = !!(sniffedOrientation && sniffedOrientation !== 1);

  // Preferred: WebCodecs ImageDecoder (decodes directly to target size)
  if (typeof ImageDecoder !== 'undefined' && typeof ImageDecoder.isTypeSupported === 'function' && ImageDecoder.isTypeSupported(blob.type || 'image/jpeg')) {
    try {
      const decoder = new ImageDecoder({ data: blob, type: blob.type || 'image/jpeg' });
      const scaleDecodedBitmap = async (image, width, height) => {
        const longEdge = Math.max(width, height);
        const scale = Math.min(1, maxEdge / longEdge);
        if (scale >= 1) return { bitmap: image, width, height };
        const scaledW = Math.max(1, Math.round(width * scale));
        const scaledH = Math.max(1, Math.round(height * scale));
        if (typeof createImageBitmap === 'function') {
          try {
            const scaledBitmap = await createImageBitmap(image, {
              resizeWidth: scaledW,
              resizeHeight: scaledH,
              resizeQuality: 'high'
            });
            cleanupBitmap(image);
            return { bitmap: scaledBitmap, width: scaledW, height: scaledH };
          } catch (_) {}
        }
        const canvas = document.createElement('canvas');
        canvas.width = scaledW;
        canvas.height = scaledH;
        canvas.getContext('2d').drawImage(image, 0, 0, scaledW, scaledH);
        cleanupBitmap(image);
        return { bitmap: canvas, width: scaledW, height: scaledH };
      };
      let naturalW = null;
      let naturalH = null;
      try {
        await decoder.tracks.ready;
        const track = decoder.tracks?.selectedTrack;
        const info = track?.trackInfo || track;
        naturalW = info?.codedWidth || info?.displayWidth || info?.presentationWidth || info?.width || null;
        naturalH = info?.codedHeight || info?.displayHeight || info?.presentationHeight || info?.height || null;
      } catch (_) {}
      if ((!naturalW || !naturalH) && sniffedW && sniffedH) {
        naturalW = sniffedW;
        naturalH = sniffedH;
      }
      const hasDims = Number.isFinite(naturalW) && Number.isFinite(naturalH) && naturalW > 0 && naturalH > 0;
      let desiredWidth = null;
      let desiredHeight = null;
      if (hasDims && !hasExifOrientation) {
        const longEdge = Math.max(naturalW, naturalH);
        const scale = Math.min(1, maxEdge / longEdge);
        desiredWidth = Math.max(1, Math.round(naturalW * scale));
        desiredHeight = Math.max(1, Math.round(naturalH * scale));
      } else if (!hasDims) {
        warnMissingDimsOnce();
      }
      let image = null;
      let width = 0;
      let height = 0;
      const expectedDisplayRatio = (sniffedDisplayW && sniffedDisplayH) ? (sniffedDisplayW / sniffedDisplayH) : null;
      const expectedRawRatio = (sniffedW && sniffedH) ? (sniffedW / sniffedH) : (hasDims ? (naturalW / naturalH) : null);
      const getPixelDims = (img) => {
        const pixelW = img?.codedWidth || img?.width || img?.displayWidth || 0;
        const pixelH = img?.codedHeight || img?.height || img?.displayHeight || 0;
        const displayW = img?.displayWidth || pixelW;
        const displayH = img?.displayHeight || pixelH;
        return { pixelW, pixelH, displayW, displayH };
      };
      try {
        ({ image } = (desiredWidth && desiredHeight)
          ? await decoder.decode({ desiredWidth, desiredHeight })
          : await decoder.decode());
        let dims = getPixelDims(image);
        width = dims.pixelW;
        height = dims.pixelH;

        let orientationApplied = true;
        if (hasExifOrientation && expectedDisplayRatio && width && height) {
          const decodedRatio = width / height;
          orientationApplied = Math.abs(decodedRatio - expectedDisplayRatio) <= 0.02;
        }
        if (!hasExifOrientation) {
          const expectedRatio = expectedRawRatio;
          if (expectedRatio && width && height) {
            const decodedRatio = width / height;
            const mismatch = Math.abs(decodedRatio - expectedRatio) > 0.02;
            if (mismatch && desiredWidth && desiredHeight) {
              warnAspectMismatchOnce();
              cleanupBitmap(image);
              ({ image } = await decoder.decode());
              dims = getPixelDims(image);
              width = dims.pixelW;
              height = dims.pixelH;
              desiredWidth = null;
              desiredHeight = null;
            }
          }
        }

        // If we couldn't size the decode up front, scale afterward to preserve aspect ratio.
        if ((!desiredWidth || !desiredHeight) && width && height) {
          const scaled = await scaleDecodedBitmap(image, width, height);
          return { ...scaled, orientation: sniffedOrientation, orientationApplied };
        }
        return { bitmap: image, width, height, orientation: sniffedOrientation, orientationApplied };
      } finally {
        decoder.close?.();
      }
    } catch (e) {
      console.warn('ImageDecoder decode failed, falling back', e);
    }
  }

  let resizeWidth = null;
  let resizeHeight = null;
  if (!hasExifOrientation && sniffedW && sniffedH) {
    const longEdge = Math.max(sniffedW, sniffedH);
    const scale = Math.min(1, maxEdge / longEdge);
    resizeWidth = Math.max(1, Math.round(sniffedW * scale));
    resizeHeight = Math.max(1, Math.round(sniffedH * scale));
  }

  if (typeof createImageBitmap === 'function') {
    try {
      let bitmap = await createImageBitmap(blob, {
        resizeWidth: resizeWidth || undefined,
        resizeHeight: resizeHeight || undefined,
        resizeQuality: 'high',
        imageOrientation: 'from-image'
      });
      let width = bitmap.width;
      let height = bitmap.height;
      if (hasExifOrientation) {
        const longEdge = Math.max(width, height);
        const scale = Math.min(1, maxEdge / longEdge);
        if (scale < 1) {
          const scaledW = Math.max(1, Math.round(width * scale));
          const scaledH = Math.max(1, Math.round(height * scale));
          const scaled = await createImageBitmap(bitmap, {
            resizeWidth: scaledW,
            resizeHeight: scaledH,
            resizeQuality: 'high'
          });
          cleanupBitmap(bitmap);
          bitmap = scaled;
          width = scaledW;
          height = scaledH;
        }
      }
      let orientationApplied = true;
      if (hasExifOrientation && sniffedDisplayW && sniffedDisplayH && width && height) {
        const expectedRatio = sniffedDisplayW / sniffedDisplayH;
        const decodedRatio = width / height;
        orientationApplied = Math.abs(decodedRatio - expectedRatio) <= 0.02;
      }
      return {
        bitmap,
        width,
        height,
        orientation: sniffedOrientation,
        orientationApplied
      };
    } catch (e) {
      console.warn('createImageBitmap path failed', e);
    }
  }

  // Legacy fallback: decode via <img> (may be higher memory)
  const img = await new Promise((res, rej) => {
    const el = new Image();
    const url = URL.createObjectURL(blob);
    el.onload = () => { res(el); try { URL.revokeObjectURL(url); } catch (_) {} };
    el.onerror = (err) => { rej(err); try { URL.revokeObjectURL(url); } catch (_) {} };
    el.src = url;
  });
  const naturalW = img.naturalWidth || img.width;
  const naturalH = img.naturalHeight || img.height;
  const longEdge = Math.max(naturalW, naturalH) || maxEdge;
  const scale = Math.min(1, maxEdge / longEdge);
  const width = Math.max(1, Math.round(naturalW * scale));
  const height = Math.max(1, Math.round(naturalH * scale));
  const expectedRatio = (sniffedDisplayW && sniffedDisplayH) ? (sniffedDisplayW / sniffedDisplayH) : null;
  let orientationApplied = true;
  if (sniffedOrientation && expectedRatio && naturalW && naturalH) {
    const decodedRatio = naturalW / naturalH;
    orientationApplied = Math.abs(decodedRatio - expectedRatio) <= 0.02;
  }
  return { bitmap: img, width, height, orientation: sniffedOrientation, orientationApplied };
}

// NEW: Helpers to avoid holding full-res images in memory
function stripFullImage(item, hasBlob = false) {
  if (!item) return;
  if (item._objectURL) {
    try { URL.revokeObjectURL(item._objectURL); } catch (_) {}
  }
  delete item._objectURL;
  delete item.dataURL;
  delete item.blob;
  if (hasBlob) item._hasBlob = true;
}

function showHeicProcessing(msg = 'Processing HEIC/HEIFâ€¦') {
  heicProcessingCount++;
  if (heicProcessingEl) {
    heicProcessingEl.style.display = 'flex';
    if (heicProcessingText) heicProcessingText.textContent = msg;
  }
  if (!debugMetaPrompted) {
    debugMetaPrompted = true;
    if (confirm('Show metadata debug panel while importing HEIC/HEIF?')) {
      debugMetaEnabled = true;
      debugMetaAuto = true;
    }
  }
  if (debugMetaEnabled && debugMetaEl) {
    debugMetaEl.style.display = 'block';
  }
}
function hideHeicProcessing() {
  heicProcessingCount = Math.max(0, heicProcessingCount - 1);
  if (heicProcessingEl && heicProcessingCount === 0) {
    heicProcessingEl.style.display = 'none';
  }
  if (heicProcessingCount === 0 && debugMetaAuto && debugMetaEl) {
    debugMetaEl.style.display = 'none';
  }
}

function updateHeicProcessing(msg) {
  if (heicProcessingEl) {
    heicProcessingEl.style.display = 'flex';
    if (heicProcessingText && msg) heicProcessingText.textContent = msg;
  }
}

function debugMetaLog(label, payload) {
  if (!debugMetaEnabled || !debugMetaEl) return;
  try {
    const simplified = {
      label,
      exifDate: payload?.exifDate || payload?.whenISO || null,
      exifGPS: payload?.exifGPS || payload?.gps || null,
      exifOrientation: payload?.exifOrientation || null,
      exifWidth: payload?.exifWidth || payload?.exifDims?.width || null,
      exifHeight: payload?.exifHeight || payload?.exifDims?.height || null,
      raw: payload
    };
    debugMetaEl.textContent = JSON.stringify(simplified, null, 2);
    debugMetaEl.style.display = 'block';
  } catch (_) {}
}

async function fetchBlobForItem(item) {
  if (!item || !item.id) return null;
  // Use in-memory blob if present (e.g. just created)
  if (item.blob instanceof Blob) return item.blob;
  try {
    const stored = await idbGet(STORE, item.id);
    if (stored?.blob instanceof Blob) {
      item._hasBlob = true;
      return stored.blob;
    }
    if (stored?.dataURL) {
      try {
        const blob = dataURLtoBlob(stored.dataURL);
        // Upgrade stored item to blob-only to reduce future memory pressure
        const upgraded = { ...stored, blob };
        delete upgraded.dataURL;
        await idbPut(STORE, upgraded);
        item._hasBlob = true;
        return blob;
      } catch (e) {
        console.warn('Failed to convert dataURL for item', item.id, e);
      }
    }
  } catch (e) {
    console.warn('Could not fetch blob for item', item.id, e);
  }
  return null;
}

// NEW: EXIF Helpers
function getExifData(file) {
  return new Promise((resolve) => {
    if(!window.EXIF) return resolve({});
    EXIF.getData(file, function() {
      resolve(EXIF.getAllTags(this));
    });
  });
}
function convertDMSToDD(d, m, s, ref) {
  // Ensure inputs are numbers. EXIF data can sometimes be messy (e.g. Number objects, strings, or NaN).
  let deg = Number(d);
  let min = Number(m);
  let sec = Number(s);
  
  // Handle invalid numbers gracefully by treating as 0
  if (isNaN(deg)) deg = 0;
  if (isNaN(min)) min = 0;
  if (isNaN(sec)) sec = 0;

  let dd = deg + min/60 + sec/3600;
  
  // Check ref. Sometimes it's not a string, or has whitespace.
  if (typeof ref === 'string') {
    ref = ref.toUpperCase().trim();
    if (ref === "S" || ref === "W") dd = dd * -1;
  }
  return dd;
}
function parseExifLocation(tags) {
  // Check if tags exist and have length. Some EXIF readers return length 0 arrays for missing data.
  if (tags && tags.GPSLatitude && tags.GPSLatitude.length >= 3 && tags.GPSLongitude && tags.GPSLongitude.length >= 3) {
    const lat = convertDMSToDD(tags.GPSLatitude[0], tags.GPSLatitude[1], tags.GPSLatitude[2], tags.GPSLatitudeRef);
    const lon = convertDMSToDD(tags.GPSLongitude[0], tags.GPSLongitude[1], tags.GPSLongitude[2], tags.GPSLongitudeRef);
    
    // Safety check: if calculation resulted in NaN, reject it.
    if (isNaN(lat) || isNaN(lon)) return null;
    
    // Basic bounds check (Lat -90 to 90, Lon -180 to 180)
    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return null;
    
    // Check for 0,0 which is often a default/error value in EXIF (Null Island)
    if (Math.abs(lat) < 0.0001 && Math.abs(lon) < 0.0001) return null;

    return { lat, lon };
  }
  return null;
}
function parseExifDate(tags) {
  const str = tags.DateTimeOriginal || tags.DateTime;
  if(typeof str === 'string') {
    const parts = str.split(' ');
    if(parts.length === 2) {
      const dParts = parts[0].split(':');
      const tParts = parts[1].split(':');
      if(dParts.length === 3 && tParts.length === 3) {
        return new Date(dParts[0], dParts[1]-1, dParts[2], tParts[0], tParts[1], tParts[2]);
      }
    }
  }
  return null;
}

function coerceExifNumber(value) {
  if (value === null || typeof value === 'undefined') return null;
  const v = Array.isArray(value) ? value[0] : value;
  const n = Number(v);
  return Number.isFinite(n) && n > 0 ? n : null;
}

function parseExifDimensions(tags) {
  if (!tags) return null;
  const width = coerceExifNumber(
    tags.PixelXDimension ?? tags.ExifImageWidth ?? tags.ImageWidth ?? tags.Width
  );
  const height = coerceExifNumber(
    tags.PixelYDimension ?? tags.ExifImageHeight ?? tags.ImageHeight ?? tags.ImageLength ?? tags.Height
  );
  if (!width || !height) return null;
  return { width, height };
}

// Minimal HEIC EXIF reader (date + GPS) adapted from CombinedHEIC.html
function heicDmsToDecimal(arr, ref) {
  if (!Array.isArray(arr) || arr.length < 3) return null;
  const [deg, min, sec] = arr;
  let dd = deg + min / 60 + sec / 3600;
  if (ref === 'S' || ref === 'W') dd = -dd;
  return dd;
}
function heicGetString(view, start, length) {
  let out = '';
  for (let n = start; n < start + length; n++) out += String.fromCharCode(view.getUint8(n));
  return out;
}
function heicReadTagValue(view, entryOffset, tiffStart, bigEnd) {
  const type = view.getUint16(entryOffset + 2, !bigEnd);
  const numValues = view.getUint32(entryOffset + 4, !bigEnd);
  const valueOffset = view.getUint32(entryOffset + 8, !bigEnd) + tiffStart;
  switch (type) {
    case 2: { // ascii
      const offset = numValues > 4 ? valueOffset : (entryOffset + 8);
      return heicGetString(view, offset, numValues - 1);
    }
    case 3: { // short
      if (numValues === 1) return view.getUint16(entryOffset + 8, !bigEnd);
      const offset = numValues > 2 ? valueOffset : (entryOffset + 8);
      return Array.from({ length: numValues }, (_, i) => view.getUint16(offset + 2 * i, !bigEnd));
    }
    case 5: { // rational
      const read = (off) => {
        const num = view.getUint32(off, !bigEnd);
        const den = view.getUint32(off + 4, !bigEnd);
        return den ? num / den : 0;
      };
      if (numValues === 1) return read(valueOffset);
      return Array.from({ length: numValues }, (_, i) => read(valueOffset + 8 * i));
    }
    default:
      return null;
  }
}
function heicReadTags(view, tiffStart, dirStart, tagMap, bigEnd) {
  const entries = view.getUint16(dirStart, !bigEnd);
  const tags = {};
  for (let i = 0; i < entries; i++) {
    const entryOffset = dirStart + i * 12 + 2;
    const tagId = view.getUint16(entryOffset, !bigEnd);
    const tagName = tagMap[tagId];
    if (!tagName) continue;
    tags[tagName] = heicReadTagValue(view, entryOffset, tiffStart, bigEnd);
  }
  return tags;
}
function heicReadEXIFData(view, start) {
  const byteOrder = view.getUint16(start);
  let bigEnd = byteOrder === 0x4D4D;
  if (view.getUint16(start + 2, !bigEnd) !== 0x002A) return null;
  const firstIFDOffset = view.getUint32(start + 4, !bigEnd);
  const tiffStart = start;
  const TiffTags = { 0x8769: 'ExifIFDPointer', 0x8825: 'GPSInfoIFDPointer', 0x0132: 'DateTime' };
  const ExifTags = { 0x9003: 'DateTimeOriginal', 0x9004: 'DateTimeDigitized' };
  const GPSTags = { 0x0001: 'GPSLatitudeRef', 0x0002: 'GPSLatitude', 0x0003: 'GPSLongitudeRef', 0x0004: 'GPSLongitude' };
  const tags = heicReadTags(view, tiffStart, tiffStart + firstIFDOffset, TiffTags, bigEnd);
  let out = {};
  if (tags.ExifIFDPointer) {
    out = { ...out, ...heicReadTags(view, tiffStart, tiffStart + tags.ExifIFDPointer, ExifTags, bigEnd) };
  }
  if (tags.GPSInfoIFDPointer) {
    out = { ...out, ...heicReadTags(view, tiffStart, tiffStart + tags.GPSInfoIFDPointer, GPSTags, bigEnd) };
  }
  if (tags.DateTime) out.DateTime = tags.DateTime;
  return out;
}
async function extractHeicExifSummary(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const view = new DataView(e.target.result);
        let exif = null;
        // Simple scan for Exif marker
        for (let i = 0; i < view.byteLength - 4; i++) {
          if (heicGetString(view, i, 4) === 'Exif') {
            exif = heicReadEXIFData(view, i + 6); // skip "Exif\0\0"
            break;
          }
        }
        const rawDate = exif?.DateTimeOriginal || exif?.DateTimeDigitized || exif?.DateTime || null;
        let exifDate = null;
        if (rawDate && typeof rawDate === 'string') {
          const safe = rawDate.replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
          const d = new Date(safe);
          if (!isNaN(d.getTime())) exifDate = d;
        }
        let exifGPS = null;
        if (exif?.GPSLatitude && exif?.GPSLatitudeRef && exif?.GPSLongitude && exif?.GPSLongitudeRef) {
          const lat = heicDmsToDecimal(exif.GPSLatitude, exif.GPSLatitudeRef);
          const lon = heicDmsToDecimal(exif.GPSLongitude, exif.GPSLongitudeRef);
          if (typeof lat === 'number' && typeof lon === 'number' && !isNaN(lat) && !isNaN(lon)) {
            exifGPS = { lat, lon, accuracy: 0, source: 'exif' };
          }
        }
        resolve({ exifDate, exifGPS });
      } catch (err) {
        console.warn('HEIC EXIF parse failed', err);
        resolve({ exifDate: null, exifGPS: null });
      }
    };
    reader.readAsArrayBuffer(file);
  });
}

// Extended EXIF parsing (JPEG + HEIC) adapted from CombinedHEIC.html for robust metadata
function readStringFromDB(buffer, start, length) {
  let outstr = '';
  for (let n = start; n < start + length; n++) outstr += String.fromCharCode(buffer.getUint8(n));
  return outstr;
}
function readTagValueFull(file, entryOffset, tiffStart, bigEnd) {
  const type = file.getUint16(entryOffset + 2, !bigEnd);
  const numValues = file.getUint32(entryOffset + 4, !bigEnd);
  const valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart;

  switch (type) {
    case 1: // byte
    case 7: { // undefined
      if (numValues === 1) return file.getUint8(entryOffset + 8, !bigEnd);
      const offset = numValues > 4 ? valueOffset : (entryOffset + 8);
      return Array.from({ length: numValues }, (_, i) => file.getUint8(offset + i));
    }
    case 2: { // ascii
      const offset = numValues > 4 ? valueOffset : (entryOffset + 8);
      return readStringFromDB(file, offset, numValues - 1);
    }
    case 3: { // short
      if (numValues === 1) return file.getUint16(entryOffset + 8, !bigEnd);
      const offset = numValues > 2 ? valueOffset : (entryOffset + 8);
      return Array.from({ length: numValues }, (_, i) => file.getUint16(offset + 2 * i, !bigEnd));
    }
    case 4: { // long
      if (numValues === 1) return file.getUint32(entryOffset + 8, !bigEnd);
      return Array.from({ length: numValues }, (_, i) => file.getUint32(valueOffset + 4 * i, !bigEnd));
    }
    case 5: { // rational
      const readR = (off) => {
        const num = file.getUint32(off, !bigEnd);
        const den = file.getUint32(off + 4, !bigEnd);
        return den ? num / den : 0;
      };
      if (numValues === 1) return readR(valueOffset);
      return Array.from({ length: numValues }, (_, i) => readR(valueOffset + 8 * i));
    }
    case 9: { // slong
      if (numValues === 1) return file.getInt32(entryOffset + 8, !bigEnd);
      return Array.from({ length: numValues }, (_, i) => file.getInt32(valueOffset + 4 * i, !bigEnd));
    }
    case 10: { // signed rational
      const readSR = (off) => {
        const num = file.getInt32(off, !bigEnd);
        const den = file.getInt32(off + 4, !bigEnd);
        return den ? num / den : 0;
      };
      if (numValues === 1) return readSR(valueOffset);
      return Array.from({ length: numValues }, (_, i) => readSR(valueOffset + 8 * i));
    }
    default:
      return null;
  }
}
function readTagsFull(file, tiffStart, dirStart, strings, bigEnd) {
  const entries = file.getUint16(dirStart, !bigEnd);
  const tags = {};
  for (let i = 0; i < entries; i++) {
    const entryOffset = dirStart + i * 12 + 2;
    const tagName = strings[file.getUint16(entryOffset, !bigEnd)];
    if (!tagName) continue;
    tags[tagName] = readTagValueFull(file, entryOffset, tiffStart, bigEnd);
  }
  return tags;
}
function readEXIFDataFull(file, start) {
  let bigEnd;
  let tags, tag;
  let exifData, gpsData;

  if (file.getUint16(start) === 0x4949) bigEnd = false;
  else if (file.getUint16(start) === 0x4D4D) bigEnd = true;
  else return null;

  if (file.getUint16(start + 2, !bigEnd) !== 0x002A) return null;

  const firstIFDOffset = file.getUint32(start + 4, !bigEnd);
  if (firstIFDOffset < 0x00000008) return null;

  const TiffTagsFull = {
    0x8769: 'ExifIFDPointer',
    0x8825: 'GPSInfoIFDPointer',
    0x0132: 'DateTime',
    0x0100: 'ImageWidth',
    0x0101: 'ImageLength',
    0x0112: 'Orientation'
  };
  const ExifTagsFull = {
    0x9003: 'DateTimeOriginal',
    0x9004: 'DateTimeDigitized',
    0xA002: 'PixelXDimension',
    0xA003: 'PixelYDimension'
  };
  const GPSTagsFull = { 0x0001: 'GPSLatitudeRef', 0x0002: 'GPSLatitude', 0x0003: 'GPSLongitudeRef', 0x0004: 'GPSLongitude' };

  tags = readTagsFull(file, start, start + firstIFDOffset, TiffTagsFull, bigEnd);

  if (tags.ExifIFDPointer) {
    exifData = readTagsFull(file, start, start + tags.ExifIFDPointer, ExifTagsFull, bigEnd);
    for (tag in exifData) tags[tag] = exifData[tag];
  }

  if (tags.GPSInfoIFDPointer) {
    gpsData = readTagsFull(file, start, start + tags.GPSInfoIFDPointer, GPSTagsFull, bigEnd);
    for (tag in gpsData) tags[tag] = gpsData[tag];
  }
  return tags;
}
function findEXIFinJPEGFull(file) {
  if (file.getUint8(0) !== 0xFF || file.getUint8(1) !== 0xD8) return null;
  let offset = 2;
  const length = file.byteLength;
  while (offset < length) {
    if (file.getUint8(offset) !== 0xFF) return null;
    const marker = file.getUint8(offset + 1);
    if (marker === 225) {
      return readEXIFDataFull(file, offset + 4 + 6);
    } else {
      offset += 2 + file.getUint16(offset + 2);
    }
  }
  return null;
}
function findEXIFinHEICFull(buffer) {
  const view = new DataView(buffer);
  const ftypSize = view.getUint32(0);
  const mdatStart = view.getUint32(ftypSize);
  let exifOffset = -1;
  let ilocOffset = -1;

  for (let i = ftypSize; i < mdatStart + ftypSize; i++) {
    const sig = readStringFromDB(view, i, 4);
    if (sig === 'Exif') exifOffset = i;
    else if (sig === 'iloc') ilocOffset = i;
  }
  if (exifOffset === -1 || ilocOffset === -1) return null;

  const exifItemId = view.getUint16(exifOffset - 4);
  for (let i = ilocOffset + 12; i < mdatStart + ftypSize; i += 16) {
    const itemId = view.getUint16(i);
    if (itemId === exifItemId) {
      const dataOffset = view.getUint32(i + 8);
      const tiffHeaderOffset = 4 + view.getUint32(dataOffset);
      return readEXIFDataFull(view, dataOffset + tiffHeaderOffset);
    }
  }
  return null;
}

function parseExifDateString(raw) {
  if (!raw || typeof raw !== 'string') return null;
  const safe = raw.replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
  const d = new Date(safe);
  return isNaN(d.getTime()) ? null : d;
}

async function extractExifUnified(file, fallbackName = '') {
  const name = (file?.name || fallbackName || '').toLowerCase();
  const isHeicFile = /\.(heic|heif)$/.test(name) || (file?.type || '').toLowerCase().includes('heic');
  
  let exifDate = null;
  let exifGPS = null;
  let exifOrientation = null;
  let exifWidth = null;
  let exifHeight = null;

  // 1) Try EXIF.js for quick win (JPEG/PNG with EXIF)
  // Skip if explicitly HEIC as EXIF.js doesn't support it
  if (!isHeicFile) {
    try {
      const tags = await getExifData(file);
      exifDate = parseExifDate(tags);
      const loc = parseExifLocation(tags);
      if (loc) exifGPS = { lat: loc.lat, lon: loc.lon, accuracy: 0, source: 'exif' };
      if (tags && typeof tags.Orientation !== 'undefined') {
        const o = Number(tags.Orientation);
        if (!isNaN(o) && o >= 1 && o <= 8) exifOrientation = o;
      }
      const dims = parseExifDimensions(tags);
      if (dims) {
        exifWidth = dims.width;
        exifHeight = dims.height;
      }
      
      // If we have both, return immediately
      if (exifDate && exifGPS && exifOrientation && exifWidth && exifHeight) {
        return { exifDate, exifGPS, exifOrientation, exifWidth, exifHeight };
      }
    } catch (_) {}
  }

  // 2) Fallback: manual parsing (if HEIC or if EXIF.js missed something)
  try {
    const buf = await file.arrayBuffer();
    const view = new DataView(buf);
    let raw = null;
    
    // Try HEIC parser if indicated
    if (isHeicFile) {
      raw = findEXIFinHEICFull(buf);
    }
    // If not found (or not HEIC), try JPEG parser
    if (!raw && view.byteLength > 4) {
      raw = findEXIFinJPEGFull(view);
    }
    // If still not found, try HEIC parser as last resort (in case extension was wrong)
    if (!raw && !isHeicFile) {
      raw = findEXIFinHEICFull(buf);
    }

    if (raw) {
      // Date
      if (!exifDate) {
        const rawDate = raw.DateTimeOriginal || raw.DateTimeDigitized || raw.DateTime || null;
        exifDate = parseExifDateString(rawDate);
      }
      // GPS
      if (!exifGPS && raw.GPSLatitude && raw.GPSLatitudeRef && raw.GPSLongitude && raw.GPSLongitudeRef) {
        const lat = heicDmsToDecimal(raw.GPSLatitude, raw.GPSLatitudeRef);
        const lon = heicDmsToDecimal(raw.GPSLongitude, raw.GPSLongitudeRef);
        if (typeof lat === 'number' && typeof lon === 'number' && !isNaN(lat) && !isNaN(lon)) {
          exifGPS = { lat, lon, accuracy: 0, source: 'exif' };
        }
      }
      if (!exifOrientation && raw.Orientation) {
        const o = Number(raw.Orientation);
        if (!isNaN(o) && o >= 1 && o <= 8) exifOrientation = o;
      }
      if (!exifWidth || !exifHeight) {
        const dims = parseExifDimensions(raw);
        if (dims) {
          exifWidth = dims.width;
          exifHeight = dims.height;
        }
      }
    }
  } catch (e) {
    console.warn('Manual EXIF parse failed', e);
  }
  
  return { exifDate, exifGPS, exifOrientation, exifWidth, exifHeight };
}

async function getExpectedDisplayRatioFromExif(file, exifOrientation, exifDims){
  let rawW = exifDims?.width || null;
  let rawH = exifDims?.height || null;
  let sniffed = null;
  if ((!rawW || !rawH) || !exifOrientation) {
    sniffed = await sniffImageDimensions(file);
    if (!rawW) rawW = sniffed?.width || null;
    if (!rawH) rawH = sniffed?.height || null;
  }
  if (!rawW || !rawH) return null;
  const orientation = exifOrientation || sniffed?.orientation || 1;
  const displayW = shouldSwapOrientation(orientation) ? rawH : rawW;
  const displayH = shouldSwapOrientation(orientation) ? rawW : rawH;
  if (!displayW || !displayH) return null;
  return displayW / displayH;
}

async function maybeSwapCanvasAxesOnImport(file, canvas, exifOrientation, exifDims){
  if (!file || !canvas) return canvas;
  const expectedRatio = await getExpectedDisplayRatioFromExif(file, exifOrientation, exifDims);
  if (!expectedRatio) return canvas;
  const currentRatio = canvas.width / canvas.height;
  if (Math.abs(currentRatio - expectedRatio) <= 0.02) return canvas;
  const swappedRatio = canvas.height / canvas.width;
  if (Math.abs(swappedRatio - expectedRatio) >= Math.abs(currentRatio - expectedRatio)) return canvas;
  const swapped = document.createElement('canvas');
  swapped.width = canvas.height;
  swapped.height = canvas.width;
  swapped.getContext('2d').drawImage(canvas, 0, 0, swapped.width, swapped.height);
  return swapped;
}

// NEW: Helper to ensure imported items match current structure
function normaliseLegacyItem(item) {
  // If item has flat GPS props (legacy), move them to .gps object
  if (!item.gps && (typeof item.lat === 'number' || typeof item.bngE !== 'undefined')) {
    item.gps = {
      lat: item.lat,
      lon: item.lon,
      accuracy: item.accuracy,
      bngE: item.bngE,
      bngN: item.bngN
    };
    // clean up flat props to avoid confusion
    delete item.lat; delete item.lon; delete item.accuracy; delete item.bngE; delete item.bngN;
  }
  // Tag imported GPS so live location updates do not overwrite it
  if (item.gps && !item.gps.source && item.gps.accuracy === 0) {
    item.gps.source = 'exif';
  }
  // Strip transient UI properties
  delete item._preview;
  delete item._loading;
  delete item._needsPreview;
  delete item._objectURL; // NEW: Ensure transient URL is stripped
  return item;
}

function isHeicLike(obj, fallbackName = '') {
  const name = ((obj && obj.name) || fallbackName || '').toLowerCase();
  const type = (obj && obj.type ? obj.type : '').toLowerCase();
  return /\.(heic|heif|hif)$/.test(name) || type.includes('heic') || type.includes('heif');
}

/** Normalize an image file. 
    - Loads image reliably into an HTMLImageElement
    - Preserves aspect ratio
    - Optionally rotates portrait sources 90 deg to yield landscape output (if forceRotate=true)
*/
async function normalizeImage(file, maxW, forceRotate=true){
  return runInImageQueue(async () => {
    const targetEdge = maxW || DEFAULT_MAX_EDGE;
    // CHANGED: Detect and convert HEIC/HEIF/HIF before loading
    const isHeic = isHeicLike(file);
    let sourceBlob = file;
    let convertedHeic = false;
    let heicLastError = null;
    let didShowToast = false;

    async function convertHeic(toType){
      // First try the heic-to library (more robust for some HEIF variants)
      if (typeof HeicTo === 'function') {
        try {
          const converted = await HeicTo({ blob: file, type: toType, quality: 0.9 });
          if (converted instanceof Blob && converted.size) {
            return converted;
          }
        } catch (err) {
          heicLastError = err instanceof Error ? err : new Error(String(err));
          console.warn('HeicTo conversion failed, falling back to heic2any', err);
        }
      }

      // Fallback to heic2any (local copy, then CDN via loadLegacyHeicDecoder)
      if (typeof heic2any !== 'function') await loadLegacyHeicDecoder();
      if (typeof heic2any !== 'function') throw new Error('HEIC converter unavailable');
      try {
        const converted = await heic2any({ blob: file, toType, quality: 0.92 });
        const blob = Array.isArray(converted) ? converted[0] : converted;
        if (!(blob instanceof Blob)) throw new Error('HEIC conversion returned an invalid result');
        if (!blob.size) throw new Error('HEIC conversion returned empty data');
        return blob && (blob.type ? blob : new Blob([blob], { type: toType }));
      } catch (err) {
        heicLastError = err instanceof Error ? err : new Error(String(err));
        throw heicLastError;
      }
    }

    async function loadLegacyHeicDecoder(){
      if (typeof heic2any === 'function') return true;
      if (heicFallbackLoader) return heicFallbackLoader;
      const loadScript = (src) => new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.onload = () => resolve(true);
        script.onerror = () => reject(new Error('HEIC decoder failed to load'));
        document.head.appendChild(script);
      });

      heicFallbackLoader = (async () => {
        try{
          await loadScript(HEIC_SCRIPT_LOCAL);
        }catch(primaryErr){
          console.warn('Local HEIC decoder failed, falling back to CDN', primaryErr);
          await loadScript(HEIC_SCRIPT_FALLBACK);
        }
        return true;
      })();

      try{
        await Promise.race([
          heicFallbackLoader,
          new Promise((_, rej) => setTimeout(() => rej(new Error('Legacy HEIC decoder load timeout')), 5000))
        ]);
      }catch(err){
        heicFallbackLoader = null;
        throw err;
      }
      return true;
    }

    try {
      if (isHeic) {
        showHeicProcessing('Processing HEIC/HEIF.');
        didShowToast = true;
      }
      if (isHeic) {
        try{
          const blob = await convertHeic('image/jpeg');
          if (blob && blob.size) {
            sourceBlob = blob;
            convertedHeic = true;
          }
        }catch(primaryErr){
          heicLastError = primaryErr;
          try{
            const blob = await convertHeic('image/png');
            if (blob && blob.size) {
              sourceBlob = blob;
              convertedHeic = true;
            }
          }catch(secondaryErr){
            heicLastError = secondaryErr;
            // Try loading a legacy decoder and re-attempt JPEG conversion
            try{
              await loadLegacyHeicDecoder();
              const legacyBlob = await convertHeic('image/jpeg');
              if (legacyBlob && legacyBlob.size) {
                sourceBlob = legacyBlob;
                convertedHeic = true;
              }
            }catch(legacyErr){
              heicLastError = legacyErr;
            }
          }
        }
      }
    } catch (heicErr) {
      console.warn('HEIC conversion failed, falling back to original file', heicErr);
    }

    let decodeResult = null;
    let bmp = null;
    try {
      try {
        decodeResult = await decodeImageDownscaled(sourceBlob, targetEdge);
      } catch (decodeErr) {
        heicLastError = heicLastError || decodeErr;
      }

      // Attempt a last-resort re-decode via dataURL to avoid empty canvases
      if ((!decodeResult || !decodeResult.width || !decodeResult.height) && sourceBlob) {
        try {
          const dataUrl = await blobToDataURL(sourceBlob);
          const tmpBlob = dataURLtoBlob(dataUrl);
          decodeResult = await decodeImageDownscaled(tmpBlob, targetEdge);
        } catch (e) {
          heicLastError = heicLastError || e;
        }
      }

      if (!decodeResult || !decodeResult.width || !decodeResult.height || !decodeResult.bitmap) {
        const reason = heicLastError?.message || 'Decode failed';
        throw new Error(isHeic ? `HEIC decoding failed: ${reason}` : `Image decode failed: ${reason}`);
      }

      bmp = decodeResult.bitmap;
      const sw = decodeResult.width;
      const sh = decodeResult.height;
      const orientation = decodeResult.orientation || 1;
      const orientationApplied = decodeResult.orientationApplied !== false;
      let orientedSource = bmp;
      let orientedW = sw;
      let orientedH = sh;
      let orientationCanvas = null;

      if (orientation !== 1 && !orientationApplied) {
        orientedW = shouldSwapOrientation(orientation) ? sh : sw;
        orientedH = shouldSwapOrientation(orientation) ? sw : sh;
        orientationCanvas = document.createElement('canvas');
        orientationCanvas.width = orientedW;
        orientationCanvas.height = orientedH;
        const octx = orientationCanvas.getContext('2d');
        applyExifOrientation(octx, orientation, sw, sh);
        octx.drawImage(bmp, 0, 0, sw, sh);
        orientedSource = orientationCanvas;
      }

      // determine if source is portrait (after EXIF orientation)
      const isPortrait = orientedH > orientedW;
      // Rotate only if forced AND it is portrait
      const rotate = forceRotate && isPortrait;

      // Output dimensions already downscaled by decoder
      const outW = rotate ? orientedH : orientedW;
      const outH = rotate ? orientedW : orientedH;
      const canvas = document.createElement('canvas');
      canvas.width = outW;
      canvas.height = outH;
      const ctx = canvas.getContext('2d');

      if (rotate) {
        ctx.save();
        ctx.translate(outW / 2, outH / 2);
        ctx.rotate(Math.PI / 2);
        ctx.drawImage(orientedSource, -orientedW / 2, -orientedH / 2, orientedW, orientedH);
        ctx.restore();
      } else {
        ctx.drawImage(orientedSource, 0, 0, orientedW, orientedH);
      }

      disposeCanvas(orientationCanvas);
      return canvas;
    } finally {
      cleanupBitmap(bmp);
      if (didShowToast) hideHeicProcessing();
    }
  });
}


// Preview generator that prefers thumbData and falls back to IDB blobs
async function createPreviewCanvas(item) {
  if (!item) return null;
  if (item._preview) return item._preview;

  const hasThumb = !!item.thumbData;
  if (!item._needsPreview && !hasThumb) return null;
  if (item._loading) return null;

  item._loading = true;
  let revokeUrl = null;
  let fullItem = null;

  try {
    let src = item.thumbData || null;

    if (!src) {
      if (!item.id) return null;
      fullItem = await idbGet(STORE, item.id);
      if (!fullItem) return null;

      if (fullItem.blob) {
        src = URL.createObjectURL(fullItem.blob);
        revokeUrl = src;
      } else if (fullItem.dataURL) {
        src = fullItem.dataURL;
      } else {
        return null;
      }
    }

    const img = new Image();
    await new Promise((res, rej) => {
      img.onload = res;
      img.onerror = rej;
      img.src = src;
    });

    const scale = Math.min(300 / img.width, 300 / img.height, 1);
    const canvas = document.createElement('canvas');
    canvas.width = Math.max(1, Math.floor(img.width * scale));
    canvas.height = Math.max(1, Math.floor(img.height * scale));
    canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
    img.src = '';

    item._preview = canvas;
    item._needsPreview = false;

    // Persist thumbData if we had to build it from the full asset
    if (!item.thumbData) {
      item.thumbData = canvas.toDataURL('image/jpeg', 0.6);
      if (item.id) {
        const base = fullItem || await idbGet(STORE, item.id);
        if (base) {
          const merged = { ...base, ...item, thumbData: item.thumbData };
          merged.blob = base.blob || item.blob;
          merged.dataURL = base.dataURL || item.dataURL;
          await saveItem(merged);
        }
      }
    }

    return canvas;
  } catch (err) {
    console.warn('Preview generation failed for item', item?.id, err);
    return null;
  } finally {
    if (revokeUrl) {
      try { URL.revokeObjectURL(revokeUrl); } catch (_) {}
    }
    delete item._loading;
  }
}

// NEW: Helper to create small thumbnail from full canvas (Fixes memory leak)
function createThumbnailFromCanvas(sourceCanvas) {
  const sw = Number(sourceCanvas?.width) || 0;
  const sh = Number(sourceCanvas?.height) || 0;
  // Guard against zero-sized canvases (can happen if decode failed upstream)
  if (sw === 0 || sh === 0) {
    console.warn('createThumbnailFromCanvas: source canvas has zero size, returning 1x1 thumb');
    const tiny = document.createElement('canvas');
    tiny.width = tiny.height = 1;
    return tiny;
  }

  const thumbScale = Math.min(300 / sw, 300 / sh, 1);
  const t = document.createElement('canvas');
  t.width = Math.max(1, Math.floor(sw * thumbScale));
  t.height = Math.max(1, Math.floor(sh * thumbScale));
  t.getContext('2d').drawImage(sourceCanvas, 0, 0, t.width, t.height);
  return t;
}

const THUMB_MAX = 300;
function encodeThumb(canvas) {
  try {
    return canvas.toDataURL('image/webp', 0.75);
  } catch (_) {
    return canvas.toDataURL('image/jpeg', 0.75);
  }
}

// Rotation helpers
function getRotationDeg(item) {
  const raw = item?.rotation || 0;
  const norm = raw % 360;
  return norm < 0 ? norm + 360 : norm;
}

async function bakeRotationIfNeeded(item, { stripAfterSave = false } = {}) {
  const rotation = getRotationDeg(item);
  if (!rotation) return item;

  return runInImageQueue(async () => {
    const blob = await fetchBlobForItem(item);
    if (!blob) return item;

    const canvas = document.createElement('canvas');
    let bitmap = null;
    let thumbCanvas = null;
    try {
      const targetEdge = Math.max(item.w || DEFAULT_MAX_EDGE, item.h || DEFAULT_MAX_EDGE, DEFAULT_MAX_EDGE);
      const decoded = await decodeImageDownscaled(blob, targetEdge);
      bitmap = decoded.bitmap;
      const rot90 = rotation === 90 || rotation === 270;
      canvas.width = rot90 ? decoded.height : decoded.width;
      canvas.height = rot90 ? decoded.width : decoded.height;

      const ctx = canvas.getContext('2d');
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(rotation * Math.PI / 180);
      ctx.drawImage(bitmap, -decoded.width / 2, -decoded.height / 2, decoded.width, decoded.height);

      const newBlob = await canvasToBlob(canvas, 0.9) || blob;
      item.blob = newBlob;
      item.dataURL = undefined;
      item.imageData = undefined;
      item._hasBlob = true;
      item.w = canvas.width;
      item.h = canvas.height;
      thumbCanvas = createThumbnailFromCanvas(canvas);
      item.thumbData = encodeThumb(thumbCanvas);
      item.rotation = 0; // baked into pixels
      await saveItem(item);
      if (stripAfterSave) stripFullImage(item, true);
      return item;
    } catch (e) {
      console.warn('bakeRotationIfNeeded failed', e);
      return item;
    } finally {
      cleanupBitmap(bitmap);
      disposeCanvas(thumbCanvas);
      disposeCanvas(canvas);
    }
  });
}

async function swapItemAxes(item) {
  if (!item) return;
  return runInImageQueue(async () => {
    const blob = await fetchBlobForItem(item);
    if (!blob) throw new Error('Image not available in storage');

    let bitmap = null;
    let thumbCanvas = null;
    const targetEdge = Math.max(item.w || DEFAULT_MAX_EDGE, item.h || DEFAULT_MAX_EDGE, DEFAULT_MAX_EDGE);
    const canvas = document.createElement('canvas');
    try {
      if (typeof createImageBitmap === 'function') {
        bitmap = await createImageBitmap(blob, { imageOrientation: 'from-image' });
      } else {
        const img = await new Promise((res, rej) => {
          const el = new Image();
          const url = URL.createObjectURL(blob);
          el.onload = () => { res(el); try { URL.revokeObjectURL(url); } catch (_) {} };
          el.onerror = (err) => { rej(err); try { URL.revokeObjectURL(url); } catch (_) {} };
          el.src = url;
        });
        bitmap = img;
      }

      const w = bitmap.width || bitmap.naturalWidth || 0;
      const h = bitmap.height || bitmap.naturalHeight || 0;
      if (!w || !h) throw new Error('Image decode failed');

      // Swap axis lengths by rescaling without rotating (keeps visual orientation)
      canvas.width = h;
      canvas.height = w;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);

      const newBlob = await canvasToBlob(canvas, 0.9);
      item.blob = newBlob;
      delete item.dataURL;
      item.imageData = undefined;
      item._hasBlob = true;
      item.w = canvas.width;
      item.h = canvas.height;
      item.rotation = 0;
      thumbCanvas = createThumbnailFromCanvas(canvas);
      item.thumbData = encodeThumb(thumbCanvas);
      item._preview = null;
      item._needsPreview = true;
      delete item._loading;

      await saveItem(item);
      stripFullImage(item, true);
    } finally {
      cleanupBitmap(bitmap);
      disposeCanvas(thumbCanvas);
      disposeCanvas(canvas);
    }
  });
}

function buildThumbFromSrc(src, revoke = false) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const scale = Math.min(THUMB_MAX / img.width, THUMB_MAX / img.height, 1);
      const cw = Math.max(1, Math.floor(img.width * scale));
      const ch = Math.max(1, Math.floor(img.height * scale));
      if (!cw || !ch) {
        resolve(null);
        try { URL.revokeObjectURL(src); } catch (_) {}
        img.src = '';
        return;
      }
      canvas.width = cw;
      canvas.height = ch;
      canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
      resolve(encodeThumb(canvas));
      if (revoke) try { URL.revokeObjectURL(src); } catch (_) {}
      img.src = '';
    };
    img.onerror = () => {
      resolve(null);
      if (revoke) try { URL.revokeObjectURL(src); } catch (_) {}
      img.src = '';
    };
    img.src = src;
  });
}

async function ensureThumbData(item) {
  if (!item || item.thumbData) return item?.thumbData || null;
  if (item._preview) {
    item.thumbData = encodeThumb(item._preview);
    delete item._preview;
    return item.thumbData;
  }
  if (item.dataURL) {
    item.thumbData = await buildThumbFromSrc(item.dataURL, false);
    return item.thumbData;
  }
  if (item.blob) {
    const url = URL.createObjectURL(item.blob);
    item.thumbData = await buildThumbFromSrc(url, true);
    return item.thumbData;
  }
  return null;
}

// Build and persist a tiny thumbnail so the gallery never needs the full image
async function buildThumbData(item) {
  if (!item || item.thumbData || item._thumbBuilding) return item?.thumbData || null;
  item._thumbBuilding = true;
  const finish = (val) => { item._thumbBuilding = false; return val; };

  try {
    // If we already have a preview canvas, encode it and persist
  if (item._preview) {
    item.thumbData = encodeThumb(item._preview);
    delete item._preview;
    // Save with blob intact (if present) to keep full-res in IDB
    await saveItem(item);
    return finish(item.thumbData);
  }

  const blob = await fetchBlobForItem(item);
  if (!blob) return finish(null);

    const srcUrl = URL.createObjectURL(blob);
    const thumbData = await new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const scale = Math.min(THUMB_MAX / img.width, THUMB_MAX / img.height, 1);
        canvas.width = Math.max(1, Math.floor(img.width * scale));
        canvas.height = Math.max(1, Math.floor(img.height * scale));
        canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
        resolve(encodeThumb(canvas));
        try { URL.revokeObjectURL(srcUrl); } catch (_) {}
        img.src = '';
      };
      img.onerror = () => {
        resolve(null);
        try { URL.revokeObjectURL(srcUrl); } catch (_) {}
        img.src = '';
      };
      img.src = srcUrl;
    });

    if (thumbData) {
      item.thumbData = thumbData;
      // Persist with the blob retained in IDB (but strip from in-memory copy)
      const toPersist = { ...item, blob };
      await saveItem(toPersist);
      stripFullImage(item, true);
    }
    return finish(thumbData);
  } catch (e) {
    console.warn('Failed to build thumbnail', e);
    return finish(null);
  }
}

function requestThumbBuild(item) {
  if (!item || item.thumbData || item._thumbBuilding) return;
  buildThumbData(item).then((data) => {
    if (data) renderGallery();
  });
}

/* Render gallery from state.items (thumb-only, never full images) */
async function renderGallery(){
  const gallery = document.getElementById('gallery');
  gallery.innerHTML = '';
  if (isSelecting) normalizeSelectionOrder();

  // NEW: show placeholder when empty
  const items = [...state.items].sort((a, b) => {
    const ta = new Date(a.whenISO || a.created).getTime() || 0;
    const tb = new Date(b.whenISO || b.created).getTime() || 0;
    return tb - ta;
  });
  if (items.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'gallery-placeholder';
    empty.setAttribute('role', 'status');
    empty.setAttribute('aria-live', 'polite');
    empty.innerHTML = `
      <svg viewBox="0 0 24 24" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <rect x="3" y="7" width="18" height="12" rx="2"></rect>
        <path d="M7 7l2-3h6l2 3"></path>
        <circle cx="12" cy="13" r="4"></circle>
      </svg>
      <div>No photos yet</div>
      <small>Tap "Photo" to add images to this collection.</small>
    `;
    gallery.appendChild(empty);
    const countEl = document.getElementById('count');
    if (countEl) countEl.textContent = '0 items';
    isSelecting = false;
    clearSelectionFlags();
    updateSelectionUI();
    return;
  }

  for (const item of items){
    const card=document.createElement('div'); card.className='thumb';
    if (isSelecting) card.classList.add(item._selected ? 'selected' : 'unselected');
    card.dataset.id = item.id; // NEW: ID for lazy update
    card.style.overflow = 'hidden';
    const rotationDeg = getRotationDeg(item);

    // NEW: Long press to edit description (ignore scroll/move)
    let pressTimer;
    let startX = 0, startY = 0, moved = false;
    const cancelPress = () => { clearTimeout(pressTimer); pressTimer = null; };
    card.addEventListener('pointerdown', (e) => {
      if (e.target.closest('button')) return; // Ignore buttons
      startX = e.clientX; startY = e.clientY; moved = false;
      if (isSelecting) return; // toggle handled on pointerup to avoid scroll false positives
      pressTimer = setTimeout(() => {
        if (moved) return;
        editingItem = item;
        // Populate dialog
        descText.value = item.desc || '';
        descInitials.value = item.tech || ''; // NEW: Populate initials
        const dt = item.whenISO ? new Date(item.whenISO) : (item.created ? new Date(item.created) : new Date());
        // Adjust to local ISO for datetime-local input
        descWhen.value = new Date(dt.getTime() - dt.getTimezoneOffset() * 60000).toISOString().slice(0, 19);
        descPosition.value = fmtBNGDisplay(item.gps);
        
        // CHANGED: Lock position AND date fields visually when editing
        descWhen.disabled = true;
        descWhen.style.opacity = '0.5';
        descPosition.disabled = true;
        descPosition.style.opacity = '0.5';
        descPosition.readOnly = true;

        // Show lock button and reset to locked state
        if(btnUnlockMeta) {
          btnUnlockMeta.style.display = 'inline-flex';
          btnUnlockMeta.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;
        }
        
        const header = descDialog.querySelector('header strong');
        if(header) header.textContent = 'Edit description';
        
        descDialog.showModal();
        if(navigator.vibrate) navigator.vibrate(40);
      }, 600);
    });
    card.addEventListener('pointermove', (e) => {
      if (pressTimer === null && !isSelecting) return;
      const dx = Math.abs((e.clientX || 0) - startX);
      const dy = Math.abs((e.clientY || 0) - startY);
      if (dx > 8 || dy > 8) { moved = true; cancelPress(); }
    });
    card.addEventListener('pointerup', () => {
      if (isSelecting && !moved) toggleItemSelection(item);
      cancelPress();
    });
    card.addEventListener('pointerleave', () => { moved = true; cancelPress(); });
    card.addEventListener('pointercancel', () => { moved = true; cancelPress(); });
    // End long press logic

    // Thumbnail-only rendering (prefer stored thumb, fall back to IDB fetch)
    const preview = await createPreviewCanvas(item);
    const c = document.createElement('canvas');
    c.style.width = '100%';
    c.style.display = 'block';

    const applyPlaceholder = () => {
      c.width = 300;
      c.height = 225;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#1f2937';
      ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle = '#4b5563';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Loading...', c.width/2, c.height/2);
    };

    if (preview) {
      c.width = Math.max(1, preview.width || 300);
      c.height = Math.max(1, preview.height || 225);
      c.getContext('2d').drawImage(preview, 0, 0, c.width, c.height);
    } else if (item.thumbData) {
      try {
        const img = new Image();
        await new Promise((res, rej) => {
          img.onload = res;
          img.onerror = rej;
          img.src = item.thumbData;
        });
        c.width = Math.max(1, img.width || 300);
        c.height = Math.max(1, img.height || 225);
        c.getContext('2d').drawImage(img, 0, 0, c.width, c.height);
        img.src = '';
      } catch (_) {
        applyPlaceholder();
      }
    } else {
      applyPlaceholder();
    }
    if (rotationDeg) {
      c.style.transform = `rotate(${rotationDeg}deg)`;
      c.style.transformOrigin = '50% 50%';
    }

    const hasFullImage = !!(item._hasBlob || item.blob || item.dataURL || item.imageData);
    if (!hasFullImage) {
      const warn = document.createElement('div');
      warn.setAttribute('aria-label', 'Full image missing; export will be low-resolution');
      warn.title = 'Full image missing; replace this photo to export in full quality.';
      warn.style.position = 'absolute';
      warn.style.top = '50%';
      warn.style.left = '50%';
      warn.style.transform = 'translate(-50%, -50%)';
      warn.style.width = '44px';
      warn.style.height = '44px';
      warn.style.borderRadius = '50%';
      warn.style.background = 'rgba(239,68,68,0.92)';
      warn.style.color = '#fff';
      warn.style.display = 'grid';
      warn.style.placeItems = 'center';
      warn.style.fontSize = '18px';
      warn.style.fontWeight = '800';
      warn.style.boxShadow = '0 4px 12px rgba(0,0,0,0.35)';
      warn.textContent = '!';
      card.appendChild(warn);
    }

    if (isSelecting) {
      const indicator = document.createElement('div');
      indicator.className = 'select-indicator';
      indicator.textContent = (item._selected && item._selectedOrder) ? String(item._selectedOrder) : '';
      card.appendChild(indicator);
    }

    const meta=document.createElement('div'); meta.className='meta';
    const when=item.whenISO?new Date(item.whenISO):new Date(item.created);
    let gpsText = '';
    if(item.gps){
      // CHANGED: Handle imported items (accuracy 0)
      const isImport = isImportedGPS(item.gps);
      const suffix = isImport ? ' *' : '';

      if(typeof item.gps.bngE !== 'undefined'){
        // CHANGED: Show only BNG on gallery cards (no Lat/Lon)
        const acc = (!isImport && item.gps.accuracy && item.gps.accuracy > 0) ? ` (~${Math.round(item.gps.accuracy)} m)` : '';
        gpsText = ` â€¢ BNG: E ${item.gps.bngE} N ${item.gps.bngN}${suffix}${acc}`;
      }else if(typeof item.gps.lat === 'number' && typeof item.gps.lon === 'number'){
        const acc = (!isImport) ? ` (~${Math.round(item.gps.accuracy||3)} m)` : '';
        gpsText = ` â€¢ Lat ${item.gps.lat.toFixed(6)}, Lon ${item.gps.lon.toFixed(6)}${suffix}${acc}`;
      }
    }
    meta.innerHTML = `<div><strong>${escapeHTML(item.desc||'(no description)')}</strong><span class="badge">${item.w||'?'}Ã—${item.h||'?'}</span></div>
      <small>${when.toLocaleString()}${gpsText} â€¢ ${escapeHTML(item.tech||'')} â€¢ ${escapeHTML(item.loc||'')}</small>`;
    
    // NEW: replace button (top-left)
    const replaceBtn = document.createElement('button');
    replaceBtn.type = 'button';
    replaceBtn.className = 'replace-btn';
    replaceBtn.title = 'Replace this image';
    replaceBtn.setAttribute('aria-label','Replace this image');
    replaceBtn.innerHTML = `
      <svg viewBox="0 0 24 24" aria-hidden="true" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="7" width="18" height="12" rx="2"></rect>
        <path d="M7 7l2-3h6l2 3"></path>
        <circle cx="12" cy="13" r="4"></circle>
      </svg>`;
    replaceBtn.addEventListener('click', () => {
      const picker = document.createElement('input');

      picker.type = 'file';
      picker.accept = 'image/*';
      picker.style.display = 'none';
           document.body.appendChild(picker);
      picker.addEventListener('change', async () => {
        const file = picker.files?.[0];
        if (!file) { picker.remove(); return; }
        let canvas = null;
        let thumbCanvas = null;
        let exifOrientation = null;
        let exifDims = null;
        try {
          const maxW = 1920;
          try {
            const { exifOrientation: o, exifWidth: w, exifHeight: h } = await extractExifUnified(file, file.name || 'replace');
            exifOrientation = o;
            if (w && h) exifDims = { width: w, height: h };
          } catch (ex) { console.warn('EXIF unified extraction failed', ex); }
          // CHANGED: Always preserve orientation for single replace (pass false)
          canvas = await normalizeImage(file, maxW, false);
          if (!canvas || !canvas.width || !canvas.height) throw new Error('Image decode failed (empty canvas)');
          const swappedCanvas = await maybeSwapCanvasAxesOnImport(file, canvas, exifOrientation, exifDims);
          if (swappedCanvas !== canvas) {
            disposeCanvas(canvas);
            canvas = swappedCanvas;
          }
          
          // CHANGED: Store as Blob
          const blob = await canvasToBlob(canvas, 0.9);
          item.blob = blob;
          delete item.dataURL; // Remove legacy dataURL if present

          item.w = canvas.width;
          item.h = canvas.height;
          thumbCanvas = createThumbnailFromCanvas(canvas);
          item.thumbData = encodeThumb(thumbCanvas);
          item._preview = null;
          item._needsPreview = false;
          
          // CHANGED: Patch item only (no session rewrite)
          await saveItem(item);
          stripFullImage(item, true);
          renderGallery();
        } catch ( err) {
          alert('Failed to replace image: ' + err.message);
          console.error(err);
        } finally {
          disposeCanvas(thumbCanvas);
          disposeCanvas(canvas);
          picker.remove();
        }
      }, { once: true });
      picker.click();
    });

    // NEW: Rotate button
    const rotateBtn = document.createElement('button');
    rotateBtn.type = 'button';
    rotateBtn.className = 'rotate-btn';
    rotateBtn.title = 'Rotate 90Â°';
    rotateBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`;
    rotateBtn.addEventListener('click', () => {
      const next = (getRotationDeg(item) + 90) % 360;
      item.rotation = next;
      // Persist lightweight metadata immediately
      saveItem(item).catch(e => console.warn('Failed to persist rotation', e));
      renderGallery();
    });

    // NEW: Swap dimensions button (re-bake image to fix swapped axes)
    const swapBtn = document.createElement('button');
    swapBtn.type = 'button';
    swapBtn.className = 'swap-btn';
    swapBtn.title = 'Swap W/H pixels (fix aspect)';
    swapBtn.setAttribute('aria-label','Swap W/H pixels (fix aspect)');
    swapBtn.innerHTML = `
      <svg viewBox="0 0 24 24" aria-hidden="true" stroke-linecap="round" stroke-linejoin="round">
        <path d="M7 3h7v7"></path>
        <path d="M7 3l7 7"></path>
        <path d="M17 21h-7v-7"></path>
        <path d="M17 21l-7-7"></path>
      </svg>`;
    swapBtn.addEventListener('click', async () => {
      try {
        await swapItemAxes(item);
        renderGallery();
      } catch (err) {
        alert('Failed to swap dimensions: ' + err.message);
        console.error(err);
      }
    });

    // Updated delete button (uses CSS class, removed duplicate appends)
    const deleteBtn = document.createElement('button');
    deleteBtn.type='button';
    deleteBtn.className='delete-btn';
    deleteBtn.title='Delete this image';
    deleteBtn.setAttribute('aria-label','Delete this image');
    deleteBtn.innerHTML = `
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2"/>
        <path d="M10 11v6M14 11v6" stroke="#f87171" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    deleteBtn.addEventListener('click', async () => {
      if (!confirm('Delete this image from this collection?')) return;
      const index = state.items.indexOf(item);
      if (index > -1) {
        // CHANGED: Revoke any lingering references on delete
        stripFullImage(item, item?._hasBlob);
        
        // CHANGED: Delete from store and update session
        await idbDelete(STORE, item.id);
        state.items.splice(index, 1);
        saveGlobalsToSession(activeSessionId); // Updates ID list
        renderGallery();
      }
    });

    card.appendChild(c);
    card.appendChild(meta);
    card.appendChild(replaceBtn);
    card.appendChild(rotateBtn); // NEW
    card.appendChild(swapBtn); // NEW
    card.appendChild(deleteBtn);
    gallery.appendChild(card);
  }
  const countEl = document.getElementById('count');
  countEl.textContent = fmtCount(state.items.length);
  updateSelectionUI();
}

fileInput.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  disposeCanvas(pendingCanvas);
  pendingCanvas = null;
  pendingBlob = null;
  try{
    const maxW = 1920; 
    let exifGPS = null;
    let exifDate = null;
    let exifOrientation = null;
    let exifDims = null;

    // NEW: Extract EXIF Data (Date & Location)
    // Unified EXIF extraction (HEIC/HEIF + JPEG) using robust parser
    try {
      const { exifDate: d, exifGPS: g, exifOrientation: o, exifWidth: w, exifHeight: h } = await extractExifUnified(f, f.name || 'capture');
      exifDate = d;
      exifGPS = g;
      exifOrientation = o;
      if (w && h) exifDims = { width: w, height: h };
      debugMetaLog('single-unified', { exifDate, exifGPS, exifOrientation, exifWidth: w, exifHeight: h });
    } catch (ex) { console.warn('EXIF unified extraction failed', ex); }

    // CHANGED: Always preserve orientation for single capture (pass false)
    pendingCanvas = await normalizeImage(f, maxW, false);
    const swappedCanvas = await maybeSwapCanvasAxesOnImport(f, pendingCanvas, exifOrientation, exifDims);
    if (swappedCanvas !== pendingCanvas) {
      disposeCanvas(pendingCanvas);
      pendingCanvas = swappedCanvas;
    }
    // NEW: Create blob immediately
    pendingBlob = await canvasToBlob(pendingCanvas, 0.9);

    // Derive BNG if GPS present
    if (exifGPS && typeof exifGPS.lat === 'number' && typeof exifGPS.lon === 'number') {
      try {
        const bng = latLonToBNG(exifGPS.lat, exifGPS.lon);
        exifGPS = { ...exifGPS, bngE: bng.easting, bngN: bng.northing };
      } catch (convErr) {
        console.warn('EXIF BNG conversion failed, falling back to lat/lon', convErr);
      }
    }

    // NEW: Location handling differs for camera vs gallery imports (respect explicit mode)
    const isGalleryCapture = captureMode === 'gallery';
    const isCameraCapture = !isGalleryCapture;
    pendingGPS = null;
    locationTaskID++;
    const myTaskID = locationTaskID;
    
    // Only attempt shutter GPS if Camera mode AND Location is enabled
    shutterGPSPromise = (isCameraCapture && locationEnabled) ? captureShutterLocation() : null;

    if (isGalleryCapture) {
      // Flowchart: Photo 'Gallery' -> EXIF GPS Present?
      isLocationPending = false;
      if (exifGPS) {
        // Yes -> Use EXIF GPS
        pendingGPS = exifGPS;
        if (descPosition) descPosition.value = fmtBNGDisplay(exifGPS);
      } else {
        // No -> 'No Location Data'
        pendingGPS = null;
        if (descPosition) descPosition.value = 'No location data available';
      }
    } else {
      // Photo 'Camera'
      if (locationEnabled) {
        // Flowchart: Location Permissions Enabled? Yes -> Attempt Live GPS
        isLocationPending = true;
        if (descPosition) descPosition.value = 'Acquiring location...';

        (async () => {
          try {
            const perm = navigator.permissions ? await navigator.permissions.query({ name:'geolocation' }) : null;
            if (perm && perm.state === 'denied') {
              if (locationTaskID === myTaskID) {
                pendingGPS = null;
                isLocationPending = false;
                if (descPosition) descPosition.value = 'Location not allowed';
              }
              return;
            }

            const livePos = await (shutterGPSPromise || captureShutterLocation());
            shutterGPSPromise = null;
            
            if (locationTaskID !== myTaskID) return;

            if (livePos) {
              // Success -> Use Live GPS
              pendingGPS = livePos;
              lastKnownPos = livePos;
              if (descPosition) descPosition.value = fmtBNGDisplay(livePos);
            } else {
              // Failure -> 'No Location Data' (Do NOT fallback to EXIF)
              pendingGPS = null;
              if (descPosition) descPosition.value = 'No location data available';
            }
          } catch (e) {
            console.warn('Location acquisition failed', e);
            if (locationTaskID === myTaskID) {
              pendingGPS = null;
              if (descPosition) descPosition.value = 'No location data available';
            }
          } finally {
            if (locationTaskID === myTaskID) isLocationPending = false;
          }
        })();
      } else {
        // Flowchart: Location Permissions Enabled? No -> Ignore EXIF -> 'Location not allowed'
        isLocationPending = false;
        pendingGPS = null;
        if (descPosition) descPosition.value = 'Location not allowed';
      }
    }
    
    // NEW: Reset edit state for new capture
    editingItem = null;

    // CHANGED: Unlock fields for live updates (new capture)
    if(descWhen) {
      descWhen.disabled = false;
      descWhen.style.opacity = '1';
    }
    if(descPosition) {
      descPosition.disabled = false;
      descPosition.style.opacity = '1';
      descPosition.readOnly = true; // Keep readonly for auto-fill
    }
    // Hide lock button for new captures
    if(btnUnlockMeta) btnUnlockMeta.style.display = 'none';

    const header = descDialog.querySelector('header strong');
    if(header) header.textContent = 'Add description';

    if(descText) descText.value='';
    if(descInitials) descInitials.value = state.photographerInitials || ''; // NEW: Auto-fill from memory
    
    // CHANGED: Use EXIF date if available, else now
    const dateToUse = exifDate || new Date();
    if(descWhen) descWhen.value = new Date(dateToUse.getTime()-dateToUse.getTimezoneOffset()*60000).toISOString().slice(0,19);
    
    descDialog.showModal();
  }catch(err){ alert('Failed to process image: '+err); }
  finally{ fileInput.value=''; }
});

// NEW: Bulk upload handlers
if (btnBulkUpload && bulkInput) {
  btnBulkUpload.addEventListener('click', () => bulkInput.click());
  
  bulkInput.addEventListener('change', (e) => {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;
    
    pendingBulkFiles = files;
    if(bulkMsg) bulkMsg.textContent = `Selected ${files.length} photo${files.length===1?'':'s'}.`;
    
    // Load preference
    const saved = localStorage.getItem('cfgRotate');
    if (saved !== null && chkBulkRotate) chkBulkRotate.checked = (saved === 'true');
    
    if(bulkDialog) bulkDialog.showModal();
  });
}

if (btnBulkCancel) {
    btnBulkCancel.addEventListener('click', () => {
        pendingBulkFiles = [];
        bulkInput.value = '';
        bulkDialog.close();
    });
}

if (btnBulkOk) {
    btnBulkOk.addEventListener('click', async () => {
        bulkDialog.close();
        const files = pendingBulkFiles;
        if (files.length === 0) return;

        // Save preference
        if(chkBulkRotate) localStorage.setItem('cfgRotate', chkBulkRotate.checked);

        // Ensure active session
        if(!activeSessionId || !sessions[activeSessionId]){
            try{
                activeSessionId = await createNewSession();
            }catch(err){
                alert('Could not create session.');
                return;
            }
        }

        let processed = 0;
        const total = files.length;
        const originalContent = btnBulkUpload.innerHTML;
        btnBulkUpload.textContent = `Processing 0/${total}...`;
        btnBulkUpload.disabled = true;
        let bulkToast = false;
        try { showHeicProcessing(`Processing ${processed}/${total}â€¦`); bulkToast = true; } catch(_) {}

        try {
            for (const f of files) {
                let canvas = null;
                let thumbCanvas = null;
                try {
                    const maxW = DEFAULT_MAX_EDGE;
                    // Use checkbox state
                    const rotate = chkBulkRotate ? chkBulkRotate.checked : false;
                    canvas = await normalizeImage(f, maxW, rotate);
                    if (!canvas || !canvas.width || !canvas.height) throw new Error('Image decode failed (empty canvas)');
                    
                    // NEW: Extract EXIF Data (unified HEIC/JPEG)
                    let itemGPS = null;
                    let itemDate = new Date();
                    let exifOrientation = null;
                    let exifDims = null;
                    // unified EXIF (no handledHeic flag)
                    try {
                        const { exifDate: d, exifGPS: g, exifOrientation: o, exifWidth: w, exifHeight: h } = await extractExifUnified(f, f.name || 'bulk');
                        if (d) itemDate = d;
                        itemGPS = g;
                        exifOrientation = o;
                        if (w && h) exifDims = { width: w, height: h };
                        debugMetaLog('bulk-unified', { exifDate: itemDate, exifGPS: itemGPS, exifOrientation, exifWidth: w, exifHeight: h });
                    } catch(e) { console.warn('Bulk EXIF unified fail', e); }
                    if (itemGPS && typeof itemGPS.lat === 'number' && typeof itemGPS.lon === 'number') {
                        try {
                            const bng = latLonToBNG(itemGPS.lat, itemGPS.lon);
                            itemGPS = { ...itemGPS, bngE: bng.easting, bngN: bng.northing };
                        } catch (convErr) {
                            console.warn('Bulk EXIF BNG conversion failed, falling back to lat/lon', convErr);
                        }
                    }

                    if (!rotate) {
                        const swappedCanvas = await maybeSwapCanvasAxesOnImport(f, canvas, exifOrientation, exifDims);
                        if (swappedCanvas !== canvas) {
                            disposeCanvas(canvas);
                            canvas = swappedCanvas;
                        }
                    }

                    // CHANGED: Store as Blob
                    const blob = await canvasToBlob(canvas, 0.9);
                    
                    const item = {
                        blob: blob, // Store blob
                        w: canvas.width,
                        h: canvas.height,
                        desc: '', 
                        whenISO: itemDate.toISOString(), // CHANGED: Use EXIF date
                        tech: state.photographerInitials || '',
                        loc: '',
                        created: new Date().toISOString(),
                        gps: itemGPS // CHANGED: Use EXIF GPS
                    };

                    const id = await idbAdd(item);
                    item.id = id;
                    thumbCanvas = createThumbnailFromCanvas(canvas); // CHANGED: Store thumbnail only
                    item.thumbData = encodeThumb(thumbCanvas);
                    item._preview = null;
                    item._needsPreview = false;
                    item._hasBlob = true;
                    stripFullImage(item, true);
                    
                    // CHANGED: Add to state so it appears in gallery and session save
                    state.items.push(item);
                    
                    renderGallery();
                    processed++;
                    btnBulkUpload.textContent = `Processing ${processed}/${total}...`;
                    if (bulkToast) updateHeicProcessing(`Processing ${processed}/${total}.`);
                } catch (err) {
                    console.error('Failed to process a file in bulk upload', err);
                } finally {
                    disposeCanvas(thumbCanvas);
                    disposeCanvas(canvas);
                    await framePause();
                }
            }
            saveGlobalsToSession(activeSessionId); // Save ID list once
            renderGallery();
        } catch (err) {
            alert('Error during bulk upload: ' + err.message);
        } finally {
            if (bulkToast) hideHeicProcessing();
            btnBulkUpload.innerHTML = originalContent;
            btnBulkUpload.disabled = false;
            bulkInput.value = '';
            pendingBulkFiles = [];
        }
    });
}

descCancel.addEventListener('click', ()=>{ disposeCanvas(pendingCanvas); pendingCanvas=null; pendingBlob=null; pendingGPS=null; editingItem=null; descDialog.close(); });
descOK.addEventListener('click', async ()=>{
  // NEW: Handle edit save
  if (editingItem) {
    editingItem.desc = descText.value.trim();
    
    // Update initials and sync to global state (remember for next time)
    const newInitials = descInitials.value.trim();
    editingItem.tech = newInitials;
    if(newInitials) {
      state.photographerInitials = newInitials;
    }

    if (descWhen.value) editingItem.whenISO = new Date(descWhen.value).toISOString();
    
    // CHANGED: Patch item only (Optimized)
    await saveItem(editingItem);
    renderGallery();
    
    editingItem = null;
    descDialog.close();
    return;
  }

  if(!pendingCanvas) { descDialog.close(); return; }
  if(!pendingBlob || !pendingCanvas.width || !pendingCanvas.height){
    alert('Image decode failed; please re-capture or re-import this photo.');
    return;
  }

  // NEW: Check for pending location
  if(isLocationPending) {
    if (!confirm('Location information is still being acquired. Save without location?')) {
        return;
    }
    // If user confirms, proceed to save (pendingGPS will be null or partial)
  }

  // Ensure we have an active session to save into. Create one if needed.
  if(!activeSessionId || !sessions[activeSessionId]){
    try{
      // createNewSession activates the session and returns its id
      activeSessionId = await createNewSession();
    }catch(err){
      console.error('Failed to create a new collection/session', err);
      alert('Unable to save image: could not create a collection.');
      return;
    }
  }

  // Update global state with whatever is in the box now (remember for next time)
  const currentInitials = descInitials.value.trim();
  if(currentInitials) {
      state.photographerInitials = currentInitials;
  }

  // CHANGED: Use pendingBlob
  const item = {
    blob: pendingBlob,
    w: pendingCanvas.width,
    h: pendingCanvas.height,
    desc: descText.value.trim(),
    whenISO: descWhen.value? new Date(descWhen.value).toISOString(): null,
    // CHANGED: Use the dialog value
    tech: currentInitials,
    loc: '', // free-text location removed â€” keep empty, GPS stored under gps    
    created: new Date().toISOString(),
    gps: pendingGPS // may be null if unavailable
  };

  // Legacy store write
  const id = await idbAdd(item);
  item.id = id;
  const thumbCanvas = createThumbnailFromCanvas(pendingCanvas); // CHANGED: Store thumbnail only
  item.thumbData = encodeThumb(thumbCanvas);
  item._preview = null;
  item._needsPreview = false;
  item._hasBlob = true;
  stripFullImage(item, true);
  disposeCanvas(thumbCanvas);

  // Add to in-memory state and persist into the active session
  state.items.push(item);
  saveGlobalsToSession(activeSessionId); // Persist session (ID list)
  renderGallery();

  disposeCanvas(pendingCanvas);
  pendingCanvas = null;
  pendingBlob = null;
  pendingGPS = null;
  descDialog.close();
});
 
// do NOT start watching automatically â€” require user gesture
async function openCollectionsPanel() {
  const panel = document.getElementById('collections');
  if (!panel) {
    console.error('Collections panel not found');
    return;
  }
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
  document.body.classList.add('collections-open');
}

async function closeCollectionsPanel() {
  const panel = document.getElementById('collections');
  if (!panel) {
    console.error('Collections panel not found');
    return;
  }
  panel.classList.remove('open');
  panel.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('collections-open');
}

/* ---------- Startup ---------- */
document.addEventListener('DOMContentLoaded', () => {
  (async function init(){
    await loadPersistedSessions();
       // NEW: check for saved directory handle on startup
    if ('showDirectoryPicker' in window) {
      const savedHandle = await getDirectoryHandle();
      if (savedHandle) {
        // Verify we still have permission. This doesn't prompt the user.
        try {
          const permStatus = await savedHandle.requestPermission({ mode: "readwrite" });
          if (permStatus === "granted") {
            // And verify the handle is still usable by trying a non-destructive read.
            try {
              // `keys()` is a simple async iterator to check usability.
              // We don't need to do anything with the result.
              // If this fails, the handle is stale.
              await savedHandle.keys().next(); 
              dirHandle = savedHandle;
              folderStatus.textContent = `Status: Saving to "${dirHandle.name}" folder.`;
            } catch (e) {
              console.warn('Stale directory handle, re-selection needed.', e);
              folderStatus.textContent = `Status: Re-select "${savedHandle.name}" to grant access.`;
              dirHandle = null;
            }
          } else {
            // Permission was not persisted or was revoked. User must re-grant it.
            folderStatus.textContent = `Status: Permission needed for "${savedHandle.name}". Click "Choose Folder" to re-enable.`;
            dirHandle = null; // Clear the stale handle.
          }
        } catch (err) {
          console.error('Failed to check saved directory handle:', err);
        }
      }
    }
  })();

  const headerRow1 = document.querySelector('.header-row-1');
  window.addEventListener('scroll', () => {
    if (!headerRow1) return;
    if (window.scrollY >  80) headerRow1.classList.add('is-hidden');

    else headerRow1.classList.remove('is-hidden');
  });
});


btnClear?.addEventListener('click', async ()=>{
  if(!confirm('Clear all images from the current collection?')) return;
  // CHANGED: Revoke all URLs before clearing
  state.items.forEach(i => stripFullImage(i, i?._hasBlob));
  state.items = [];
  saveGlobalsToSession(activeSessionId);
  renderGallery();
});

/* ---------- Export helpers that return Blobs ---------- */
async function buildPPTXBlob(fileName, options = {}){
  const allowFallbackDownload = options.allowFallbackDownload !== false;
  const allowDirectSave = options.allowDirectSave !== false;
  const includeTimestamp    = attrTimestampChk?.checked !== false;
  const includePosition     = attrPositionChk?.checked !== false;
  const includeAccuracy     = attrAccuracyChk?.checked !== false;
  const includePhotographer = attrPhotographerChk?.checked !== false;
  const autoSortEnabled     = !!(chkAutoSort && chkAutoSort.checked);
  const noMixEnabled        = autoSortEnabled && !!(chkNoMix && chkNoMix.checked);
  const photographerInitials = (state.photographerInitials || '').trim();

  if(state.items.length===0) { alert('Nothing to export.'); return null; }
  
  // Ensure current session data is saved before export
  saveGlobalsToSession(activeSessionId);

  // NEW: Prepare items list (sorted or original) with selection support
  const finalList = getExportList();
  const hasManualOrder = finalList.length > 0 && finalList.some(i => typeof i._selectedOrder === 'number');
  let exportItems = [...finalList];
  if (autoSortEnabled && !hasManualOrder) {
    // Sort by aspect ratio (descending: Wide -> Square -> Tall)
    // This groups Landscape images together and Portrait images together
    exportItems.sort((a, b) => {
      const ratioA = (a.w || 1) / (a.h || 1);
      const ratioB = (b.w || 1) / (b.h || 1);
      return ratioB - ratioA;
    });
  }

  const layout = parseInt(layoutSel.value,10); // 1,2,4
  const perSlide = layout;
  
  // CHANGED: Grouping logic to support NoMix
  const groups = []; 
  if (noMixEnabled) {
    let currentGroup = [];
    let currentType = null; // 'L' or 'P'
    
    for (const item of exportItems) {
      const type = (item.w >= item.h) ? 'L' : 'P';
      
      // If group is full OR (group has items AND orientation changes), flush group
      if (currentGroup.length > 0 && (currentGroup.length >= perSlide || type !== currentType)) {
        groups.push(currentGroup);
        currentGroup = [];
      }
      
      if (currentGroup.length === 0) {
        currentType = type;
      }
      currentGroup.push(item);
    }
    if (currentGroup.length > 0) groups.push(currentGroup);
  } else {
    for(let i=0;i<exportItems.length;i+=perSlide) groups.push(exportItems.slice(i,i+perSlide));
  }

  // Create a fresh presentation (do not attempt to load a template)
  const pptx = new PptxGenJS();
  try{
    pptx.defineLayout({ name:'A4PORTRAIT', width:8.27, height:11.69 });
    pptx.defineLayout({ name:'A4LANDSCAPE', width:11.69, height:8.27 });
  }catch(e){/*ignore*/}

  const isLandscape = (orientationSel && orientationSel.value === 'landscape');
  try{ pptx.layout = isLandscape ? 'A4LANDSCAPE' : 'A4PORTRAIT'; }catch(e){}

  // Use margins from settings (mm -> inches)
  const marginsMM = 10; // REMOVED: Number(marginsInput.value) || 10;
  const margin = Math.max(0.05, marginsMM / 25.4); // in

  // Slide dimensions based on chosen layout
  const slideW = isLandscape ? 11.69 : 8.27;
  const slideH = isLandscape ? 8.27 : 11.69;

  // Side panel width as proportion of slide width so it scales with orientation
  const sideW = Math.min(2.4, Math.max(1.6, slideW * 0.24)); // clamp to reasonable bounds
  const contentW = slideW - margin*2 - sideW - 0.12; // small gap before side panel
  const contentH = slideH - margin*2;

  // Grid selection: make 2-up side-by-side in landscape, stacked in portrait
  const grid = layout === 1 ? { rows: 1, cols: 1 } : (layout === 2 ? (isLandscape ? { rows: 1, cols: 2 } : { rows: 2, cols: 1 }) : { rows: 2, cols: 2 });
  const cellW = contentW / grid.cols;
  const cellH = contentH / grid.rows;

  // Visual style values
  const blueBar = '8DB2E8';
  const lightGrey = 'F6F8FA';
  const textGrey = '444444';

  // Attempt to load logo data URL once (best-effort). Keep it simple and non-blocking.
  let logoDataUrl = null;
  let logoRatio = null; // NEW: Store aspect ratio
  try{
    const r = await fetch('./brownfield_logo.png', { cache:'no-store' });
    if(r.ok){
      const blob = await r.blob();
      logoDataUrl = await new Promise(res=>{
        const fr = new FileReader();
        fr.onload = ()=>res(fr.result);
        fr.onerror = ()=>res(null);
        fr.readAsDataURL(blob);
      });
      // NEW: Calculate aspect ratio
      if (logoDataUrl) {
        await new Promise(resolve => {
          const img = new Image();
          img.onload = () => { logoRatio = img.width / img.height; resolve(); };
          img.onerror = () => resolve();
          img.src = logoDataUrl;
        });
      }
    }
  }catch(e){ logoDataUrl = null; }

  let slideIndex = 0;
  let globalPhotoIndex = 0; // sequential numbering across slides

  // Insert helper to draw the entire right panel (logo, desc rows, footer fields)
  function addRightPanel(slide, {
    pptx,
    sideX,
    sideW,
    panelTopY,
    panelH,
    textGrey,
    borderBlue,
    panelFill,
    logoDataUrl,
    logoRatio, // NEW: Accept ratio
    pageNumber,
    descItems,        // array of up to 4 { num: 1-based index, text: 'desc...' }
    client,
    project,
    collection,
    photographer,
    includeAccuracy   // NEW: accept accuracy flag
  }) {
    // Internal layout constants
    const innerPadX     = 0.18;
    const innerW        = sideW - (innerPadX * 2);
    const headingFontSize = 12;
    const labelFontSize   = 8;
    const fieldFontSize   = 9;
    const descRowH     = 0.4;
    const descGapY     = 0.08;
    const logoBlockH   = 0.9;
    const postLogoGap  = 0.25;
    const footerLabelH = 0.1;
    const footerBoxH   = 0.27;
    const footerGapY   = 0.15;
    const labelBoxGap  = 0.075; // Increased by 50% from 0.05 to reduce overlap

    // 1. Panel background
    slide.addShape(pptx.ShapeType.rect, { x: sideX, y: panelTopY, w: sideW, h: panelH, fill: { color: panelFill } });

    // --- Top 50% section (Descriptions) ---
    let yCursor = panelTopY + 0.2;
    slide.addText('Photo Descriptions', { x: sideX + innerPadX, y: yCursor, w: innerW, h: 0.3, fontSize: headingFontSize, bold: true, color: textGrey, align: 'left', valign: 'top' });
    yCursor += 0.4;

    // NEW: Dynamic height estimation constants
    const charsPerLine = Math.floor(innerW * 14); // Conservative estimate (approx 14 chars/inch for 9pt)
    const lineHeight = 0.15; 
    const boxPadding = 0.1;

    for (let i = 0; i < 4; i++) {
      const item = descItems[i];
      
      // CHANGED: Prepare text payload as array to support bold number + colon
      let textPayload = '';
      let totalLen = 0;

      if (item) {
        textPayload = [
          { text: `${item.num}: `, options: { bold: true } },
          { text: item.text || '' }
        ];
        totalLen = String(item.num).length + 2 + (item.text || '').length;
      }
      
      // NEW: Calculate height based on text length to auto-expand
      let boxH = descRowH;
      if (totalLen > 0) {
        const lines = Math.ceil(totalLen / charsPerLine);
        // If text needs more than 2 lines (approx capacity of standard box), expand
        if (lines > 2) {
          boxH = Math.max(descRowH, (lines * lineHeight) + boxPadding);
        }
      }

      // CHANGED: Use addText with shape property so text is part of the box
      slide.addText(textPayload, {
        shape: pptx.ShapeType.rect,
        x: sideX + innerPadX,
        y: yCursor,
        w: innerW,
        h: boxH,
        fill: { color: 'FFFFFF' },
        line: { color: borderBlue },
        color: textGrey,
        fontSize: fieldFontSize,
        align: 'left',
        valign: 'top',
        inset: 0.05
      });
      
      yCursor += boxH + descGapY;
    }

    // NEW: Add GPS note below descriptions ONLY if accuracy is enabled
    if (includeAccuracy) {
      slide.addText("Positions are collected via GPS with the approximate accuracy shown in square brackets", {
        x: sideX + innerPadX,
        y: yCursor,
        w: innerW,
        h: 0.3,
        fontSize: 7,
        color: textGrey,
        align: 'left',
        valign: 'top'
      });
      yCursor += 0.3;
    }

    // --- Bottom 50% section (Logo and Footer Fields) ---
    
    // Helper to calc height for footer fields (uses charsPerLine/lineHeight from descriptions logic)
    const calcFieldH = (val) => {
      const len = (val || '').length;
      if (len === 0) return footerBoxH;
      const lines = Math.ceil(len / charsPerLine);
      // Expand if text wraps (approx > 1 line). 0.27 is base.
      return Math.max(footerBoxH, (lines * lineHeight) + boxPadding);
    };

    const hClient = calcFieldH(client);
    const hProject = calcFieldH(project);
    const hCollection = calcFieldH(collection);
    const hPhotographer = calcFieldH(photographer);

    // Calculate total footer height dynamically
    const getBlockH = (boxH) => footerLabelH + labelBoxGap + boxH + footerGapY;
    
    const totalFooterH = (logoBlockH + postLogoGap) 
                       + getBlockH(hClient) 
                       + getBlockH(hProject) 
                       + getBlockH(hCollection) 
                       + getBlockH(hPhotographer);

    // Target start Y: Bottom of panel minus page number space (approx 0.5) minus visual height
    // (visual height is totalFooterH minus the trailing gap from the last field)
    const targetFooterStartY = (panelTopY + panelH) - 0.5 - (totalFooterH - footerGapY);
    
    // Use the calculated bottom-aligned Y, unless descriptions push it further down
    let footerCursor = Math.max(targetFooterStartY, yCursor + 0.1);

    // Logo
    if (logoDataUrl) {
      let w = innerW;
      let h = logoBlockH;
      // CHANGED: Maintain aspect ratio if known to prevent stretching
      if (logoRatio) {
        h = w / logoRatio;
        if (h > logoBlockH) {
          h = logoBlockH;
          w = h * logoRatio;
        }
      }
      slide.addImage({ data: logoDataUrl, x: sideX + innerPadX, y: footerCursor, w: w, h: h });
    } else {
      slide.addText('BROWNFIELD\nSOLUTIONS', { x: sideX + innerPadX, y: footerCursor + 0.1, w: innerW, h: logoBlockH, fontSize: 12, bold: true, color: textGrey, align: 'left', valign: 'top' });
    }
    footerCursor += logoBlockH + postLogoGap;

    // Footer Fields
    function drawFooterField(label, value, height) {
      slide.addText(label, { x: sideX + innerPadX, y: footerCursor, w: innerW, h: footerLabelH, fontSize: labelFontSize, bold: true, color: textGrey, align: 'left', valign: 'top' });
      const boxY = footerCursor + footerLabelH + labelBoxGap;
      
      // CHANGED: Use addText with shape property so text is part of the box
      slide.addText(value || '', {
        shape: pptx.ShapeType.rect,
        x: sideX + innerPadX,
        y: boxY,
        w: innerW,
        h: height,
        fill: { color: 'FFFFFF' },
        line: { color: borderBlue },
        color: textGrey,
        fontSize: fieldFontSize,
        align: 'left',
        valign: 'top',
        inset: 0.05
      });

      footerCursor += footerLabelH + labelBoxGap + height + footerGapY;
    }

    // CHANGED LABELS FOR EXPORT FOOTER
    drawFooterField('CLIENT', client || '', hClient);
    drawFooterField('JOB NO.', project || '', hProject);
    drawFooterField('JOB NAME', collection || '', hCollection);
    drawFooterField('PHOTOBOARD TITLE', photographer || '', hPhotographer);

    // Page number (remains at the absolute bottom of the panel)
    slide.addText(`Page ${pageNumber}`, { x: sideX, y: panelTopY + panelH - 0.3, w: sideW - 0.1, h: 0.2, fontSize: 8, color: textGrey, align: 'right' });
   }

  const activeSession = sessions[activeSessionId] || {};
  for(const group of groups){
    slideIndex++;
    const slide = pptx.addSlide();

    // Background
    try{ slide.addShape(pptx.ShapeType.rect, { x:0, y:0, w:slideW, h:slideH, fill:{ color:'FFFFFF' } }); }catch(e){}

    // Right-hand panel background (keep panel background creation for compatibility)
    const sideX = slideW - margin - sideW;
    try{ slide.addShape(pptx.ShapeType.rect, { x: sideX, y: margin, w: sideW, h: contentH, fill:{ color: lightGrey } }); }catch(e){}

    // NEW: Check if all images in this group are portrait to optimize vertical space
    const allPortrait = group.every(i => (i.h > i.w));

    // Add images to the slide
    // CHANGED: Use for...of loop to support await
    for (const [idx, item] of group.entries()) {
      const r = Math.floor(idx / grid.cols);
      const c = idx % grid.cols;
      const cellX = margin + c * cellW;
      const cellY = margin + r * cellH;

      // CHANGED: Optimize maxImageH for portrait-only pages
      // Standard: 80% of cell height.
      // Optimized: Cell height minus fixed text allowance (approx 0.65 inches for caption + gap)
      // This allows portrait images in 4-up grids to be taller.
      const textAllowance = 0.65; 
      const maxImageH = allPortrait ? Math.max(cellH * 0.8, cellH - textAllowance) : (cellH * 0.8);
      
      // Calculate scaled image size to fit within cellW and maxImageH, preserving aspect ratio
      const imgAspect = item.w / item.h;
      let imgW = cellW;
      let imgH = imgW / imgAspect;
      
      // Fit to height constraint
      if (imgH > maxImageH) {
        imgH = maxImageH;
        imgW = imgH * imgAspect;
      }
      // Fit to width constraint (safety check)
      if (imgW > cellW) {
        imgW = cellW;
        imgH = imgW / imgAspect;
      }

      // Center the image horizontally
      const imgX = cellX + (cellW - imgW) / 2;
      
      // CHANGED: Center the image vertically within the allocated image area
      // This ensures portrait images float in the middle rather than sticking to the top
      const imgY = cellY + (maxImageH - imgH) / 2;
      
      try {
        // CHANGED: Convert Blob to DataURL for PPTX generation if needed
        let imgData = item.dataURL;
        if (!imgData) {
          const blob = await fetchBlobForItem(item);
          if (blob) imgData = await blobToDataURL(blob);
        }
        if (imgData) {
          slide.addImage({ data: imgData, x: imgX, y: imgY, w: imgW, h: imgH });
        }
      } catch (e) {
        console.warn('Failed to add image to slide', e);
      }

      // --- NEW caption logic: two lines (Photo + timestamp, then BNG/coords) ---
      globalPhotoIndex++;
      const dt = item.whenISO ? new Date(item.whenISO) : (item.created ? new Date(item.created) : new Date());
      // Locale-friendly compact timestamp (DD/MM/YYYY HH:MM)
      const ts = dt.toLocaleString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      }).replace(',', '');

      // Line 1: Photo number + optional timestamp + optional photographer initials
      let line1 = `Photo ${globalPhotoIndex}`;
      if (includeTimestamp) {
        line1 += ` â€“ ${ts}`;
        if (includePhotographer && photographerInitials) {
          line1 += ` â€“ ${photographerInitials}`;
        }
      }

      // Line 2 (position + optional accuracy)
      let line2 = '';
      if (item.gps) {
        const isImport = isImportedGPS(item.gps);
        const suffix = isImport ? ' *' : '';

        if (includePosition) {
          if (typeof item.gps.bngE !== 'undefined') {
            line2 = `BNG: E ${item.gps.bngE} N ${item.gps.bngN}${suffix}`;
          } else if (typeof item.gps.lat === 'number' && typeof item.gps.lon === 'number') {
            line2 = `Lat ${item.gps.lat.toFixed(6)}, Lon ${item.gps.lon.toFixed(6)}${suffix}`;
          }
        }
        
        // CHANGED: Only show accuracy if NOT imported
        if (!isImport && includeAccuracy && typeof item.gps.accuracy === 'number' && !isNaN(item.gps.accuracy)) {
          const accStr = `[~${Math.round(item.gps.accuracy)} m]`;
          line2 = line2 ? `${line2} ${accStr}` : accStr;
        }
      }

      const captionText = line2 ? `${line1}\n${line2}` : line1;

      // Calculate text position relative to the actual image position
      const textY = imgY + imgH + 0.05;
      // Ensure text box doesn't exceed cell bounds
      const textH = Math.max(0.3, (cellY + cellH) - textY);

      slide.addText(captionText, {
        x: cellX + 0.05,
        y: textY,
        w: cellW - 0.1,
        h: textH,
        fontSize: 8,
        color: textGrey,
        align: 'center',
        valign: 'top'
      });
    } // End group loop

    // Build descItems for this slide using the sequential globalPhotoIndex.
    // globalPhotoIndex was incremented while adding images above.
    const startNum = Math.max(1, globalPhotoIndex - group.length + 1);
    const descItems = group.map((item, idx) => ({
      num: startNum + idx,
      text: (item.desc || '').replace(/\r?\n/g, ' ')
    }));

    // Draw the entire right panel using the helper (logo, desc rows, footer fields, page number)
    addRightPanel(slide, {
      pptx,
      sideX,
      sideW,
      panelTopY: margin,
      panelH: contentH,
      textGrey,
      borderBlue: blueBar,
      panelFill: lightGrey,
      logoDataUrl,
      logoRatio, // NEW: Pass ratio
      pageNumber: slideIndex,
      descItems,
      // CHANGED: Force uppercase for project details
      client:       (activeSession.client || '').toUpperCase(),
      project:      (activeSession.project || '').toUpperCase(),
      collection:   (activeSession.name || '').toUpperCase(),
      photographer: (activeSession.photographer || '').toUpperCase(),
      includeAccuracy // NEW: pass the flag
    });

    // Slide number bottom-right outside panel is now handled by addRightPanel; if you still
    // want an extra page text outside, keep previous call (optional).
  }

  // Write blob and ensure PPTX MIME

  try{
    const rawBlob = await pptx.write('blob');
    const pptxMime = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';

    let outBlob = rawBlob;
    try{ if(!rawBlob.type || !rawBlob.type.includes('presentation')) outBlob = new Blob([rawBlob], { type: pptxMime }); }catch(e){ outBlob = rawBlob; }
    
    // NEW: If we have a directory handle, save directly to the file system.
    if (allowDirectSave && dirHandle && (await dirHandle.queryPermission({ mode: 'readwrite' })) === 'granted') {
      try {
        const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(outBlob);
        await writable.close();
        alert(`Successfully saved "${fileName}" to your chosen directory.`);
        return null; // Indicate that download is not needed
      } catch (err) {
        console.error('Failed to save file directly:', err);
        alert(`Failed to save to directory. Falling back to download.\nError: ${err.message}`);
        // Fall through to return blob for normal download
      }
    }
    
    return outBlob;
  }catch(err){
    if (!allowFallbackDownload) throw err;
    console.warn('pptx write(blob) failed, trying fallback writeFile/save', err);
    try{
      const name = fileName || `evidence_${new Date().toISOString().slice(0,10)}_${layoutSel.value}ppA4.pptx`;
      if(typeof pptx.writeFile === 'function'){ await pptx.writeFile({ fileName: name }); return null; }
      else if(typeof pptx.save === 'function'){ await pptx.save(name); return null; }
      else throw err;
    }catch(e){ console.error('pptx fallback failed', e); throw e; }
  }
}
/* local downloads for manual export */
function sanitizeFileName(name, fallback = 'photo') {
  const cleaned = (name || fallback).toString().trim().replace(/[<>:"/\\|?*\u0000-\u001f]+/g, ' ').replace(/\s+/g, ' ').slice(0, 40);
  return cleaned || fallback;
}

async function ensureJpegBlob(item) {
  try {
    await bakeRotationIfNeeded(item);
    const srcBlob = await fetchBlobForItem(item);
    if (srcBlob && (srcBlob.type || '').toLowerCase().includes('jpeg')) return srcBlob;

    let dataURL = srcBlob ? await blobToDataURL(srcBlob) : null;
    if (!dataURL) {
      const resolved = await resolveExportImageData(item);
      dataURL = resolved?.dataURL || null;
    }
    if (!dataURL) return null;

    const img = new Image();
    await new Promise((res, rej) => {
      img.onload = res;
      img.onerror = rej;
      img.src = dataURL;
    });

    const canvas = document.createElement('canvas');
    canvas.width = img.naturalWidth || img.width || item.w || 1;
    canvas.height = img.naturalHeight || img.height || item.h || 1;
    canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
    img.src = '';

    return await new Promise(resolve => {
      canvas.toBlob(b => resolve(b || dataURLtoBlob(dataURL)), 'image/jpeg', 0.92);
    });
  } catch (e) {
    console.warn('ensureJpegBlob failed', e);
    return null;
  }
}

async function buildZipBlob(options = {}) {
  const includePptx = options.includePptx === true;
  if (typeof JSZip === 'undefined') throw new Error('Zip library not available.');
  const finalList = getExportList();
  if (!finalList.length) { alert('Nothing to export.'); return null; }

  const zip = new JSZip();
  let added = 0;
  let pptxFailed = false;

  for (let idx = 0; idx < finalList.length; idx++) {
    const item = finalList[idx];
    const jpegBlob = await ensureJpegBlob(item);
    if (!jpegBlob) continue;
    const label = sanitizeFileName(item.desc || item.name || item.filename || `photo_${idx + 1}`);
    const fname = `${String(++added).padStart(3,'0')}_${label}.jpg`;
    zip.file(fname, jpegBlob, { binary: true });
  }

  if (!added) {
    alert('No images could be prepared for zip export (missing image data).');
    return null;
  }

  if (includePptx) {
    try {
      const pptxFileName = `evidence_${new Date().toISOString().slice(0,10)}_${layoutSel.value}ppA4.pptx`;
      const pptxBlob = await buildPPTXBlob(pptxFileName, { allowFallbackDownload: false, allowDirectSave: false });
      if (pptxBlob) {
        zip.file(pptxFileName, pptxBlob, { binary: true });
      } else {
        pptxFailed = true;
      }
    } catch (e) {
      console.warn('PPTX build failed for zip export', e);
      pptxFailed = true;
    }
  }

  if (pptxFailed) {
    alert('PowerPoint generation failed; exporting photos only.');
  }

  return zip.generateAsync({ type: 'blob' });
}

function buildZipConfirmMessage() {
  const total = state.items.length;
  const selectedCount = getSelectedItems().length;
  const exportingAll = selectedCount === 0 || selectedCount === total;
  if (exportingAll) {
    const label = total === 1 ? 'photo' : 'photos';
    return `Are you sure you want to export all ${total} ${label} from this collection?`;
  }
  const label = selectedCount === 1 ? 'photo' : 'photos';
  return `Are you sure you want to export ${selectedCount} selected ${label}?`;
}

function openZipConfirmDialog() {
  const message = buildZipConfirmMessage();
  if (!zipConfirmDialog || typeof zipConfirmDialog.showModal !== 'function') {
    const confirmed = confirm(message);
    return Promise.resolve({ confirmed, includePptx: true });
  }

  if (zipConfirmText) zipConfirmText.textContent = message;
  if (chkZipIncludePPTX) chkZipIncludePPTX.checked = true;
  zipConfirmDialog.returnValue = '';

  return new Promise(resolve => {
    const handleConfirm = () => {
      zipConfirmDialog.returnValue = 'confirm';
      zipConfirmDialog.close();
    };
    const handleCancel = () => {
      zipConfirmDialog.returnValue = 'cancel';
      zipConfirmDialog.close();
    };
    const handleClose = () => {
      if (btnZipConfirm) btnZipConfirm.removeEventListener('click', handleConfirm);
      if (btnZipCancel) btnZipCancel.removeEventListener('click', handleCancel);
      const confirmed = zipConfirmDialog.returnValue === 'confirm';
      const includePptx = confirmed ? !!chkZipIncludePPTX?.checked : false;
      resolve({ confirmed, includePptx });
    };

    if (btnZipConfirm) btnZipConfirm.addEventListener('click', handleConfirm);
    if (btnZipCancel) btnZipCancel.addEventListener('click', handleCancel);
    zipConfirmDialog.addEventListener('close', handleClose, { once: true });
    zipConfirmDialog.showModal();
  });
}

async function runPPTXExport() {
  // NEW: Warn about missing logo if not installed
  if (!computeInstalled()) {
    if (!confirm("Warning: When running in the browser (not installed), the company logo may not be included in the PowerPoint export due to browser security restrictions.\n\nDo you want to continue?")) {
      return;
    }
  }

  const wasSelecting = isSelecting;

  try {
    // Close settings panel on start
    settingsPanel.style.right = '-320px';
    
         
    const fileName = `evidence_${new Date().toISOString().slice(0,10)}_${layoutSel.value}ppA4.pptx`;
    const blob = await buildPPTXBlob(fileName);
    if(!blob) { if (wasSelecting) cancelSelectionMode(); return; } // fallback handled download
    const a=document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = fileName;
    a.click();
    setTimeout(() => { try { URL.revokeObjectURL(url); } catch (_) {} }, 0);
    if (wasSelecting) cancelSelectionMode();
  } catch (err) {
    alert('PPTX export failed: ' + err.message);
    console.error('PPTX export error:', err);
  }
}

async function runZipExport(options = {}) {
  if (!state.items.length) { alert('Nothing to export.'); return; }
  if (typeof JSZip === 'undefined') { alert('Zip export is unavailable (JSZip not loaded).'); return; }
  const wasSelecting = isSelecting;

  try {
    settingsPanel.style.right = '-320px';
    const blob = await buildZipBlob(options);
    if (!blob) { if (wasSelecting) cancelSelectionMode(); return; }

    const fileName = `photos_${new Date().toISOString().slice(0,10)}.zip`;
    const a=document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = fileName;
    a.click();
    setTimeout(() => { try { URL.revokeObjectURL(url); } catch (_) {} }, 0);
    if (wasSelecting) cancelSelectionMode();
  } catch (err) {
    alert('ZIP export failed: ' + err.message);
    console.error('ZIP export error:', err);
  }
}

async function runZipExportWithConfirm() {
  if (!state.items.length) { alert('Nothing to export.'); return; }
  if (typeof JSZip === 'undefined') { alert('Zip export is unavailable (JSZip not loaded).'); return; }
  const { confirmed, includePptx } = await openZipConfirmDialog();
  if (!confirmed) return;
  if (includePptx && !computeInstalled()) {
    if (!confirm("Warning: When running in the browser (not installed), the company logo may not be included in the PowerPoint export due to browser security restrictions.\n\nDo you want to continue?")) {
      return;
    }
  }
  await runZipExport({ includePptx });
}

if(btnConfirmExport) {
  btnConfirmExport.addEventListener('click', runPPTXExport);
}
if (btnExportSelected) {
  btnExportSelected.addEventListener('click', () => {
    if (!isSelecting) return;
    confirmSelection();
  });
}
if (btnExportZip) {
  btnExportZip.addEventListener('click', async () => {
    await runZipExportWithConfirm();
  });
}
</script>

<script>
/* ---------- Session Manager (clean implementation) ---------------- */
const sessions = {};           // id -> session object
let activeSessionId = null;

// NEW: Helper to save current global state into the session object
// CHANGED: Now saves only metadata and item IDs (lightweight)
async function saveGlobalsToSession(id) {
  if (!id || !sessions[id]) return;
  const s = sessions[id];
  
  // Sync state to session object
  // CHANGED: Map items to IDs only
  s.items = state.items.map(i => i.id);
  
  s.client = state.client;
  s.project = state.project;
  s.photographer = state.photographer;
  s.photographerInitials = state.photographerInitials;
  
  // Ensure title is synced if this is the active session
  if (id === activeSessionId && collectionTitleInput) {
    s.name = collectionTitleInput.value.trim() || s.name;
  }

  s.lastModified = Date.now(); // NEW: Update timestamp on save

  await persistSession(s);
}

async function persistSession(session) {
  // ensure session has an id
  if (!session || !session.id) throw new Error('Invalid session');
  await idbAddSession(session);
}

async function createNewSession(fromData = null) {
  const id = Date.now(); // CHANGED: Use numeric ID to play nice with autoIncrement
  const name = fromData?.name || `Collection ${new Date().toLocaleString()}`;
  
  const newSession = {
    id,
    name,
    client: fromData?.client || '',
    project: fromData?.project || '',
    photographer: fromData?.photographer || '',
    photographerInitials: fromData?.photographerInitials || '',
    lastModified: Date.now(), // NEW: Init timestamp
    items: fromData?.items ? fromData.items.slice() : []
  };
  sessions[id] = newSession;
  await persistSession(newSession);
  await activateSession(id);
  return id;
}

async function importSession(data) {
  const id = Date.now(); // Numeric ID
  const name = `${data.name || 'Untitled'} (Imported)`;

  // Basic validation from working version
  if (!data || typeof data !== 'object') throw new Error('Invalid JSON file');

  // Normalize items from working version
  const rawItems = Array.isArray(data.items) 
    ? data.items
        .filter(i => i && typeof i === 'object')
        .map(i => normaliseLegacyItem({ ...i })) 
    : [];
  if (!rawItems.length) throw new Error('No items found in JSON (expected an array of objects).');
  showImportDebug(`Starting import "${name}" with ${rawItems.length} items`);
  // Efficient processing: Save items to IDB, get IDs
  const itemIds = [];
  const thumbFallback = [];
  const skippedMissing = [];
  for (let idx = 0; idx < rawItems.length; idx++) {
    const item = rawItems[idx];
    // Strip old ID
    delete item.id;
    delete item.imageSource; // export-only hint
    // Ensure created date
    if (!item.created) item.created = new Date().toISOString();
    const label = item.desc || item.filename || item.name || `Item ${idx + 1}`;
    let usedThumbFallback = false;

    // Normalise incoming media fields (prefer explicit full image payloads)
    if (!item.dataURL && item.imageData) {
      item.dataURL = item.imageData;
    }

    // Convert embedded dataURL/imageData to Blob
    if (!item.blob && item.dataURL) {
      try {
        if (typeof dataURLtoBlob === 'function') {
          item.blob = dataURLtoBlob(item.dataURL);
          item._hasBlob = true;
          delete item.dataURL;
          delete item.imageData;
        }
      } catch (e) {
        console.warn('Blob conversion failed', e);
        showImportDebug(`Blob conversion failed for "${label}"`, 'error');
      }
    }

    // Fallback: build a blob from thumbData so the item is at least importable
    if (!item.blob && item.thumbData) {
      try {
        if (typeof dataURLtoBlob === 'function') {
          item.blob = dataURLtoBlob(item.thumbData);
          usedThumbFallback = true;
          item._hasBlob = true;
        }
      } catch (e) {
        console.warn('Thumb fallback failed', e);
        showImportDebug(`Thumbnail fallback failed for "${label}"`, 'error');
      }
    }

    // Abort this item if we still have no image payload
    if (!item.blob) {
      skippedMissing.push(label);
      showImportDebug(`Missing image data for "${label}" - skipping item`, 'error');
      continue;
    }

    // Drop redundant base64 now that we have a blob representation
    delete item.imageData;
    delete item.dataURL;

    // Handle HEIC normalization
    if (!usedThumbFallback && item.blob && isHeicLike(item.blob, item.name || item.filename || '')) {
      try {
        const heicFile = new File([item.blob], item.name || item.filename || 'import.heic', { type: item.blob.type || 'image/heic' });
        const canvas = await normalizeImage(heicFile, DEFAULT_MAX_EDGE, false);
        item.blob = await canvasToBlob(canvas, 0.9);
        item.w = canvas.width;
        item.h = canvas.height;
        const thumbCanvas = createThumbnailFromCanvas(canvas);
        item.thumbData = encodeThumb(thumbCanvas);
        item._needsPreview = false;
        disposeCanvas(thumbCanvas);
        disposeCanvas(canvas);
      } catch (e) {
        console.warn('HEIC import conversion failed', e);
      }
    }

    // Ensure thumbData (generate thumbnail if needed)
    await ensureThumbData(item); // Assuming this generates _preview if missing and sets thumbData

    // Add to IDB, get new ID
    const newId = await idbAdd(item);
    itemIds.push(newId);
    showImportDebug(`Imported item -> new ID ${newId} (${label})`);

    if (usedThumbFallback) thumbFallback.push(label);

    // Strip full image from memory (keep thumbData)
    stripFullImage(item, true); // Assuming true keeps blob temporarily if needed, but strips dataURL
  }

  // Surface any media issues to the user
  if (skippedMissing.length) {
    const sample = skippedMissing.slice(0, 5).join(', ');
    const suffix = skippedMissing.length > 5 ? ` â€¦+${skippedMissing.length - 5} more` : '';
    alert(`Import skipped ${skippedMissing.length} item(s) missing image data: ${sample}${suffix}`);
  }
  if (thumbFallback.length) {
    const sample = thumbFallback.slice(0, 5).join(', ');
    const suffix = thumbFallback.length > 5 ? ` â€¦+${thumbFallback.length - 5} more` : '';
    alert(`Imported ${thumbFallback.length} item(s) using thumbnail data only. They may appear low-resolution. ${sample}${suffix}`);
  }

  // Construct session with IDs (efficient)
  const newSession = {
    id,
    name,
    created: Date.now(),
    lastModified: Date.now(),
    items: itemIds,
    client: data.client || '',
    project: data.project || '',
    photographer: data.photographer || '',
    photographerInitials: data.photographerInitials || ''
  };

  // Inject into memory and IDB
  sessions[id] = newSession;
  await idbAddSession(newSession);

  // Activate and alert
  await activateSession(id);
  showImportDebug(`Import complete: session ${id} activated`);
  alert(`Imported "${name}" with ${itemIds.length} items.`);
}

async function activateSession(id) {
  if (!id || !sessions[id] || id === activeSessionId) return;
  isSelecting = false;
  clearSelectionFlags();
  updateSelectionUI();
  
  // Persist current session first before switching
  if (activeSessionId && sessions[activeSessionId]) {
    saveGlobalsToSession(activeSessionId);
       // CHANGED: Revoke URLs from the old session to free memory
    state.items.forEach(i => stripFullImage(i, i?._hasBlob));
  }
  
  await loadSessionToGlobals(id);
}

async function loadSessionToGlobals(id) {
  if (!id || !sessions[id]) return;
 
  const s = sessions[id];
  activeSessionId = id;

  // CHANGED: Hydrate items from IDs
  state.items = [];
  if (s.items && s.items.length > 0) {
    // Check if items are IDs or legacy objects
    if (typeof s.items[0] === 'object') {
      // Legacy: items are embedded
      state.items = s.items.map(raw => {
        const item = { ...raw };
        item._hasBlob = !!(item.blob || item.dataURL);
        item._needsPreview = !item.thumbData;
        stripFullImage(item, item._hasBlob);
        return item;
      });
    } else {
      // New: items are IDs, fetch them
      // We fetch in parallel for speed
      const promises = s.items.map(itemId => idbGet(STORE, itemId));
      const results = await Promise.all(promises);
      state.items = results
        .filter(i => i)
        .map(raw => {
          const item = { ...raw };
          item._hasBlob = !!(item.blob || item.dataURL);
          item._needsPreview = !item.thumbData;  // CHANGED: Always need preview if no thumbData
          stripFullImage(item, item._hasBlob);
          return item;
        }); // filter out any missing
    }
  }
  clearSelectionFlags();
  isSelecting = false;
  
  // Populate text inputs
  state.client = s.client || '';
  state.project = s.project || '';
  state.photographer = s.photographer || '';
  state.photographerInitials = s.photographerInitials || '';

  collectionTitleInput.value = s.name || '';
  clientNameInput.value = state.client;
  projectTitleInput.value = state.project;
  photographerNameInput.value = state.photographer;
  // REMOVED: photographerInitialsInput.value = state.photographerInitials;

  // UPDATE UI
  renderGallery();   // Re-draws the grid of photos
  renderSessions();  // Updates the sidebar list
}

function renderSessions() {
  const listEl = document.getElementById('collectionsList');
  if (!listEl) return;
  listEl.innerHTML = '';

  Object.values(sessions).forEach(s => {
    const li = document.createElement('li');
    li.className = 'session-tab' + (s.id == activeSessionId ? ' active' : ''); // CHANGED: Loose equality for ID match

    const albumBtn = document.createElement('button');
    albumBtn.type = 'button';
    albumBtn.className = 'album-btn';
    albumBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
               <rect x="3" y="5" width="18" height="14" rx="2"></rect>
               <path d="M7 11h4l1.5-2 4 5"></path>
               <circle cx="9" cy="14.5" r="2.1"></circle>
             </svg>`;
    if (s.id == activeSessionId) { // CHANGED: Loose equality
      albumBtn.classList.add('active');
      albumBtn.title = 'Current collection';
    } else {
      albumBtn.title = 'Set as current collection';
    }
    albumBtn.addEventListener('click', async ev => {
      ev.stopPropagation();
      if (s.id != activeSessionId) await activateSession(s.id); // CHANGED: Loose equality
    });

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = s.name || '(untitled)';
    nameInput.className = 'tab-name'; // CHANGED class
    // nameInput.style.flex = '1'; // Handled by CSS class now
    nameInput.title = 'Edit collection name';
    nameInput.addEventListener('change', async (ev) => {
      s.name = nameInput.value.trim() || s.name;
      await persistSession(s);
      if (s.id == activeSessionId) collectionTitleInput.value = s.name; // CHANGED: Loose equality
      renderSessions();
    });
    nameInput.addEventListener('click', ev => ev.stopPropagation());

    // NEW: Action buttons container
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'session-actions';

    const exportBtn = document.createElement('button');
    exportBtn.type = 'button';
    exportBtn.className = 'btn-action'; // CHANGED class
    exportBtn.title = 'Export this collection to JSON';
    // CHANGED: Updated SVG to match "external link" style icon
    exportBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>`;
    exportBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      handleExportCollection(s.id);
    });

    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'btn-action delete'; // CHANGED class
    closeBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`; // CHANGED to SVG icon
    closeBtn.title = 'Delete collection';
    closeBtn.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      const hasData = s.items && s.items.length > 0;
      const promptMsg = hasData ? 'Delete this collection and all its photos? This cannot be undone.' : 'Delete this empty collection?';
      if (!confirm(promptMsg)) return;
      // delete from memory and IDB
      delete sessions[s.id];
      await idbDeleteSession(s.id);
      // if it was active, pick another or create default
      if (activeSessionId == s.id) { // CHANGED: Loose equality
        const keys = Object.keys(sessions);
        if (keys.length) await activateSession(keys[0]);
        else await createNewSession();
      } else {
        renderSessions();
      }
    });

    li.addEventListener('click', () => { activateSession(s.id); });

    li.appendChild(albumBtn);
    li.appendChild(nameInput);
    
    actionsDiv.appendChild(exportBtn);
    actionsDiv.appendChild(closeBtn); // Moved inside actionsDiv
    li.appendChild(actionsDiv);

    listEl.appendChild(li);
  });

  // Emphasised header summary with album icon that opens Collections panel
  const summary = document.getElementById('tabsSummary');
  if (summary) {
    const name = sessions[activeSessionId]?.name || '';
    summary.innerHTML = name
      ? `<button id="activeCollectionChip" class="collection-chip" title="Open collections">
             <svg viewBox="0 0 24 24" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
               <rect x="3" y="5" width="18" height="14" rx="2"></rect>
               <path d="M7 11h4l1.5-2 4 5"></path>
               <circle cx="9" cy="14.5" r="2.1"></circle>
             </svg>
             <span>${escapeHTML(name)}</span>
           </button>`
        : '';
      const chip = document.getElementById('activeCollectionChip');
      if (chip) {
        chip.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          // open Collections panel
          openCollectionsPanel?.();
        });
      }
    }
  }

  async function loadPersistedSessions() {
    // read all sessions from indexeddb
    const arr = await idbAllSessions();
    if (Array.isArray(arr) && arr.length) {
      arr.forEach(s => { sessions[s.id] = s; }); // CHANGED: Use raw ID (Number)
      
      // NEW: Sort by lastModified (descending) so most recent is first
      // Fallback to ID (creation time) if lastModified is missing
      arr.sort((a, b) => (b.lastModified || b.id) - (a.lastModified || a.id));

      // pick first session as active
      const firstId = arr[0].id; // CHANGED: Use raw ID
      await activateSession(firstId);
    } else {
      // create default session and activate it
      await createNewSession({ name: 'Default Collection' });
    }
    renderSessions();
  }

  /* Wire session UI controls (Collections panel new/close already wired elsewhere) */
  const collectionsPanel = document.getElementById('collections');
  const collectionsClose = document.getElementById('collectionsClose');
  const newCollectionBtn = document.getElementById('newCollectionBtn');
  // NEW: Import button refs
  const importCollectionBtn = document.getElementById('importCollectionBtn');
  const importCollectionInput = document.getElementById('importCollectionInput');

  if (collectionsClose) {
    collectionsClose.addEventListener('click', () => {
      collectionsPanel.classList.remove('open');
      collectionsPanel.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('collections-open');
    });
  }
  if (newCollectionBtn) {
    newCollectionBtn.addEventListener('click', async () => {
      await createNewSession();
      collectionsPanel.classList.remove('open');
      collectionsPanel.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('collections-open');
      collectionTitleInput.focus();
    });
  }

  /* ensure global save on unload */
  window.addEventListener('beforeunload', () => { if (activeSessionId) saveGlobalsToSession(activeSessionId); });

  /* ensure sessions load once DOM is ready (mobile reliable) */
  document.addEventListener('DOMContentLoaded', () => {
    loadPersistedSessions().catch(err => console.error('loadPersistedSessions failed', err));
  });
</script>

<script>
// Save client, project title, and photographer to state on input change
// CHANGED: Apply debounce to all text inputs
const debouncedSave = debounce(() => {
  if (activeSessionId && sessions[activeSessionId]) {
    saveGlobalsToSession(activeSessionId);
  }
}, 500);

clientNameInput.addEventListener('input', () => {
  state.client = (clientNameInput.value || '').trim();
  debouncedSave();
});

projectTitleInput.addEventListener('input', () => {
  state.project = (projectTitleInput.value || '').trim();
  debouncedSave();
});

photographerNameInput.addEventListener('input', () => {
  state.photographer = (photographerNameInput.value || '').trim();
  debouncedSave();
});

collectionTitleInput.addEventListener('input', () => {
  const name = (collectionTitleInput.value || '').trim();
  if (activeSessionId && sessions[activeSessionId]) {
    sessions[activeSessionId].name = name || sessions[activeSessionId].name;
    debouncedSave();
    // update the sessions UI to reflect the new name (immediate feedback)
    renderSessions();
  }
});

// NEW: Import/Export handlers
async function resolveExportImageData(item) {
  let source = 'missing';
  let dataURL = null;

  try {
    if (item?.imageData) {
      dataURL = item.imageData;
      source = 'imageData';
    } else if (item?.dataURL) {
      dataURL = item.dataURL;
      source = 'dataURL';
    } else if (item?.blob instanceof Blob) {
      dataURL = await blobToDataURL(item.blob);
      source = 'blob';
    } else {
      const blob = await fetchBlobForItem(item);
      if (blob) {
        dataURL = await blobToDataURL(blob);
        source = 'idb-blob';
      }
    }
  } catch (e) {
    console.warn('Failed to resolve full image data for export', item?.id, e);
  }

  if (!dataURL && item?.thumbData) {
    dataURL = item.thumbData;
    source = 'thumb';
  }

  return { dataURL, source };
}

async function handleExportCollection(sessionId) {
  const session = sessions[sessionId];
  if (!session) {
    alert('Collection not found.');
    return;
  }
  // Ensure the latest data is in the session object before exporting
  if (sessionId === activeSessionId) {
    saveGlobalsToSession(sessionId);
  }
  
  // CHANGED: Deep clone and convert blobs to base64 for JSON export
  const sessionData = JSON.parse(JSON.stringify(sessions[sessionId])); // Clone structure
  
  // Re-attach items from source because JSON.stringify dropped blobs
  // We need to manually convert blobs to dataURLs
  // CHANGED: Handle ID-based items for export
  let itemsToExport = [];
  if (sessions[sessionId].items) {
    if (typeof sessions[sessionId].items[0] === 'number') {
       // Fetch items if they are IDs
       const promises = sessions[sessionId].items.map(id => idbGet(STORE, id));
       itemsToExport = (await Promise.all(promises)).filter(i=>i);
    } else {
       itemsToExport = sessions[sessionId].items;
    }
  }

  if (itemsToExport.length) {
    const missingFull = [];
    const thumbFallback = [];
    const formatList = (arr) => {
      const sample = arr.slice(0, 5).join(', ');
      const suffix = arr.length > 5 ? ` â€¦+${arr.length - 5} more` : '';
      return `${sample}${suffix}`;
    };

    sessionData.items = await Promise.all(itemsToExport.map(async (item, idx) => {
      await bakeRotationIfNeeded(item);
      const exportItem = { ...item };
      delete exportItem._preview;
      delete exportItem._objectURL;
      delete exportItem._selected;
      delete exportItem._selectedOrder;

      const label = exportItem.desc || exportItem.name || exportItem.filename || `Item ${idx + 1}`;
      const { dataURL, source } = await resolveExportImageData(item);

      if (dataURL) {
        exportItem.imageData = dataURL; // full image base64
        exportItem.dataURL = dataURL;   // backward compatible field
        exportItem.imageSource = source;
        if (source === 'thumb') thumbFallback.push(label);
      } else {
        missingFull.push(label);
      }

      delete exportItem.blob; // Remove blob from export
      return exportItem;
    }));
    // Drop any blob references retained during export
    itemsToExport.forEach(i => stripFullImage(i, true));

    if (missingFull.length || thumbFallback.length) {
      const parts = [];
      if (missingFull.length) parts.push(`${missingFull.length} missing full image data (${formatList(missingFull)})`);
      if (thumbFallback.length) parts.push(`${thumbFallback.length} exported with thumbnails (${formatList(thumbFallback)})`);
      console.warn('Export image issues', { missingFull, thumbFallback, total: itemsToExport.length });

      // Block export if we have no full images at all
      if (missingFull.length + thumbFallback.length === itemsToExport.length) {
        alert(`Export failed: no full images available (all items are missing or thumbnails only).\n${parts.join('\n')}\nPlease replace or re-import the photos, then export again.`);
        return;
      }

      alert(`Export warning:\n${parts.join('\n')}`);
    }
  }

  const jsonString = JSON.stringify(sessionData, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;

  const safeName = (sessionData.name || 'untitled').replace(/[^a-z0-9]/gi, '_').toLowerCase();
  a.download = `collection-export-${safeName}-${new Date().toISOString().slice(0,10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function handleImportCollection(event) {
  if (event.__importHandled) return;
  event.__importHandled = true;

  showImportDebug('Import change event received');
  const file = event.target.files?.[0];
  if (!file) {
    showImportDebug('No file selected, aborting import');
    return;
  }
  showImportDebug(`File selected: ${file.name} (${file.size} bytes)`);

  const reader = new FileReader();
  
  // NEW: Handle reader errors explicitly
  reader.onerror = () => {
    const msg = reader.error ? reader.error.message : 'Unknown read error';
    console.error('FileReader error:', reader.error);
    showImportDebug(`FileReader error: ${msg}`, 'error');
    alert(`Failed to read file: ${msg}`);
    event.target.value = ''; // Reset
  };

  reader.onload = async (e) => {
       try {
      const json = e.target.result;
      const data = JSON.parse(json);
      showImportDebug(`Parsed JSON, items=${Array.isArray(data?.items) ? data.items.length : 0}`);
      
      // Basic validation
      if (!data || typeof data !== 'object') throw new Error('Invalid JSON file');
      
      await importSession(data);
      
    } catch (err) {
      console.error('Import failed', err);
      showImportDebug(`Import failed: ${err.message || err}`, 'error');
      alert('Failed to import collection: ' + err.message);
    } finally {
      // Reset input so the same file can be selected again if needed
      if (event.target) event.target.value = '';
    }
  };
  reader.readAsText(file);
}

// NEW: Wire up import functionality (placed here to ensure handleImportCollection is defined)
function wireImportControls() {
  const ensureInput = () => {
    const inp = document.getElementById('importCollectionInput');
    if (!inp) {
      showImportDebug('Import input not found in DOM', 'error');
      return null;
    }
    if (!inp._wired) {
      inp.addEventListener('change', handleImportCollection);
      inp._wired = true;
    }
    return inp;
  };

  try {
    const inp = ensureInput();

    // Fallback: capture any change on the import input even if direct wiring failed
    if (!window._importCaptureListenerAttached) {
      document.addEventListener('change', (ev) => {
        const target = ev.target;
        if (target && target.id === 'importCollectionInput') {
          handleImportCollection(ev);
        }
      }, true);
      window._importCaptureListenerAttached = true;
    }

    // Re-run wiring when the label is clicked (helps if DOM was refreshed)
    const importLabel = document.querySelector('label[for="importCollectionInput"]');
    if (importLabel && !importLabel._wireHooked) {
      importLabel.addEventListener('click', ensureInput);
      importLabel._wireHooked = true;
    }
  } catch (err) {
    console.warn('Failed to wire import controls', err);
    showImportDebug(`Wire import controls failed: ${err.message || err}`, 'error');
  }
}
// Attach immediately and after DOM is ready (covers dynamic reloads)
wireImportControls();
document.addEventListener('DOMContentLoaded', wireImportControls);
</script>

<footer class="app-footer">
  <div class="wrap">
    <span id="appStatusFooter" class="footer-chip not-installed">
      <span class="dot" aria-hidden="true"></span>
      <span class="txt">v2.20 â€¢ Not installed</span>
    </span>
  </div>
</footer>

<script>
  // App version and install status footer updater
  const APP_VERSION = 'v2.20';
  let deferredPrompt = null; // Store the install prompt event
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  let iosHelpEl = null;
  let genericInstallHelpEl = null;

  function computeInstalled() {
    return (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches)
      || (navigator.standalone === true); // iOS Safari
  }

  function updateInstallStatus() {
    const el = document.getElementById('appStatusFooter');
    if (!el) return;
    const installed = computeInstalled();
    const canPrompt = deferredPrompt && !isIOS;

    // Reset classes
    el.classList.remove('installed', 'not-installed', 'install-ready');

    const txt = el.querySelector('.txt');
    if (!txt) return;

    if (installed) {
      el.classList.add('installed');
      txt.textContent = `${APP_VERSION} â€¢ Installed`;
      el.onclick = null;
      el.style.cursor = 'default';
      el.setAttribute('aria-disabled', 'true');
      el.removeAttribute('title');
    } else if (isIOS) {
      el.classList.add('install-ready');
      txt.textContent = `${APP_VERSION} â€¢ Install on iOS`;
      el.onclick = () => handleInstallClick();
      el.style.cursor = 'pointer';
      el.setAttribute('aria-disabled', 'false');
      el.setAttribute('title', 'Tap to see how to add to Home Screen');
    } else if (canPrompt) {
      // If not installed and we have a prompt, make it an install button
      el.classList.add('install-ready');
      txt.textContent = `${APP_VERSION} â€¢ Install App`;
      el.onclick = () => handleInstallClick();
      el.style.cursor = 'pointer';
      el.setAttribute('aria-disabled', 'false');
    } else {
      // Not installed, no prompt available
      el.classList.add('not-installed');
      txt.textContent = `${APP_VERSION} â€¢ Not installed`;
      el.onclick = () => handleInstallClick();
      el.style.cursor = 'pointer';
      el.setAttribute('aria-disabled', 'false');
    }
  }

  // Capture the install prompt
  window.addEventListener('beforeinstallprompt', (e) => {
    console.log('Install prompt captured'); // Check console if this appears
    e.preventDefault();
    deferredPrompt = e;
    updateInstallStatus();
  });

  function handleInstallClick(ev) {
    const el = document.getElementById('appStatusFooter');
    if (el) {
      el.setAttribute('role', 'button');
      el.tabIndex = 0;
    }
    if (computeInstalled()) return;
    ev?.preventDefault?.();
    if (isIOS) {
      showIOSInstallHelp();
    } else if (deferredPrompt) {
      deferredPrompt.prompt();
      deferredPrompt.userChoice.then(({ outcome }) => {
        if (outcome === 'accepted') {
          deferredPrompt = null;
        }
        updateInstallStatus();
      });
    } else {
      showGenericInstallHelp();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const el = document.getElementById('appStatusFooter');
    if (el) {
      el.setAttribute('role', 'button');
      el.tabIndex = 0;
      if (!el._wiredInstall) {
        el._wiredInstall = true;
        el.addEventListener('click', handleInstallClick);
        el.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter' || ev.key === ' ') handleInstallClick(ev);
        });
      }
    }
    updateInstallStatus();
  });

  window.addEventListener('appinstalled', () => {
    deferredPrompt = null;
    updateInstallStatus();
  });


  try {
    const dm = window.matchMedia && window.matchMedia('(display-mode: standalone)');
    dm && dm.addEventListener && dm.addEventListener('change', updateInstallStatus);
  } catch (_) {}

  function showIOSInstallHelp() {
    if (computeInstalled()) return;
    if (iosHelpEl) {
      iosHelpEl.remove();
      iosHelpEl = null;
      return;
    }
    iosHelpEl = document.createElement('div');
    iosHelpEl.style.position = 'fixed';
    iosHelpEl.style.bottom = '80px';
    iosHelpEl.style.right = '12px';
    iosHelpEl.style.maxWidth = '260px';
    iosHelpEl.style.background = 'rgba(15,23,42,0.95)';
    iosHelpEl.style.color = '#e5e7eb';
    iosHelpEl.style.padding = '12px 14px';
    iosHelpEl.style.borderRadius = '12px';
    iosHelpEl.style.boxShadow = '0 12px 28px rgba(0,0,0,0.35)';
    iosHelpEl.style.fontSize = '13px';
    iosHelpEl.style.zIndex = 4000;
    iosHelpEl.innerHTML = `
      <div style="font-weight:700; margin-bottom:6px;">Add to Home Screen</div>
      <div>On iPhone/iPad: tap <span aria-hidden="true">âŽˆ</span> Share, then â€œAdd to Home Screenâ€.</div>
      <div style="margin-top:8px; display:flex; gap:6px; align-items:center;">
        <span style="background:#1d4ed8;color:#fff;border-radius:8px;padding:2px 6px;font-weight:700;">Share</span>
        <span style="opacity:0.8;">â†’</span>
        <span style="background:#16a34a;color:#fff;border-radius:8px;padding:2px 6px;font-weight:700;">Add to Home Screen</span>
      </div>
      <button type="button" style="margin-top:10px;width:100%;padding:6px 8px;border:none;border-radius:8px;background:#334155;color:#fff;font-weight:600;cursor:pointer;">Close</button>
    `;
    iosHelpEl.querySelector('button')?.addEventListener('click', () => {
      iosHelpEl?.remove();
      iosHelpEl = null;
    });
    document.body.appendChild(iosHelpEl);
  }

  function showGenericInstallHelp() {
    if (computeInstalled()) return;
    if (genericInstallHelpEl) {
      genericInstallHelpEl.remove();
      genericInstallHelpEl = null;
      return;
    }
    genericInstallHelpEl = document.createElement('div');
    genericInstallHelpEl.style.position = 'fixed';
    genericInstallHelpEl.style.bottom = '80px';
    genericInstallHelpEl.style.right = '12px';
    genericInstallHelpEl.style.maxWidth = '260px';
    genericInstallHelpEl.style.background = 'rgba(15,23,42,0.95)';
    genericInstallHelpEl.style.color = '#e5e7eb';
    genericInstallHelpEl.style.padding = '12px 14px';
    genericInstallHelpEl.style.borderRadius = '12px';
    genericInstallHelpEl.style.boxShadow = '0 12px 28px rgba(0,0,0,0.35)';
    genericInstallHelpEl.style.fontSize = '13px';
    genericInstallHelpEl.style.zIndex = 4000;
    genericInstallHelpEl.innerHTML = `
      <div style="font-weight:700; margin-bottom:6px;">Install this app</div>
      <div>Use your browser menu (â‹® or â€¦) and choose â€œInstall appâ€ / â€œAdd to Home Screenâ€.</div>
      <div style="margin-top:8px; display:flex; gap:6px; align-items:center;">
        <span style="background:#1d4ed8;color:#fff;border-radius:8px;padding:2px 6px;font-weight:700;">â‹®</span>
        <span style="opacity:0.8;">â†’</span>
        <span style="background:#16a34a;color:#fff;border-radius:8px;padding:2px 6px;font-weight:700;">Install</span>
      </div>
      <button type="button" style="margin-top:10px;width:100%;padding:6px 8px;border:none;border-radius:8px;background:#334155;color:#fff;font-weight:600;cursor:pointer;">Close</button>
    `;
    genericInstallHelpEl.querySelector('button')?.addEventListener('click', () => {
      genericInstallHelpEl?.remove();
      genericInstallHelpEl = null;
    });
    document.body.appendChild(genericInstallHelpEl);
  }

  // Theme toggle logic
  const btnTheme = document.getElementById('btnTheme');

  function setTheme(isLight) {
    document.documentElement.setAttribute('data-theme', isLight ? 'light' : 'dark');
    if(btnTheme) btnTheme.textContent = isLight ? 'â˜€ï¸' : 'ðŸŒ™';
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
    const meta = document.querySelector('meta[name="theme-color"]');
    if(meta) meta.setAttribute('content', isLight ? '#f8fafc' : '#0f172a');
  }
  btnTheme?.addEventListener('click', () => {
    const isLight = document.documentElement.getAttribute('data-theme') === 'light';
    setTheme(!isLight);
  });
  // Init theme
  if (localStorage.getItem('theme') === 'light') setTheme(true);
</script>
</body>
</html>
