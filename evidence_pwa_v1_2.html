<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Site Evidence Capture (PWA)</title> <!-- CHANGED: removed v1.2 -->
<meta name="theme-color" content="#0f172a" />
<!-- Favicons from ./icons -->
<link rel="icon" type="image/png" sizes="32x32" href="./icons/favicon-32.png" />
<link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
<link rel="apple-touch-icon" sizes="180x180" href="./icons/apple-touch-icon.png" />
<link rel="manifest" href="./manifest.webmanifest" />
<!-- removed static manifest link so dynamic manifest below is used -->
<style>
  :root{
    --bg:#0f172a;--card:#111827;--muted:#1f2937;--text:#e5e7eb;--accent:#22c55e;--danger:#ef4444;--warn:#f59e0b;
    --border:#333; --header-bg:rgba(15,23,42,.95); --input-bg:#111827; --thumb-bg:#0b1220;
  }
  [data-theme="light"]{
    --bg:#f8fafc;--card:#ffffff;--muted:#f1f5f9;--text:#0f172a;--accent:#16a34a;--danger:#ef4444;--warn:#f59e0b;
    --border:#cbd5e1; --header-bg:rgba(255,255,255,.95); --input-bg:#ffffff; --thumb-bg:#e2e8f0;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{position:sticky;top:0;z-index:10;background:var(--header-bg);backdrop-filter:blur(6px);border-bottom:1px solid var(--border)}
  .wrap{max-width:1040px;margin:0 auto;padding:16px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;width:100%}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px}
  button,.btn{cursor:pointer;border:1px solid var(--border);background:var(--muted);color:var(--text);padding:10px 14px;border-radius:12px}
  button:disabled{opacity:.5;cursor:not-allowed}
  .primary{background:#16a34a;border-color:#15803d}
  .danger{background:#991b1b;border-color:#7f1d1d}
  .warn{background:#b45309;border-color:#92400e}
  select,input[type="number"],input[type="text"]{background:var(--input-bg);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
  .thumb{position:relative;border-radius:12px;overflow:hidden;border:1px solid var(--border);background:var(--thumb-bg)}
  .thumb canvas{width:100%;height:auto;display:block}
  .meta{padding:8px 10px;border-top:1px solid var(--border);font-size:14px}
  .meta small{opacity:.7}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#0b4; font-size:12px; margin-left:6px}
  .footer{opacity:.8;font-size:13px}
  dialog{border:none;border-radius:16px;padding:0;max-width:520px;width:90%;background:var(--thumb-bg);color:var(--text)}
  dialog header{padding:16px;border-bottom:1px solid var(--border)}
  dialog .content{padding:16px}
  dialog .actions{display:flex;gap:10px;justify-content:flex-end;padding:16px;border-top:1px solid var(--border)}
  .count{font-variant-numeric: tabular-nums}
  .hint{opacity:.7;font-size:12px}

  /* Slide-out panel for sessions */
  .section {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    transition: transform 0.28s ease; /* Smooth slide-in/out */
    z-index: 1000;
    box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
    border-right: 1px solid var(--border);
    overflow: auto;
    background: var(--card);
    padding: 16px;
    transform: translateX(-110%); /* Hidden by default */
  }
  .section.open {
    transform: translateX(0); /* Slide in when open */
  }
  .tab-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .tab {
    flex: 1;
    padding: 10px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--card);
    color: var(--text);
    cursor: pointer;
    transition: background .2s;
  }
  .tab:hover {
    background: #1f2937;
  }
  .tab.active {
    background: #15803d;
    color: #fff;
  }
  .close {
    background: none;
    border: none;
    color: #ef4444;
    font-size: 18px;
    cursor: pointer;
  }

  /* Session Manager styles */
  .sessions-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    background: var(--card);
    color: var(--text);
    border-right: 1px solid var(--border);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
    padding: 16px;
    overflow-y: auto;
    z-index: 1000;
    transform: translateX(-110%); /* Hidden by default */
    transition: transform 0.28s ease;
  }
  .sessions-panel.open {
    transform: translateX(0); /* Visible when open */
  }
  body.sessions-open #sessionsToggle {
    opacity: 1; /* Ensure the button is fully visible */
    pointer-events: auto; /* Allow interaction */
  }
  .sessions-header-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .sessions-title {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
  }
  .flex-spacer {
    flex: 1;
  }
  .sessions-hint {
    margin-top: 6px;
    font-size: 0.9rem;
    color: var(--muted, #8b93b8);
  }
  .sessions-new-btn-row {
    margin-top: 8px;
  }
  .sessions-list {
    list-style: none;
    padding: 0;
    margin-top: 10px;
  }
  .session-tab {
    display: flex; /* CHANGED from inline-flex */
    align-items: center;
    justify-content: space-between;
    width: 100%;
    gap: 8px;
    padding: 8px 10px;
    margin-bottom: 8px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: var(--card);
    color: var(--text);
    font-weight: 600;
    text-align: left;
    cursor: pointer;
  }
  .session-tab.active {
    outline: 3px solid var(--focus-ring, #7aa9f6);
    outline-offset: 0;
  }
  .session-close-btn {
    background: transparent;
    border: 0;
    color: var(--muted, #8b93b8);
    cursor: pointer;
    padding: 0 4px;
    font-size: 0.9rem;
    line-height: 1;
    margin-left: auto; /* Push to the right */
  }
  /* NEW: styles for collection action buttons (export) */
  .collection-actions {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .collection-actions .btn {
    padding: 4px;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 8px;
  }
  .collection-actions .btn:hover {
    background: var(--muted);
    border-color: #333;
  }
  .collection-actions .btn svg {
    width: 16px;
    height: 16px;
    stroke: #a7acc4;
  }
  .collection-actions .btn:hover svg {
    stroke: #e5e7eb;
  }
  .session-summary-chip {
    display: inline-block;
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--muted);
    border: 1px solid var(--border);
    background: rgba(127, 146, 190, 0.08);
    border-radius: 999px;
    padding: 2px 8px;
    max-width: 40vw;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Update styles for the renamed Collections panel */
  .collections-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    background: var(--card);
    color: var(--text);
    border-right: 1px solid var(--border);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
    padding: 16px;
    overflow-y: auto;
    z-index: 1000;
    transform: translateX(-110%); /* Hidden by default */
    transition: transform 0.28s ease;
  }
  .collections-panel.open {
    transform: translateX(0); /* Slide in when open */
  }
  /* body.collections-open #collectionsToggle {
    opacity: 1;
    pointer-events: auto;
  } */

  /* Collection Parameters slide-out (left) */
  .params-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    background: var(--card);
    color: var(--text);
    border-right: 1px solid var(--border);
    box-shadow: 8px 0 24px rgba(0,0,0,0.6);
    padding: 16px;
    transform: translateX(-110%);
    transition: transform 0.28s ease;
    z-index: 1200;
    overflow-y: auto;
  }
  .params-panel.open { transform: translateX(0); }
  .params-panel h3 { margin:0 0 8px; font-size:1rem; font-weight:600; }
  .params-panel .field { display:flex; flex-direction:column; gap:6px; margin-bottom:12px; }

  /* location button state colours */
  .btn.loc-on { background:#16a34a !important; border-color:#15803d !important; color:#fff; }
  .btn.loc-off { background:#991b1b !important; border-color:#7f1d1d !important; color:#fff; }

  /* make svg inside control inherit button foreground */
  .btn svg { vertical-align: middle; fill: none; stroke: currentColor; }

  /* icon-only button style (tight square for header icons) */
  .btn.icon-btn { width:40px; height:40px; padding:6px; display:inline-flex; align-items:center; justify-content:center; border-radius:10px; }

  /* export button: inline icon + label, slightly tighter */
  .btn.export { display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px; font-weight:600; }
  .btn.export svg { width:18px; height:18px; }

  /* group two buttons so they look related (export + settings) */
  .btn.group-left { border-top-right-radius:0; border-bottom-right-radius:0; margin-left:8px; }
  .btn.group-right { border-top-left-radius:0; border-bottom-left-radius:0; margin-left:0; border-left:1px solid rgba(0,0,0,0.25); }
  /* NEW: middle-group style for 3-button groups */
  .btn.group-mid { border-radius:0; margin-left:0; border-left:1px solid rgba(0,0,0,0.25); }

  /* keep grouped header buttons together on small screens */
  .btn-group {
    display: inline-flex;
    flex-wrap: nowrap;
    gap: 0;
    align-items: center;
    white-space: nowrap;
  }
  .btn-group .btn {
    flex: 0 0 auto; /* do not grow or shrink */
  }
  /* Header logo sizing (prevents huge rendering on mobile) */
  .brand-logo {
    height: 64px; /* CHANGED: was 32px */
    width: auto;
    margin-right: 12px;
    display: inline-block;
  }

  /* Album icon button in Collections list (restore visible strokes and active colour) */
  .album-btn {
    background: transparent;
    border: 0;
    padding: 0 4px 0 0;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
  }
  .album-btn svg {
    width: 20px;
    height: 20px;
    stroke: #a7acc4; /* light grey stroke on dark panel */
    fill: none;
    transition: stroke .2s, fill .2s;
  }
  .album-btn:hover svg { stroke: #e5e7eb; }
  .album-btn.active svg {
    stroke: var(--accent); /* #22c55e */
    fill: rgba(34,197,94,0.18);
  }

  /* header collection chip */
  .collection-chip {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 4px 10px;
    border-radius: 999px;
    background: rgba(34,197,94,0.12);
    border: 1px solid rgba(34,197,94,0.33);
    color: #e5e7eb;
    font-weight: 700;
    cursor: pointer;
    user-select: none;
  }
  .collection-chip:hover {
    background: rgba(34,197,94,0.18);
    border-color: rgba(34,197,94,0.55);
  }
  .collection-chip svg {
    width: 16px;
    height: 16px;
    stroke: #22c55e;
    fill: rgba(34,197,94,0.15);
  }

  .app-footer {
    position: sticky;
    bottom: 0;
    background: var(--header-bg);
    border-top: 1px solid var(--border);
    z-index: 10;
    width: 100%;
  }
  .app-footer .wrap {
    padding: 10px 16px;
    font-size: 12px;
    opacity: .9;
    display: flex;
    justify-content: flex-start;
    align-items: center;
  }
  /* Footer status chip */
  .footer-chip {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 4px 10px;
    border-radius: 999px;
    background: rgba(148,163,184,0.12); /* slate-300-ish */
    border: 1px solid rgba(148,163,184,0.35);
    color: #e5e7eb;
    font-weight: 600;
    white-space: nowrap;
  }
  .footer-chip .dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: #94a3b8; /* default grey */
    box-shadow: 0 0 0 2px rgba(148,163,184,0.25);
  }
  .footer-chip.installed {
    background: rgba(34,197,94,0.12);
    border-color: rgba(34,197,94,0.45);
    color: #d1fae5;
  }
  .footer-chip.installed .dot {
    background: #22c55e;
    box-shadow: 0 0 0 3px rgba(34,197,94,0.2);
  }
  .footer-chip.not-installed {
    background: rgba(148,163,184,0.12);
    border-color: rgba(148,163,184,0.35);
    color: #e5e7eb;
  }
  /* NEW: Distinct style for when install is available */
  .footer-chip.install-ready {
    background: rgba(37, 99, 235, 0.15); /* blue-600 */
    border-color: rgba(37, 99, 235, 0.4);
    color: #bfdbfe;
    cursor: pointer;
    animation: pulse-border 2s infinite;
  }
  @keyframes pulse-border {
    0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.4); }
    70% { box-shadow: 0 0 0 6px rgba(37, 99, 235, 0); }
    100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
  }

  /* Base action button (icon + label) */
  .btn.action {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 12px;
    font-weight: 600;
  }
  .btn.action svg { width: 18px; height: 18px; }

  /* Make capture group a full-width toolbar with tall, stacked buttons */
  /* REMOVED old #captureGroup styles */

  /* Small warning chip shown in header when location is OFF */
  .loc-warning {
    display: none;
    margin-left: 8px;
    padding: 2px 8px;
    border-radius: 999px;
    background: rgba(239,68,68,0.15); /* red-500 bg */
    border: 1px solid rgba(239,68,68,0.35);
    color: #fecaca; /* red-200 text */
    font-size: 12px;
    font-weight: 700;
    white-space: nowrap;
  }

  /* NEW: Action button row styles */
  .button-row {
    display: flex;
    gap: 0.75rem;
    width: 100%;
  }
  .button-row .btn {
    flex: 1 1 0%;
    min-width: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.85rem 1rem;
    border-radius: 999px;
    border: none;
    font-weight: 600;
    font-size: 0.95rem;
    color: #f9fafb;
    cursor: pointer;
    transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.15s;
  }
  .button-row .btn-photo {
    flex: 2; /* Two thirds of the space */
  }
  .button-row .btn-params {
    flex: 1; /* One third of the space */
  }
  .button-row .btn .icon svg {
    width: 18px;
    height: 18px;
  }
  .button-row .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  }
  .button-row .btn:active {
    transform: translateY(1px);
    box-shadow: none;
    opacity: 0.9;
  }
  /* NEW: Header rows styling */
  .header-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 8px; /* Space between rows */
  }
  .header-row-1 {
    justify-content: space-between;
    overflow: hidden;
    max-height: 80px;
    margin-bottom: 8px;
    transition: opacity 0.3s ease, transform 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
  }
  .header-row-1.is-hidden {
    opacity: 0;
    transform: translateY(-16px);
    max-height: 0;
    margin-bottom: 0;
    pointer-events: none;
  }
  .header-row-2 .left-group {
    display: flex;
    align-items: center;
    gap: 8px; /* Space between button and chip */
  }
  .header-row-2 .right-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* NEW: floating actions bottom-right */
  .floating-actions {
    position: fixed;
    right: 24px;
    bottom: 24px;
    display: inline-flex;
    flex-direction: row;
    gap: 0;
    z-index: 60;
  }
  .floating-actions .btn-group {
    display: inline-flex;
    flex-wrap: nowrap;
  }
  .floating-actions .btn {
    box-shadow: 0 12px 24px rgba(0,0,0,0.35);
    border-radius: 999px;
    padding: 10px 16px;
  }
  /* override header spacing so the group joins tightly */
  .floating-actions .btn.group-left { margin-left: 0; }
  .floating-actions .btn svg { pointer-events: none; }
  @media (max-width: 640px) {
    .floating-actions { right: 16px; bottom: 16px; }
  }

  /* Added: delete button styling */
  .thumb .delete-btn {
    position:absolute;
    top:6px;
    right:6px;
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .delete-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .delete-btn:focus {
    outline:2px solid #f87171;
    outline-offset:2px;
  }
  .thumb .delete-btn svg {
    width:16px;
    height:16px;
    stroke:#f87171;
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }

  /* NEW: replace button styling (top-left) */
  .thumb .replace-btn {
    position:absolute;
    top:6px;
    left:6px;
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .replace-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .replace-btn:focus {
    outline:2px solid #22c55e;
    outline-offset:2px;
  }
  .thumb .replace-btn svg {
    width:16px;
    height:16px;
    stroke:#22c55e; /* accent */
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }

  /* NEW: rotate button styling (top-left, next to replace) */
  .thumb .rotate-btn {
    position:absolute;
    top:6px;
    left:42px; /* 6px + 30px width + 6px gap */
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .rotate-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .rotate-btn:focus {
    outline:2px solid #3b82f6;
    outline-offset:2px;
  }
  .thumb .rotate-btn svg {
    width:16px;
    height:16px;
    stroke:#3b82f6;
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }

  /* Empty gallery placeholder */
  .gallery-placeholder {
    grid-column: 1 / -1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 28px 16px;
    border: 1px dashed #334155;
    border-radius: 12px;
    color: #94a3b8;
    background: rgba(2, 6, 23, 0.35);
    text-align: center;
  }
  .gallery-placeholder svg {
    width: 36px;
    height: 36px;
    stroke: #64748b;
    fill: none;
  }
  .gallery-placeholder small { opacity: 0.8; }

  /* MODE STYLES: green (camera) / blue (gallery) */
  #btnSnap { position:relative; overflow:hidden; }
  #btnSnap.mode-camera {
    background:#16a34a !important;
    border-color:#15803d !important;
  }
  #btnSnap.mode-camera:hover { background:#18b152 !important; }
  #btnSnap.mode-gallery {
    background:#1d4ed8 !important;
    border-color:#1e40af !important;
  }
  #btnSnap.mode-gallery:hover { background:#235ae8 !important; }

  /* Long-press visual progress (leftâ†’right fade) */
  #btnSnap .press-progress {
    position:absolute;
    top:0; left:0;
    height:100%;
    width:0;
    background:linear-gradient(90deg,rgba(255,255,255,0.15),rgba(255,255,255,0.35));
    pointer-events:none;
  }
  #btnSnap.progressing .press-progress {
    animation: pressFill 1s linear forwards;
  }
  @keyframes pressFill {
    from { width:0; }
    to { width:100%; }
  }

  /* When mode changes flash subtle overlay */
  #btnSnap.mode-switch-flash::after {
    content:'';
    position:absolute; inset:0;
    background:radial-gradient(circle at 30% 50%, rgba(255,255,255,0.35), rgba(255,255,255,0));
    animation: flashFade .5s ease;
    pointer-events:none;
  }
  @keyframes flashFade { from { opacity:1; } to { opacity:0; } }

  .mode-hint { font-style: italic; }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <!-- Row 1: Logo left, title right -->
    <div class="header-row header-row-1">
      <div style="display:flex;align-items:center;font-weight:700;font-size:15px;letter-spacing:.2px">
        <img src="./brownfield_logo.png" alt="Brownfield Solutions" loading="lazy" class="brand-logo" />
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <button id="btnTheme" class="btn icon-btn" title="Toggle theme" aria-label="Toggle theme">ðŸŒ™</button>
        <img src="./icons/icon-512.png" alt="Site Evidence Capture" loading="lazy" style="height: 64px; width: auto;" />
      </div>
    </div>
    
    <!-- Row 2: Collection button + count chip left, location right -->
    <div class="header-row header-row-2">
      <div class="left-group">
        <div id="tabsSummary" style="font-weight: 500; opacity: 0.8;"></div>
        <span class="count-chip" id="count">0 items</span>
      </div>
      <div class="right-group">
        <span id="locWarning" class="loc-warning" role="status" aria-live="polite">Location OFF</span>
        <button id="btnEnableLoc" class="btn loc-off icon-btn" title="Enable location" aria-pressed="false" style="margin-right:0">
          <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 2C8.686 2 6 4.686 6 8c0 5.25 6 12 6 12s6-6.75 6-12c0-3.314-2.686-6-6-6z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
            <circle cx="12" cy="8" r="2.2" stroke="currentColor" stroke-width="1.2" fill="none"/>
          </svg>
        </button>
      </div>
    </div>
  </div>
</header>

<main class="wrap" style="padding-top:14px;padding-bottom:72px">
  <section class="card">
    <div class="row">
      <input id="fileInput" type="file" accept="image/*" capture="environment" style="display:none" />
      <!-- REPLACED: button group with new structure and styles -->
      <div class="button-row" id="captureGroup">
        <button id="btnSnap" class="btn btn-photo" title="Take or select photo" aria-label="Take or select photo" data-mode="camera">
          <span class="press-progress" aria-hidden="true"></span>
          <span class="icon">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M9 4l1.5-2h3L15 4h3a2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h3z"/>
              <circle cx="12" cy="12" r="3.25"/>
            </svg>
          </span>
          <span>Photo</span>
          <span class="mode-hint" id="captureModeHint">Camera</span>
        </button>
      
        <!-- Parameters -->
        <button id="paramsToggle" class="btn btn-params" title="Open collection parameters" aria-label="Open collection parameters">
          <span class="icon">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M9 3h6a2 2 0 012 2h1a2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V7a2 2 0 012-2h1a2 2 0 012-2z"/>
              <path d="M10 3h4v2h-4z"/>
              <path d="M9 10h6"/>
              <path d="M9 13h6"/>
              <path d="M9 16h4"/>
            </svg>
          </span>
          <span>Project Details</span>
        </button>
      </div>

      <!-- location control moved to header; status text removed (indicator is the icon colour) -->

      <!-- layout/orientation moved into Settings panel -->
      <input id="collectionTitle" type="hidden" value="Site Evidence Photos" />
    </div>

    <!-- New: Client, Project Title, and Photographer fields (moved to slide-out panel â€” keep hidden fields for compatibility) -->
    <div style="display:none;">
      <input id="clientName" type="hidden" value="" />
      <input id="projectTitle" type="hidden" value="" />
      <input id="photographerName" type="hidden" value="" />
    </div>

    <!-- Slide-out settings panel -->
    <div id="settingsPanel" style="position:fixed;right:-320px;top:72px;width:320px;max-width:90vw;height:calc(100vh - 96px);background:var(--card);border-left:1px solid var(--border);padding:16px;border-radius:8px 0 0 8px;box-shadow:-8px 0 24px rgba(0,0,0,.6);transition:right .25s ease;z-index:40;">
      <!-- CHANGED: added header row with close button -->
      <div class="settings-header" style="display:flex;align-items:center;justify-content:space-between;margin:0 0 12px">
        <h3 style="margin:0">Settings</h3>
        <button id="btnCloseSettings" class="btn icon-btn" aria-label="Close settings" title="Close settings" style="width:36px;height:36px;padding:4px;display:flex;align-items:center;justify-content:center">&times;</button>
      </div>
      <div style="display:flex;flex-direction:column;gap:10px">
        
        <label>Layout:
          <select id="layout" style="width:100%">
            <option value="2">2 per A4 page</option>
            <option value="4" selected>4 per A4 page</option>
          </select>
        </label>
        <label>Orientation:
          <select id="orientation" style="width:100%">
            <option value="portrait">Portrait (A4)</option>
            <option value="landscape" selected>Landscape (A4)</option>
          </select>
        </label>
        <!-- NEW: Rotation toggle -->
        <label style="display:flex;align-items:center;gap:6px;margin-top:8px;font-size:14px">
          <!-- CHANGED: Default to unchecked so portrait photos stay portrait by default -->
          <input id="cfgRotate" type="checkbox" /> Force landscape on bulk upload
        </label>
        <small class="hint" style="display:block;margin-bottom:10px;line-height:1.3">If checked, portrait photos added via Bulk Upload are rotated.</small>
        
        <!-- NEW: PPTX attribute toggles -->
        <div style="display:flex;flex-direction:column;gap:6px;margin-top:4px;padding:8px;border:1px solid var(--border);border-radius:10px;">
          <strong style="font-size:13px">PPTX Caption Attributes</strong>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrTimestamp" type="checkbox" checked /> Timestamp
          </label>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrPosition" type="checkbox" checked /> Position (BNG / Lat,Lon)
          </label>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrAccuracy" type="checkbox" checked /> Accuracy (Â± m)
          </label>
          <!-- NEW: Photographer toggle + initials input -->
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrPhotographer" type="checkbox" checked /> Photographer initials
          </label>
          <input id="photographerInitials" type="text" placeholder="DG" style="width:100%" />
        </div>
        <div style="margin-top:6px"><small class="hint">These affect exports (A4 sizing)</small></div>
      </div>
    </div>

    <!-- REMOVED: Footer text paragraph as requested -->
  </section>

  <section id="gallery" class="grid" style="margin-top:14px"></section>

  <!-- NEW: Bulk Upload Area -->
  <div style="margin-top: 32px; margin-bottom: 20px; text-align: center;">
    <input id="bulkInput" type="file" accept="image/*" multiple style="display:none" />
    <button id="btnBulkUpload" class="btn" style="width: 100%; padding: 16px; border: 2px dashed #334155; background: rgba(15, 23, 42, 0.6); color: #94a3b8;">
      <div style="font-weight:600; font-size:1.1em; margin-bottom:4px;">+ Bulk Upload Photos</div>
      <div style="font-size:0.85em; opacity:0.8;">Descriptions and GPS metadata will be skipped</div>
    </button>
  </div>
</main>

<!-- NEW: floating primary actions -->
<div class="floating-actions" role="region" aria-label="Primary actions">
  <span class="btn-group">
    <button id="btnExportPPTX" class="btn danger export group-left" title="Export PPTX" aria-label="Export PPTX">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" stroke="currentColor" stroke-width="1.2" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="4" width="18" height="14" rx="2" />
        <path d="M8 9h8M8 13h5" />
        <path d="M12 18v3" />
      </svg>
      <span>PPT Export</span>
    </button>
    <button id="btnSettings" class="btn group-right" title="Settings" aria-label="Settings">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7z" stroke="#e5e7eb" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09c.73 0 1.38-.39 1.51-1a1.65 1.65 0 0 0-.33-1.82l-.06-.06A2 2 0 0 1 6.4 3.7l.06.06c.47.47 1.1.7 1.75.62.62-.08 1.18-.48 1.4-1.06.2-.54.7-.94 1.28-1.06L12 2.5c.36 0 .72.1 1.03.28.58.28 1.03.78 1.22 1.4.22.68.78 1.09 1.4 1.17.65.08 1.28-.15 1.75-.62l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06c-.47.47-.7 1.1-.62 1.75.08.62.48 1.18 1.06 1.4.68.22 1.09.78 1.17 1.4V11a2 2 0 0 1 0 4h-.09c-.73 0-1.38.39-1.51 1z" stroke="#e5e7eb" stroke-width="0.9" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
  </span>
</div>

<!-- Description dialog -->
<dialog id="descDialog">
  <header><strong>Add description</strong></header>
  <div class="content">
    <p style="margin:0 0 8px">Describe the evidence in one or two lines (who/what/where/why).</p>
    <textarea id="descText" rows="4" style="width:100%;resize:vertical;background:var(--input-bg);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px" placeholder="e.g., TP03: Sub-base compaction adjacent to gridline Câ€“D. Roller: Bomag BW120."></textarea>
    <div class="row" style="margin-top:8px">
      <label>Date/time:
        <!-- include seconds support for datetime-local -->
        <input id="descWhen" type="datetime-local" step="1" />
      </label>
      <!-- REMOVED: Technician field as requested -->
    </div>
    <div style="margin-top:8px">
      <label style="display:block;font-size:13px;margin-bottom:6px">Position (device â†’ BNG) <span class="hint" style="font-size:12px">(*) approximate</span></label>
      <input id="descPosition" type="text" readonly style="width:100%;background:var(--input-bg);color:var(--text); border:1px solid var(--border);border-radius:8px;padding:8px" />
    </div>
  </div>
  <div class="actions">
    <button id="descCancel">Cancel</button>
    <button id="descOK" class="primary">Save</button>
  </div>
</dialog>

<!-- Rename the slide-out panel for managing collections -->
<div id="collections" class="collections-panel" aria-hidden="true">
  <div class="collections-header-row" style="display:flex;align-items:center;gap:8px;">
    <button id="collectionsClose" class="btn" type="button">Close</button>
    <h2 class="collections-title" style="margin:0;font-size:1rem;font-weight:600;">Collections</h2>
    <div class="flex-spacer" style="flex:1;"></div>
  </div>
  <p class="collections-hint">Manage active collections. Click one to switch to it.</p>
  <div class="collections-new-btn-row" style="margin-top:8px; display:flex; gap:8px;">
    <button id="newCollectionBtn" class="btn" type="button">ï¼‹ New Collection</button>
    <!-- NEW: Import button -->
    <button id="importCollectionBtn" class="btn" type="button">Import Collection</button>
    <input type="file" id="importCollectionInput" accept=".json,application/json" style="display:none" />
  </div>
  <ul id="collectionsList" class="collections-list" style="list-style:none;padding:0;margin-top:10px;"></ul>
</div>

<!-- Add the params panel markup (place near other slide-out panels) -->
<div id="paramsPanel" class="params-panel" aria-hidden="true">
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
    <button id="paramsClose" class="btn" type="button">Close</button>
    <h3 style="margin:0">Project Details</h3>
  </div>

  <div style="margin-top:8px">
    <div class="field">
      <label style="font-size:12px">Job Name</label>
      <input id="params_collectionTitle" type="text" placeholder="Job Name" />
    </div>
    <div class="field">
      <!-- CHANGED label from Job No. to Client -->
      <label style="font-size:12px">Client</label>
      <input id="params_clientName" type="text" placeholder="Client" />
    </div>
    <div class="field">
      <label style="font-size:12px">Job No.</label>
      <input id="params_projectTitle" type="text" placeholder="Job No." />
    </div>
    <div class="field">
      <label style="font-size:12px">Photoboard Title</label>
      <input id="params_photographerName" type="text" placeholder="Photoboard Title" />
    </div>
    <div style="margin-top:12px;text-align:right">
      <button id="paramsSave" class="btn primary">Save</button>
    </div>

    <!-- NEW: Moved Force Landscape button here -->
    <hr style="border:0;border-top:1px solid var(--border);margin:20px 0 12px" />
    <button id="btnForceLandscape" class="btn warn" style="width:100%;font-size:13px">
      Force all to Landscape
    </button>
    <small class="hint" style="display:block;margin-top:6px;text-align:center;opacity:0.7">Rotates all portrait images in this collection.</small>
  </div>
</div>

<!-- Libraries (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js" crossorigin="anonymous"></script>
<!-- include the helper as an ES module so addBottomRightTable is available -->
<script type="module" src="./pptx_table.js"></script>

<script>
  // Register the static service worker so scope works correctly on GitHub Pages
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js', { scope: './' }).catch(()=>{});
    });
  }
</script>

<script>
/* ---------------- Minimal IndexedDB ---------------- */
const DB_NAME='evidenceDB', STORE='items', SESSIONS_STORE='sessions', FS_HANDLES_STORE = 'fsHandles'; // NEW STORE
function idbOpen(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 3); // DB version 3
    req.onupgradeneeded = (event) => {
      const db = event.target.result;
      // create legacy items store if missing
      if (!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
      }
      // create sessions store if missing (autoIncrement per spec)
      if (!db.objectStoreNames.contains(SESSIONS_STORE)) {
        db.createObjectStore(SESSIONS_STORE, { keyPath: 'id', autoIncrement: true });
      }
      // NEW: create fsHandles store
      if (!db.objectStoreNames.contains(FS_HANDLES_STORE)) {
        db.createObjectStore(FS_HANDLES_STORE);
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
    req.onblocked = () => console.warn('IndexedDB open blocked - close other tabs using this site to upgrade the database.');
  });
}
async function idbAdd(obj){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).add(obj).onsuccess=e=>res(e.target.result); tx.onerror=()=>rej(tx.error); }); }
async function idbAll(){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const req=tx.objectStore(STORE).getAll(); req.onsuccess=()=>res(req.result||[]); req.onerror=()=>rej(req.error); }); }

// New helpers for sessions store
async function idbAddSession(session){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readwrite'); tx.objectStore(SESSIONS_STORE).put(session).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error); }); }
async function idbGetSession(id){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readonly'); const req=tx.objectStore(SESSIONS_STORE).get(id); req.onsuccess=()=>res(req.result||null); req.onerror=()=>rej(req.error); }); }
async function idbAllSessions(){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readonly'); const req=tx.objectStore(SESSIONS_STORE).getAll(); req.onsuccess=()=>res(req.result||[]); req.onerror=()=>rej(req.error); }); }
async function idbDeleteSession(id){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readwrite'); tx.objectStore(SESSIONS_STORE).delete(id).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error); }); }

// NEW: Helpers for File System Access handles
async function saveDirectoryHandle(handle) {
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction(FS_HANDLES_STORE, 'readwrite');
    tx.objectStore(FS_HANDLES_STORE).put(handle, 'directory').onsuccess = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function getDirectoryHandle() {
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction(FS_HANDLES_STORE, 'readonly');
    const req = tx.objectStore(FS_HANDLES_STORE).get('directory');
    req.onsuccess = () => res(req.result || null);
    req.onerror = () => rej(req.error);
  });
}

/* ---------------- App state + UI refs ---------------- */
const state = { items: [], client: '', project: '', photographer: '', photographerInitials: '' };
const fileInput = document.getElementById('fileInput');
const btnSnap = document.getElementById('btnSnap');
const captureModeLabel = document.getElementById('captureModeLabel');
const captureModeHint = document.getElementById('captureModeHint');
const gallery = document.getElementById('gallery');
const collectionTitleInput = document.getElementById('collectionTitle');
const clientNameInput = document.getElementById('clientName'); // New
const projectTitleInput = document.getElementById('projectTitle'); // New
const photographerNameInput = document.getElementById('photographerName'); // New
const descDialog = document.getElementById('descDialog');
const descText = document.getElementById('descText');
const descWhen = document.getElementById('descWhen');
const descPosition = document.getElementById('descPosition');
const descOK = document.getElementById('descOK');
const descCancel = document.getElementById('descCancel');
const btnExportPPTX = document.getElementById('btnExportPPTX');
const layoutSel = document.getElementById('layout');
const orientationSel = document.getElementById('orientation');
const cfgRotate = document.getElementById('cfgRotate'); // NEW
const btnForceLandscape = document.getElementById('btnForceLandscape'); // NEW

// NEW: Persist rotation setting
if (cfgRotate) {
  const saved = localStorage.getItem('cfgRotate');
  if (saved !== null) cfgRotate.checked = (saved === 'true');
  cfgRotate.addEventListener('change', () => localStorage.setItem('cfgRotate', cfgRotate.checked));
}

// NEW: Force all to landscape handler
if(btnForceLandscape){
  btnForceLandscape.addEventListener('click', async () => {
    if(!confirm("Rotate all portrait images in this collection to landscape?")) return;
    let count = 0;
    for(const item of state.items){
      if(item.h > item.w){
        const img = new Image();
        await new Promise(r=>{img.onload=r; img.src=item.dataURL;});
        const canvas = document.createElement('canvas');
        canvas.width = item.h;
        canvas.height = item.w;
        const ctx = canvas.getContext('2d');
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.rotate(Math.PI/2);
        ctx.drawImage(img, -item.w/2, -item.h/2);
        
        item.dataURL = toDataURL(canvas, 0.9);
        item.w = canvas.width;
        item.h = canvas.height;
        item._preview = canvas;
        count++;
      }
    }
    if(count>0){
      saveGlobalsToSession(activeSessionId);
      renderGallery();
      alert(`Rotated ${count} images.`);
    } else {
      alert("No portrait images found.");
    }
  });
}

/* REMOVED: maxwInput and marginsInput */
/* NEW: PPTX attribute checkboxes */
const attrTimestampChk = document.getElementById('attrTimestamp');
const attrPositionChk  = document.getElementById('attrPosition');
const attrAccuracyChk  = document.getElementById('attrAccuracy');
const attrPhotographerChk = document.getElementById('attrPhotographer');          // NEW
const photographerInitialsInput = document.getElementById('photographerInitials'); // NEW
const countEl = document.getElementById('count');

const btnEnableLoc = document.getElementById('btnEnableLoc');
const btnSettings = document.getElementById('btnSettings');
const settingsPanel = document.getElementById('settingsPanel');
const btnCloseSettings = document.getElementById('btnCloseSettings');
// NEW: folder picker refs
const btnChooseFolder = document.getElementById('btnChooseFolder');
const folderStatus = document.getElementById('folderStatus');
const btnClear = document.getElementById('btnClear'); // NEW: guard missing clear button
// NEW: Bulk upload refs
const btnBulkUpload = document.getElementById('btnBulkUpload');
const bulkInput = document.getElementById('bulkInput');

// NEW: params panel refs
const paramsToggle = document.getElementById('paramsToggle');
const paramsPanel = document.getElementById('paramsPanel');
const paramsClose = document.getElementById('paramsClose');
const paramsSave = document.getElementById('paramsSave');
const params_collectionTitle = document.getElementById('params_collectionTitle');
const params_clientName = document.getElementById('params_clientName');
const params_projectTitle = document.getElementById('params_projectTitle');
const params_photographerName = document.getElementById('params_photographerName');

// location state
let pendingCanvas=null;
let pendingGPS=null;
let editingItem=null; // NEW: Track item being edited
let locationEnabled = false;      // default to OFF so warning chip shows immediately
let lastKnownPos = null;
let watchId = null;
let dirHandle = null; // NEW: hold the directory handle in memory

/* --- Simple long-press controller (1s) --- */
const MODE = {
  camera:  { capture: true,  label: 'Mode A', hint: 'Camera'  },
  gallery: { capture: false, label: 'Mode B', hint: 'Gallery' }
};
let captureMode = 'camera';
const LONG_MS = 1000;
let lpTimer = null;
let isLongPress = false;  // Flag to track if long press occurred

function setCaptureMode(key){
  captureMode = key;
  btnSnap.dataset.mode = key;
  captureModeHint && (captureModeHint.textContent = MODE[key].hint);
  btnSnap.classList.remove('mode-camera','mode-gallery');
  btnSnap.classList.add('mode-'+key);
  // brief flash effect on mode switch
  btnSnap.classList.add('mode-switch-flash');
  setTimeout(()=>btnSnap.classList.remove('mode-switch-flash'),500);
  if (MODE[key].capture) fileInput.setAttribute('capture','environment');
  else fileInput.removeAttribute('capture');
}
function toggleMode(){ setCaptureMode(captureMode === 'camera' ? 'gallery' : 'camera'); }
function triggerCapture(){
  if (MODE[captureMode].capture) fileInput.setAttribute('capture', 'environment');
  else fileInput.removeAttribute('capture');
  fileInput.click();
}

btnSnap.addEventListener('pointerdown', e => {
  if (!e.isPrimary) return;
  e.preventDefault();
  isLongPress = false;
  clearTimeout(lpTimer);
  btnSnap.classList.add('progressing'); // start visual fill
  lpTimer = setTimeout(() => {
    isLongPress = true;
    toggleMode();
    btnSnap.classList.remove('progressing'); // stop fill once toggled
  }, LONG_MS);
});

btnSnap.addEventListener('pointerup', e => {
  if (!e.isPrimary) return;
  clearTimeout(lpTimer);
  if (!isLongPress) triggerCapture();
  btnSnap.classList.remove('progressing'); // cancel fill
});

// Remove pointerleave and pointercancel listeners (no longer needed)

/* --- end simple long-press controller --- */

/* --- wire up other handlers (remove conflicting click) --- */
// REMOVED: btnSnap.addEventListener('click', ()=> fileInput.click());
btnSettings.addEventListener('click', ()=> { settingsPanel.style.right = (settingsPanel.style.right === '0px') ? '-320px' : '0px'; });
btnCloseSettings.addEventListener('click', ()=> { settingsPanel.style.right = '-320px'; });
// also allow closing when panel is open and user clicks outside (optional)
document.addEventListener('keydown', e=>{ if(e.key === 'Escape'){ settingsPanel.style.right='-320px'; descDialog.close?.(); /* NEW: close params panel on Esc */ paramsPanel?.classList.remove('open'); paramsPanel?.setAttribute('aria-hidden','true'); } });

// NEW: params panel open/close/save
paramsToggle?.addEventListener('click', ()=>{
  // populate from current state before showing
  if (params_collectionTitle) params_collectionTitle.value = collectionTitleInput.value || '';
  if (params_clientName) params_clientName.value = state.client || '';
  if (params_projectTitle) params_projectTitle.value = state.project || '';
  if (params_photographerName) params_photographerName.value = state.photographer || '';
  
  paramsPanel?.classList.add('open');
  paramsPanel?.setAttribute('aria-hidden','false');
});
paramsClose?.addEventListener('click', ()=>{
  paramsPanel?.classList.remove('open');
  paramsPanel?.setAttribute('aria-hidden','true');
});
paramsSave?.addEventListener('click', ()=>{
  // write back to hidden fields + state
  const name = (params_collectionTitle?.value || '').trim();
  const client = (params_clientName?.value || '').trim();
  const proj = (params_projectTitle?.value || '').trim();
  const photoboard = (params_photographerName?.value || '').trim();

  if (name) collectionTitleInput.value = name;
  state.client = client; clientNameInput.value = client;
  state.project = proj; projectTitleInput.value = proj;
  state.photographer = photoboard; photographerNameInput.value = photoboard;

  // persist and refresh UI
  if (activeSessionId) {
    saveGlobalsToSession(activeSessionId);
    renderSessions?.();
  }
  // close panel
  paramsPanel?.classList.remove('open');
  paramsPanel?.setAttribute('aria-hidden','true');
});

// NEW: File System Access API logic
if (btnChooseFolder) {
  if ('showDirectoryPicker' in window) {
    btnChooseFolder.addEventListener('click', async () => {
      try {
        const handle = await window.showDirectoryPicker();
        // Request permission. This must be done within the user gesture.
        const permStatus = await handle.requestPermission({ mode: "readwrite" });

        // Explicitly verify the permission state after the request.
        if (permStatus === "granted") {
          // Verify we can actually use the handle (some mobile browsers require this).
          if (await handle.queryPermission({ mode: 'readwrite' }) !== 'granted') {
            throw new Error("Permission was not fully granted. Please try again.");
          }
          
          dirHandle = handle;
          await saveDirectoryHandle(handle);
          folderStatus.textContent = `Status: Saving to "${handle.name}" folder.`;
          alert(`Successfully linked to folder: ${handle.name}`);
        } else {
          throw new Error("Read/write access was not granted.");
        }
      } catch (err) {
        if (err.name !== 'AbortError') {
          alert('Could not get folder access: ' + err.message);
          console.error(err);
        }
      }
    });
  } else {
    btnChooseFolder.disabled = true;
    folderStatus.textContent = 'Status: Your browser does not support local directory saving.';
  }
}

function fmtBNGDisplay(pos){
  if(!pos) return '';
  const accText = `â‰ˆ${Math.round(pos.accuracy||3)} m`;
  if(typeof pos.bngE !== 'undefined' && typeof pos.lat === 'number' && typeof pos.lon === 'number'){
    return `BNG: E ${pos.bngE} N ${pos.bngN}* | Lat ${pos.lat.toFixed(6)}, Lon ${pos.lon.toFixed(6)} (${accText})`;
  }
  if(typeof pos.lat === 'number' && typeof pos.lon === 'number'){
    return `Lat ${pos.lat.toFixed(6)}, Lon ${pos.lon.toFixed(6)} (${accText})`;
  }
  return '';
}

function startWatch(){
  if(!navigator.geolocation || watchId) return;
  try{
    watchId = navigator.geolocation.watchPosition(pos=>{
      try{
        const lat = pos.coords.latitude, lon = pos.coords.longitude, acc = pos.coords.accuracy;
        const bng = latLonToBNG(lat, lon); // latLonToBNG()
        lastKnownPos = { lat, lon, accuracy: acc, bngE: bng.easting, bngN: bng.northing };
        pendingGPS = lastKnownPos;
        // update dialog field if open
        if(descDialog.open){
          descPosition.value = fmtBNGDisplay(lastKnownPos);
        }
        // visual indicator & tooltip include accuracy
        setLocationButtonState(true, Math.round(acc||0));
      }catch(err){
        console.warn('watchPosition -> BNG convert failed', err);
      }
    }, err=>{
      console.warn('watchPosition error', err);
      // turn off visual indicator on errors (permission/unavailable/etc)
      setLocationButtonState(false);
    }, { enableHighAccuracy:true, maximumAge:0, timeout:20000 });
  }catch(e){
    console.warn('startWatch failed', e);
    setLocationButtonState(false);
  }
}

function stopWatch(){
  if(watchId !== null && navigator.geolocation){
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
    // visual reset: icon shows disabled
    setLocationButtonState(false);
  }
}

btnEnableLoc.addEventListener('click', async ()=>{
  // If watch already running, stop it
  if(watchId){
    stopWatch();
    locationEnabled = false;
    setLocationButtonState(false);
    return;
  }

  // User gesture: do a oneâ€‘shot getCurrentPosition to force browser permission prompt,
  // then start watchPosition if permission is granted.
  // show ephemeral request state in button tooltip
  btnEnableLoc.setAttribute('title','Requestingâ€¦');
  const pos = await requestLocationOnce();
  if(!pos){
    setLocationButtonState(false, 'Denied / unavailable');
    return;
  }

  try{
    const lat = pos.coords.latitude, lon = pos.coords.longitude, acc = pos.coords.accuracy;
    const bng = latLonToBNG(lat, lon);
    lastKnownPos = { lat, lon, accuracy: acc, bngE: bng.easting, bngN: bng.northing };
    pendingGPS = lastKnownPos;
    descPosition.value = fmtBNGDisplay(lastKnownPos);
    // now start continuous watch (will not re-prompt)
    startWatch();
    locationEnabled = true;
    setLocationButtonState(true, Math.round(acc||0));
  }catch(err){
    console.warn('Enable location failed', err);
    setLocationButtonState(false, 'Error');
  }
});

/* helper to set location button visual state (green when enabled, red when off) */
function setLocationButtonState(enabled, accOrMsg){
  const btn = document.getElementById('btnEnableLoc');
  const warn = document.getElementById('locWarning');
  if(btn){
    if(enabled){
      btn.classList.remove('loc-off'); btn.classList.add('loc-on');
      const title = (typeof accOrMsg === 'number') ? `Disable location (â‰ˆ${accOrMsg} m)` : 'Disable location';
      btn.setAttribute('title', title);
      btn.setAttribute('aria-pressed','true');
    }else{
      btn.classList.remove('loc-on'); btn.classList.add('loc-off');
      const title = (typeof accOrMsg === 'string') ? accOrMsg : 'Enable location';
      btn.setAttribute('title', title);
      btn.setAttribute('aria-pressed','false');
    }
  }
  // Toggle header warning chip
  if (warn) {
    if (enabled) {
      warn.style.display = 'none';
    } else {
      warn.textContent = 'Location OFF';
      warn.style.display = 'inline-flex';
    }
  }
}

/* initialize location button visual state (off by default) */
document.addEventListener('DOMContentLoaded', ()=> {
  setLocationButtonState(false, 'Enable location');
  setCaptureMode(captureMode); // ensure initial green mode class
});

/* ---------------- Helpers needed by capture / UI ---------------- */
function escapeHTML(s){ return (s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[m])); }
function fmtCount(n){ return `${n} item${n===1?'':'s'}`; }
function toDataURL(canvas, quality=0.92){ return canvas.toDataURL('image/jpeg', quality); }

function dataURLtoBlob(dataURL){
  const parts = dataURL.split(',');
  const mime = parts[0].match(/:(.*?);/)[1];
  const binStr = atob(parts[1]);
  const len = binStr.length;
  const u8 = new Uint8Array(len);
  for(let i=0;i<len;i++) u8[i]=binStr.charCodeAt(i);
  return new Blob([u8], {type:mime});
}

// NEW: Helper to ensure imported items match current structure
function normaliseLegacyItem(item) {
  // If item has flat GPS props (legacy), move them to .gps object
  if (!item.gps && (typeof item.lat === 'number' || typeof item.bngE !== 'undefined')) {
    item.gps = {
      lat: item.lat,
      lon: item.lon,
      accuracy: item.accuracy,
      bngE: item.bngE,
      bngN: item.bngN
    };
    // clean up flat props to avoid confusion
    delete item.lat; delete item.lon; delete item.accuracy; delete item.bngE; delete item.bngN;
  }
  // Strip transient UI properties
  delete item._preview;
  delete item._loading;
  delete item._needsPreview;
  return item;
}

/** Normalize an image file. 
    - Loads image reliably into an HTMLImageElement
    - Preserves aspect ratio
    - Optionally rotates portrait sources 90Â° to yield landscape output (if forceRotate=true)
*/
async function normalizeImage(file, maxW, forceRotate=true){
  // helper to load an image element from a File/Blob
  const loadImg = (blob) => new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(img);
    img.onerror = (e) => rej(e);
    // Avoid tainting from cross-origin; blob URL is same-origin
    img.src = URL.createObjectURL(blob);
  });

  const img = await loadImg(file);

  // source dimensions
  const sw = img.width;
  const sh = img.height;

  // determine if source is portrait
  const isPortrait = sh > sw;
  // Rotate only if forced AND it is portrait
  const rotate = forceRotate && isPortrait;

  // Scale based on the longest side (if rotating, dimensions swap, but max is same)
  const sourceLong = Math.max(sw, sh);
  const scale = Math.min(1, (maxW || 1920) / sourceLong);

  // Output dimensions
  const outW = Math.round((rotate ? sh : sw) * scale);
  const outH = Math.round((rotate ? sw : sh) * scale);

  const canvas = document.createElement('canvas');
  canvas.width = outW;
  canvas.height = outH;
  const ctx = canvas.getContext('2d');

  if (rotate) {
    // Rotate 90deg clockwise and draw the scaled image centered.
    ctx.save();
    ctx.translate(outW / 2, outH / 2);
    ctx.rotate(Math.PI / 2);
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    ctx.drawImage(img, -dw / 2, -dh / 2, dw, dh);
    ctx.restore();
  } else {
    // Draw scaled to fit canvas (centering handles minor rounding diffs)
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    const dx = Math.round((outW - dw) / 2);
    const dy = Math.round((outH - dh) / 2);
    ctx.drawImage(img, dx, dy, dw, dh);
  }

  // release object URL created by loadImg (best-effort)
  try { URL.revokeObjectURL(img.src); } catch (e) {}

  return canvas;
}

/* ---------------- British National Grid conversion helpers ----------------
   WGS84 -> OSGB36 Helmert transform + Transverse Mercator
   returns {easting, northing}
*/
function deg2rad(d){ return d * Math.PI/180; }
function latLonToBNG(lat, lon){
  const aW = 6378137.0, bW = 6356752.3141;
  const aA = 6377563.396, bA = 6356256.909;
  const tx = -446.448, ty = 125.157, tz = -542.060;
  const rxSec = -0.1502, rySec = -0.2470, rzSec = -0.8421;
  const sppm = 20.4894;

  const latR = deg2rad(lat), lonR = deg2rad(lon);
  const e2W = (aW*aW - bW*bW) / (aW*aW);
  const vW = aW / Math.sqrt(1 - e2W * Math.sin(latR)*Math.sin(latR));
  const xW = vW * Math.cos(latR) * Math.cos(lonR);
  const yW = vW * Math.cos(latR) * Math.sin(lonR);
  const zW = (vW * (1 - e2W)) * Math.sin(latR);

  const rx = rxSec / 3600 * Math.PI/180;
  const ry = rySec / 3600 * Math.PI/180;
  const rz = rzSec / 3600 * Math.PI/180;
  const s = sppm * 1e-6 + 1;

  const xO = tx + s*( xW + (-rz)*yW + ry*zW );
  const yO = ty + s*( rz*xW + yW + (-rx)*zW );
  const zO = tz + s*( (-ry)*xW + rx*yW + zW );

  const e2A = (aA*aA - bA*bA) / (aA*aA);
  let p = Math.sqrt(xO*xO + yO*yO);
  let latA = Math.atan2(zO, p * (1 - e2A));
  let latPrev = 1e9, vA;
  while(Math.abs(latA - latPrev) > 1e-12){
    latPrev = latA;
    vA = aA / Math.sqrt(1 - e2A * Math.sin(latA)*Math.sin(latA));
    latA = Math.atan2(zO + e2A * vA * Math.sin(latA), p);
  }
  const lonA = Math.atan2(yO, xO);

  const lat0 = deg2rad(49.0), lon0 = deg2rad(-2.0);
  const N0 = -100000.0, E0 = 400000.0, F0 = 0.9996012717;
  const n = (aA - bA) / (aA + bA);
  const nu = aA * F0 / Math.sqrt(1 - e2A * Math.sin(latA)*Math.sin(latA));
  const rho = aA * F0 * (1 - e2A) / Math.pow(1 - e2A * Math.sin(latA)*Math.sin(latA), 1.5);
  const eta2 = nu / rho - 1;

  const M = bA * F0 * (
    (1 + n + (5/4)*n*n + (5/4)*n*n*n) * (latA - lat0)
    - (3*n + 3*n*n + (21/8)*n*n*n) * Math.sin(latA - lat0) * Math.cos(latA + lat0)
    + ((15/8)*n*n + (15/8)*n*n*n) * Math.sin(2*(latA - lat0)) * Math.cos(2*(latA + lat0))
    - (35/24)*n*n*n * Math.sin(3*(latA - lat0)) * Math.cos(3*(latA + lat0))
  );

  const I = M + N0;
  const II = (nu/2) * Math.sin(latA) * Math.cos(latA);
  const III = (nu/24) * Math.sin(latA) * Math.pow(Math.cos(latA),3) * (5 - Math.tan(latA)*Math.tan(latA) + 9*eta2);
  const IIIA = (nu/720) * Math.sin(latA) * Math.pow(Math.cos(latA),5) * (61 - 58*Math.tan(latA)*Math.tan(latA) + Math.pow(Math.tan(latA),4));
  const IV = nu * Math.cos(latA);
  const V = (nu/6) * Math.pow(Math.cos(latA),3) * (nu/rho - Math.tan(latA)*Math.tan(latA));
  const VI = (nu/120) * Math.pow(Math.cos(latA),5) * (5 - 18*Math.tan(latA)*Math.tan(latA) + Math.pow(Math.tan(latA),4) + 14*eta2 -  58*Math.tan(latA)*Math.tan(latA)*eta2);

  const dLon = lonA - lon0;
  const dLon2 = dLon*dLon, dLon3 = dLon2*dLon, dLon4 = dLon3*dLon, dLon5 = dLon4*dLon, dLon6 = dLon5*dLon;

  const N = I + II*dLon2 + III*dLon4 + IIIA*dLon6;
  const E = E0 + IV*dLon + V*dLon3 + VI*dLon5;

  return { easting: Math.round(E), northing: Math.round(N) };
}

/* getCurrentPosition-style single read (used as quick attempt when saving) */
function requestLocationOnce(){
  if(!navigator.geolocation) return Promise.resolve(null);
  return new Promise((resolve)=>{
    navigator.geolocation.getCurrentPosition(pos=>{
      resolve(pos);
    }, err=>{
      console.warn('Geolocation getCurrentPosition failed', err);
      resolve(null);
    }, { enableHighAccuracy:true, timeout:10000, maximumAge:0 });
  });
}

// NEW: Lazy preview generator
function createPreviewCanvas(item) {
  if (item._preview) return item._preview;
  if (!item._needsPreview) return null;
  if (item._loading) return null; // Prevent duplicate loads

  item._loading = true;
  const img = new Image();
  img.onload = () => {
    delete item._loading;
    const canvas = document.createElement('canvas');
    // Create a thumbnail (max 300px)
    const scale = Math.min(300 / img.width, 300 / img.height, 1);
    canvas.width = Math.floor(img.width * scale);
    canvas.height = Math.floor(img.height * scale);
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    
    item._preview = canvas;
    item._needsPreview = false;
    
    // Update DOM if visible
    const thumb = document.querySelector(`.thumb[data-id="${item.id}"] canvas`);
    if (thumb) {
      const newC = document.createElement('canvas');
      newC.width = canvas.width;
      newC.height = canvas.height;
      newC.getContext('2d').drawImage(canvas, 0, 0);
      thumb.replaceWith(newC);
    }
  };
  img.onerror = () => { 
    delete item._loading;
    item._needsPreview = false; 
  };
  img.src = item.dataURL;
  return null;
}

/* Render gallery from state.items (uses item._preview canvas if present) */
function renderGallery(){
  const gallery = document.getElementById('gallery');
  gallery.innerHTML = '';

  // NEW: show placeholder when empty
  const items = [...state.items].sort((a, b) => {
    const ta = new Date(a.whenISO || a.created).getTime() || 0;
    const tb = new Date(b.whenISO || b.created).getTime() || 0;
    return tb - ta;
  });
  if (items.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'gallery-placeholder';
    empty.setAttribute('role', 'status');
    empty.setAttribute('aria-live', 'polite');
    empty.innerHTML = `
      <svg viewBox="0 0 24 24" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <rect x="3" y="7" width="18" height="12" rx="2"></rect>
        <path d="M7 7l2-3h6l2 3"></path>
        <circle cx="12" cy="13" r="4"></circle>
      </svg>
      <div>No photos yet</div>
      <small>Tap â€œPhotoâ€ to add images to this collection.</small>
    `;
    gallery.appendChild(empty);
    const countEl = document.getElementById('count');
    if (countEl) countEl.textContent = '0 items';
    return;
  }

  items.forEach(item=>{
    const card=document.createElement('div'); card.className='thumb';
    card.dataset.id = item.id; // NEW: ID for lazy update

    // NEW: Long press to edit description
    let pressTimer;
    const cancelPress = () => clearTimeout(pressTimer);
    card.addEventListener('pointerdown', (e) => {
      if (e.target.closest('button')) return; // Ignore buttons
      pressTimer = setTimeout(() => {
        editingItem = item;
        // Populate dialog
        descText.value = item.desc || '';
        const dt = item.whenISO ? new Date(item.whenISO) : (item.created ? new Date(item.created) : new Date());
        // Adjust to local ISO for datetime-local input
        descWhen.value = new Date(dt.getTime() - dt.getTimezoneOffset() * 60000).toISOString().slice(0, 19);
        descPosition.value = fmtBNGDisplay(item.gps);
        
        const header = descDialog.querySelector('header strong');
        if(header) header.textContent = 'Edit description';
        
        descDialog.showModal();
        if(navigator.vibrate) navigator.vibrate(40);
      }, 600);
    });
    card.addEventListener('pointerup', cancelPress);
    card.addEventListener('pointerleave', cancelPress);
    card.addEventListener('pointercancel', cancelPress);
    // End long press logic

    // Lazy load logic
    const preview = createPreviewCanvas(item);
    let c;
    
    if (preview) {
      c = document.createElement('canvas');
      c.width = preview.width;
      c.height = preview.height;
      c.getContext('2d').drawImage(preview, 0, 0);
    } else {
      // Placeholder
      c = document.createElement('canvas');
      c.width = 300;
      c.height = 225;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#1f2937';
      ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle = '#4b5563';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Loading...', c.width/2, c.height/2);
    }

    const meta=document.createElement('div'); meta.className='meta';
    const when=item.whenISO?new Date(item.whenISO):new Date(item.created);
    let gpsText = '';
    if(item.gps){
      if(typeof item.gps.bngE !== 'undefined'){
        gpsText = ` â€¢ ${fmtBNGDisplay(item.gps)}`;
      }else if(typeof item.gps.lat === 'number' && typeof item.gps.lon === 'number'){
        gpsText = ` â€¢ Lat ${item.gps.lat.toFixed(6)}, Lon ${item.gps.lon.toFixed(6)} (â‰ˆ${Math.round(item.gps.accuracy||3)} m)`;
      }
    }
    meta.innerHTML = `<div><strong>${escapeHTML(item.desc||'(no description)')}</strong><span class="badge">${item.w||'?'}Ã—${item.h||'?'}</span></div>
      <small>${when.toLocaleString()}${gpsText} â€¢ ${escapeHTML(item.tech||'')} â€¢ ${escapeHTML(item.loc||'')}</small>`;
    
    // NEW: replace button (top-left)
    const replaceBtn = document.createElement('button');
    replaceBtn.type = 'button';
    replaceBtn.className = 'replace-btn';
    replaceBtn.title = 'Replace this image';
    replaceBtn.setAttribute('aria-label','Replace this image');
    replaceBtn.innerHTML = `
      <svg viewBox="0 0 24 24" aria-hidden="true" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="7" width="18" height="12" rx="2"></rect>
        <path d="M7 7l2-3h6l2 3"></path>
        <circle cx="12" cy="13" r="4"></circle>
      </svg>`;
    replaceBtn.addEventListener('click', () => {
      const picker = document.createElement('input');
      picker.type = 'file';
      picker.accept = 'image/*';
      picker.style.display = 'none';
           document.body.appendChild(picker);
      picker.addEventListener('change', async () => {
        const file = picker.files?.[0];
        if (!file) { picker.remove(); return; }
        try {
          const maxW = 1920;
          // CHANGED: Always preserve orientation for single replace (pass false)
          const canvas = await normalizeImage(file, maxW, false);
          // Replace image data; keep description and timestamps unchanged
          item.dataURL = toDataURL(canvas, 0.9);
                   item.w = canvas.width;
          item.h = canvas.height;
          item._preview = canvas;
          // Persist and re-render
          saveGlobalsToSession(activeSessionId);
          renderGallery();
        } catch ( err) {
          alert('Failed to replace image: ' + err.message);
          console.error(err);
        } finally {
          picker.remove();
        }
      }, { once: true });
      picker.click();
    });

    // NEW: Rotate button
    const rotateBtn = document.createElement('button');
    rotateBtn.type = 'button';
    rotateBtn.className = 'rotate-btn';
    rotateBtn.title = 'Rotate 90Â°';
    rotateBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`;
    rotateBtn.addEventListener('click', async () => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = item.h;
            canvas.height = item.w;
            const ctx = canvas.getContext('2d');
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(90 * Math.PI / 180);
            ctx.drawImage(img, -item.w/2, -item.h/2);
            
            item.dataURL = toDataURL(canvas, 0.9);
            item.w = canvas.width;
            item.h = canvas.height;
            item._preview = canvas;
            saveGlobalsToSession(activeSessionId);
            renderGallery();
        };
        img.src = item.dataURL;
    });

    // Updated delete button (uses CSS class, removed duplicate appends)
    const deleteBtn = document.createElement('button');
    deleteBtn.type='button';
    deleteBtn.className='delete-btn';
    deleteBtn.title='Delete this image';
    deleteBtn.setAttribute('aria-label','Delete this image');
    deleteBtn.innerHTML = `
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
        <path d="M10 11v6M14 11v6" stroke="#f87171" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    deleteBtn.addEventListener('click', async () => {
      if (!confirm('Delete this image from this collection?')) return;
      const index = state.items.indexOf(item);
      if (index > -1) {
        state.items.splice(index, 1);
        saveGlobalsToSession(activeSessionId);
        renderGallery();
      }
    });

    card.appendChild(c);
    card.appendChild(meta);
    card.appendChild(replaceBtn);
    card.appendChild(rotateBtn); // NEW
    card.appendChild(deleteBtn);
    gallery.appendChild(card);
  });
  const countEl = document.getElementById('count');
  countEl.textContent = fmtCount(state.items.length);
}

fileInput.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{
    const maxW = 1920; 
    // CHANGED: Always preserve orientation for single capture (pass false)
    pendingCanvas = await normalizeImage(f, maxW, false);

    // start location lookup (best-effort) and store in pendingGPS
    pendingGPS = null;
    // Only attempt an automatic fresh lookup if permission is already granted or user enabled location
    try{
      const perm = navigator.permissions ? await navigator.permissions.query({ name:'geolocation' }) : null;
      if((perm && perm.state === 'granted') || locationEnabled){
        // attempt a quick fresh high-accuracy read (best-effort)
        const pos = await requestLocationOnce();
        if(pos){
          try{
            const lat = pos.coords.latitude, lon = pos.coords.longitude, acc = pos.coords.accuracy;
            const bng = latLonToBNG(lat, lon);
            pendingGPS = { lat, lon, accuracy: acc, bngE: bng.easting, bngN: bng.northing };
            lastKnownPos = pendingGPS;
          }catch(err){
            console.warn('BNG conversion failed', err);
          }
        }else if(lastKnownPos){
          // fallback to last known if fresh read failed
          pendingGPS = lastKnownPos;
        }
      }else{
        // do not prompt â€” user must click "Enable Location"
        pendingGPS = null;
      }
    }catch(e){
      console.warn('Permission check / geolocation failed', e);
    }
    
    // NEW: Reset edit state for new capture
    editingItem = null;
    const header = descDialog.querySelector('header strong');
    if(header) header.textContent = 'Add description';

    descText.value='';
    const now = new Date();
    // include seconds (slice to 19 to get YYYY-MM-DDTHH:MM:SS)
    descWhen.value = new Date(now.getTime()-now.getTimezoneOffset()*60000).toISOString().slice(0,19);
    // populate position field in dialog using pendingGPS or lastKnownPos (watch supplies lastKnownPos)
    const posToShow = pendingGPS || lastKnownPos;
    descPosition.value = fmtBNGDisplay(posToShow);
    descDialog.showModal();
  }catch(err){ alert('Failed to process image: '+err); }
  finally{ fileInput.value=''; }
});

// NEW: Bulk upload handlers
if (btnBulkUpload && bulkInput) {
  btnBulkUpload.addEventListener('click', () => bulkInput.click());
  
  bulkInput.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;

    if (!confirm(`Ready to upload ${files.length} photos?\n\nNote: Descriptions and specific GPS data will be skipped for these items.`)) {
      bulkInput.value = '';
      return;
    }

    // Ensure active session
    if(!activeSessionId || !sessions[activeSessionId]){
      try{
        activeSessionId = await createNewSession();
      }catch(err){
        alert('Could not create session.');
        return;
      }
    }

    let processed = 0;
    const total = files.length;
    
    // UI Feedback
    const originalContent = btnBulkUpload.innerHTML;
    btnBulkUpload.textContent = `Processing 0/${total}...`;
    btnBulkUpload.disabled = true;

    try {
      for (const f of files) {
        try {
          const maxW = 1920;
          // CHANGED: Use normalizeImage with rotation setting
          const canvas = await normalizeImage(f, maxW, cfgRotate?.checked);
          const dataURL = toDataURL(canvas, 0.9);
          
          const item = {
            dataURL,
            w: canvas.width,
            h: canvas.height,
            desc: '', // Skipped
            whenISO: new Date().toISOString(),
            tech: state.photographerInitials || '',
            loc: '',
            created: new Date().toISOString(),
            gps: null // Skipped
          };

          // Add to DB and State
          const id = await idbAdd(item);
          item.id = id;
          item._preview = canvas;
          state.items.push(item);
          
          processed++;
          btnBulkUpload.textContent = `Processing ${processed}/${total}...`;
          
          // Yield to UI thread slightly
          await new Promise(r => setTimeout(r, 10));
        } catch (err) {
          console.error('Failed to process a file in bulk upload', err);
        }
      }
      
      saveGlobalsToSession(activeSessionId);
      renderGallery();
    } catch (err) {
      alert('Error during bulk upload: ' + err.message);
    } finally {
      btnBulkUpload.innerHTML = originalContent;
      btnBulkUpload.disabled = false;
      bulkInput.value = '';
    }
  });
}

descCancel.addEventListener('click', ()=>{ pendingCanvas=null; pendingGPS=null; editingItem=null; descDialog.close(); });
descOK.addEventListener('click', async ()=>{
  // NEW: Handle edit save
  if (editingItem) {
    editingItem.desc = descText.value.trim();
    if (descWhen.value) editingItem.whenISO = new Date(descWhen.value).toISOString();
    // Persist changes
    saveGlobalsToSession(activeSessionId);
    renderGallery();
    
    editingItem = null;
    descDialog.close();
    return;
  }

  if(!pendingCanvas) { descDialog.close(); return; }

  // Ensure we have an active session to save into. Create one if needed.
  if(!activeSessionId || !sessions[activeSessionId]){
    try{
      // createNewSession activates the session and returns its id
      activeSessionId = await createNewSession();
    }catch(err){
      console.error('Failed to create a new collection/session', err);
      alert('Unable to save image: could not create a collection.');
      return;
    }
  }

  const dataURL = toDataURL(pendingCanvas, 0.9);
  const item = {
    dataURL,
    w: pendingCanvas.width,
    h: pendingCanvas.height,
    desc: descText.value.trim(),
    whenISO: descWhen.value? new Date(descWhen.value).toISOString(): null,
    // CHANGED: Autofill tech from photographer initials in settings
    tech: state.photographerInitials || '',
    loc: '', // free-text location removed â€” keep empty, GPS stored under gps    
    created: new Date().toISOString(),
    gps: pendingGPS // may be null if unavailable
  };

  // Legacy store write
  const id = await idbAdd(item);
  item.id = id;
  item._preview = pendingCanvas;

  // Add to in-memory state and persist into the active session
  state.items.push(item);
  saveGlobalsToSession(activeSessionId); // Persist immediately after adding
  renderGallery();

  pendingCanvas = null;
  pendingGPS = null;
  descDialog.close();
});
 
// do NOT start watching automatically â€” require user gesture
async function openCollectionsPanel() {
  const panel = document.getElementById('collections');
  if (!panel) {
    console.error('Collections panel not found');
    return;
  }
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
  document.body.classList.add('collections-open');
}

async function closeCollectionsPanel() {
  const panel = document.getElementById('collections');
  if (!panel) {
    console.error('Collections panel not found');
    return;
  }
  panel.classList.remove('open');
  panel.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('collections-open');
}

/* ---------- Startup ---------- */
document.addEventListener('DOMContentLoaded', () => {
  (async function init(){
    await loadPersistedSessions();
       // NEW: check for saved directory handle on startup
    if ('showDirectoryPicker' in window) {
      const savedHandle = await getDirectoryHandle();
      if (savedHandle) {
        // Verify we still have permission. This doesn't prompt the user.
        if (await savedHandle.queryPermission({ mode: 'readwrite' }) === 'granted') {
          // And verify the handle is still usable by trying a non-destructive read.
          try {
            // `keys()` is a simple async iterator to check usability.
            // We don't need to do anything with the result.
            // If this fails, the handle is stale.
            await savedHandle.keys().next(); 
            dirHandle = savedHandle;
            folderStatus.textContent = `Status: Saving to "${dirHandle.name}" folder.`;
          } catch (e) {
            console.warn('Stale directory handle, re-selection needed.', e);
            folderStatus.textContent = `Status: Re-select "${savedHandle.name}" to grant access.`;
            dirHandle = null;
          }
        } else {
          // Permission was not persisted or was revoked. User must re-grant it.
          folderStatus.textContent = `Status: Permission needed for "${savedHandle.name}". Click "Choose Folder" to re-enable.`;
          dirHandle = null; // Clear the stale handle.
        }
      }
    }
  })();

  const headerRow1 = document.querySelector('.header-row-1');
  window.addEventListener('scroll', () => {
    if (!headerRow1) return;
    if (window.scrollY > 80) headerRow1.classList.add('is-hidden');

    else headerRow1.classList.remove('is-hidden');
  });
});


btnClear?.addEventListener('click', async ()=>{
  if(!confirm('Clear all images from the current collection?')) return;
  state.items = [];
  saveGlobalsToSession(activeSessionId);
  renderGallery();
});

/* ---------- Export helpers that return Blobs ---------- */
async function buildPPTXBlob(fileName){
  // NEW: read caption attribute toggles
  const includeTimestamp    = attrTimestampChk?.checked !== false;
  const includePosition     = attrPositionChk?.checked !== false;
  const includeAccuracy     = attrAccuracyChk?.checked !== false;
  const includePhotographer = attrPhotographerChk?.checked !== false;
  const photographerInitials = (state.photographerInitials || '').trim();

  if(state.items.length===0) { alert('Nothing to export.'); return null; }
  
  // Ensure current session data is saved before export
  saveGlobalsToSession(activeSessionId);

  const layout = parseInt(layoutSel.value,10); // 1,2,4
  const perSlide = layout;
  const groups = []; for(let i=0;i<state.items.length;i+=perSlide) groups.push(state.items.slice(i,i+perSlide));

  // Create a fresh presentation (do not attempt to load a template)
  const pptx = new PptxGenJS();
  try{
    pptx.defineLayout({ name:'A4PORTRAIT', width:8.27, height:11.69 });
    pptx.defineLayout({ name:'A4LANDSCAPE', width:11.69, height:8.27 });
  }catch(e){/*ignore*/}

  const isLandscape = (orientationSel && orientationSel.value === 'landscape');
  try{ pptx.layout = isLandscape ? 'A4LANDSCAPE' : 'A4PORTRAIT'; }catch(e){}

  // Use margins from settings (mm -> inches)
  const marginsMM = 10; // REMOVED: Number(marginsInput.value) || 10;
  const margin = Math.max(0.05, marginsMM / 25.4); // in

  // Slide dimensions based on chosen layout
  const slideW = isLandscape ? 11.69 : 8.27;
  const slideH = isLandscape ? 8.27 : 11.69;

  // Side panel width as proportion of slide width so it scales with orientation
  const sideW = Math.min(2.4, Math.max(1.6, slideW * 0.24)); // clamp to reasonable bounds
  const contentW = slideW - margin*2 - sideW - 0.12; // small gap before side panel
  const contentH = slideH - margin*2;

  // Grid selection: make 2-up side-by-side in landscape, stacked in portrait
  const grid = layout === 1 ? { rows: 1, cols: 1 } : (layout === 2 ? (isLandscape ? { rows: 1, cols: 2 } : { rows: 2, cols: 1 }) : { rows: 2, cols: 2 });
  const cellW = contentW / grid.cols;
  const cellH = contentH / grid.rows;

  // Visual style values
  const blueBar = '8DB2E8';
  const lightGrey = 'F6F8FA';
  const textGrey = '444444';

  // Attempt to load logo data URL once (best-effort). Keep it simple and non-blocking.
  let logoDataUrl = null;
  let logoRatio = null; // NEW: Store aspect ratio
  try{
    const r = await fetch('./brownfield_logo.png', { cache:'no-store' });
    if(r.ok){
      const blob = await r.blob();
      logoDataUrl = await new Promise(res=>{
        const fr = new FileReader();
        fr.onload = ()=>res(fr.result);
        fr.onerror = ()=>res(null);
        fr.readAsDataURL(blob);
      });
      // NEW: Calculate aspect ratio
      if (logoDataUrl) {
        await new Promise(resolve => {
          const img = new Image();
          img.onload = () => { logoRatio = img.width / img.height; resolve(); };
          img.onerror = () => resolve();
          img.src = logoDataUrl;
        });
      }
    }
  }catch(e){ logoDataUrl = null; }

  let slideIndex = 0;
  let globalPhotoIndex = 0; // sequential numbering across slides

  // Insert helper to draw the entire right panel (logo, desc rows, footer fields)
  function addRightPanel(slide, {
    pptx,
    sideX,
    sideW,
    panelTopY,
    panelH,
    textGrey,
    borderBlue,
    panelFill,
    logoDataUrl,
    logoRatio, // NEW: Accept ratio
    pageNumber,
    descItems,        // array of up to 4 { num: 1-based index, text: 'desc...' }
    client,
    project,
    collection,
    photographer,
    includeAccuracy   // NEW: accept accuracy flag
  }) {
    // Internal layout constants
    const innerPadX     = 0.18;
    const innerW        = sideW - (innerPadX * 2);
    const headingFontSize = 12;
    const labelFontSize   = 8;
    const fieldFontSize   = 9;
    const descRowH     = 0.4;
    const descGapY     = 0.08;
    const logoBlockH   = 0.9;
    const postLogoGap  = 0.25;
    const footerLabelH = 0.1;
    const footerBoxH   = 0.27;
    const footerGapY   = 0.15;
    const labelBoxGap  = 0.075; // Increased by 50% from 0.05 to reduce overlap

    // 1. Panel background
    slide.addShape(pptx.ShapeType.rect, { x: sideX, y: panelTopY, w: sideW, h: panelH, fill: { color: panelFill } });

    // --- Top 50% section (Descriptions) ---
    let yCursor = panelTopY + 0.2;
    slide.addText('Photo Descriptions', { x: sideX + innerPadX, y: yCursor, w: innerW, h: 0.3, fontSize: headingFontSize, bold: true, color: textGrey, align: 'left', valign: 'top' });
    yCursor += 0.4;

    // NEW: Dynamic height estimation constants
    const charsPerLine = Math.floor(innerW * 14); // Conservative estimate (approx 14 chars/inch for 9pt)
    const lineHeight = 0.15; 
    const boxPadding = 0.1;

    for (let i = 0; i < 4; i++) {
      const item = descItems[i];
      
      // CHANGED: Prepare text payload as array to support bold number + colon
      let textPayload = '';
      let totalLen = 0;

      if (item) {
        textPayload = [
          { text: `${item.num}: `, options: { bold: true } },
          { text: item.text || '' }
        ];
        totalLen = String(item.num).length + 2 + (item.text || '').length;
      }
      
      // NEW: Calculate height based on text length to auto-expand
      let boxH = descRowH;
      if (totalLen > 0) {
        const lines = Math.ceil(totalLen / charsPerLine);
        // If text needs more than 2 lines (approx capacity of standard box), expand
        if (lines > 2) {
          boxH = Math.max(descRowH, (lines * lineHeight) + boxPadding);
        }
      }

      // CHANGED: Use addText with shape property so text is part of the box
      slide.addText(textPayload, {
        shape: pptx.ShapeType.rect,
        x: sideX + innerPadX,
        y: yCursor,
        w: innerW,
        h: boxH,
        fill: { color: 'FFFFFF' },
        line: { color: borderBlue },
        color: textGrey,
        fontSize: fieldFontSize,
        align: 'left',
        valign: 'top',
        inset: 0.05
      });
      
      yCursor += boxH + descGapY;
    }

    // NEW: Add GPS note below descriptions ONLY if accuracy is enabled
    if (includeAccuracy) {
      slide.addText("Positions are collected via GPS with the approximate accuracy shown in square brackets", {
        x: sideX + innerPadX,
        y: yCursor,
        w: innerW,
        h: 0.3,
        fontSize: 7,
        color: textGrey,
        align: 'left',
        valign: 'top'
      });
      yCursor += 0.3;
    }

    // --- Bottom 50% section (Logo and Footer Fields) ---
    
    // Helper to calc height for footer fields (uses charsPerLine/lineHeight from descriptions logic)
    const calcFieldH = (val) => {
      const len = (val || '').length;
      if (len === 0) return footerBoxH;
      const lines = Math.ceil(len / charsPerLine);
      // Expand if text wraps (approx > 1 line). 0.27 is base.
      return Math.max(footerBoxH, (lines * lineHeight) + boxPadding);
    };

    const hClient = calcFieldH(client);
    const hProject = calcFieldH(project);
    const hCollection = calcFieldH(collection);
    const hPhotographer = calcFieldH(photographer);

    // Calculate total footer height dynamically
    const getBlockH = (boxH) => footerLabelH + labelBoxGap + boxH + footerGapY;
    
    const totalFooterH = (logoBlockH + postLogoGap) 
                       + getBlockH(hClient) 
                       + getBlockH(hProject) 
                       + getBlockH(hCollection) 
                       + getBlockH(hPhotographer);

    // Target start Y: Bottom of panel minus page number space (approx 0.5) minus visual height
    // (visual height is totalFooterH minus the trailing gap from the last field)
    const targetFooterStartY = (panelTopY + panelH) - 0.5 - (totalFooterH - footerGapY);
    
    // Use the calculated bottom-aligned Y, unless descriptions push it further down
    let footerCursor = Math.max(targetFooterStartY, yCursor + 0.1);

    // Logo
    if (logoDataUrl) {
      let w = innerW;
      let h = logoBlockH;
      // CHANGED: Maintain aspect ratio if known to prevent stretching
      if (logoRatio) {
        h = w / logoRatio;
        if (h > logoBlockH) {
          h = logoBlockH;
          w = h * logoRatio;
        }
      }
      slide.addImage({ data: logoDataUrl, x: sideX + innerPadX, y: footerCursor, w: w, h: h });
    } else {
      slide.addText('BROWNFIELD\nSOLUTIONS', { x: sideX + innerPadX, y: footerCursor + 0.1, w: innerW, h: logoBlockH, fontSize: 12, bold: true, color: textGrey, align: 'left', valign: 'top' });
    }
    footerCursor += logoBlockH + postLogoGap;

    // Footer Fields
    function drawFooterField(label, value, height) {
      slide.addText(label, { x: sideX + innerPadX, y: footerCursor, w: innerW, h: footerLabelH, fontSize: labelFontSize, bold: true, color: textGrey, align: 'left', valign: 'top' });
      const boxY = footerCursor + footerLabelH + labelBoxGap;
      
      // CHANGED: Use addText with shape property so text is part of the box
      slide.addText(value || '', {
        shape: pptx.ShapeType.rect,
        x: sideX + innerPadX,
        y: boxY,
        w: innerW,
        h: height,
        fill: { color: 'FFFFFF' },
        line: { color: borderBlue },
        color: textGrey,
        fontSize: fieldFontSize,
        align: 'left',
        valign: 'top',
        inset: 0.05
      });

      footerCursor += footerLabelH + labelBoxGap + height + footerGapY;
    }

    // CHANGED LABELS FOR EXPORT FOOTER
    drawFooterField('CLIENT', client || '', hClient);
    drawFooterField('JOB NO.', project || '', hProject);
    drawFooterField('JOB NAME', collection || '', hCollection);
    drawFooterField('PHOTOBOARD TITLE', photographer || '', hPhotographer);

    // Page number (remains at the absolute bottom of the panel)
    slide.addText(`Page ${pageNumber}`, { x: sideX, y: panelTopY + panelH - 0.3, w: sideW - 0.1, h: 0.2, fontSize: 8, color: textGrey, align: 'right' });
   }

  const activeSession = sessions[activeSessionId] || {};
  for(const group of groups){
    slideIndex++;
    const slide = pptx.addSlide();

    // Background
    try{ slide.addShape(pptx.ShapeType.rect, { x:0, y:0, w:slideW, h:slideH, fill:{ color:'FFFFFF' } }); }catch(e){}

    // Right-hand panel background (keep panel background creation for compatibility)
    const sideX = slideW - margin - sideW;
    try{ slide.addShape(pptx.ShapeType.rect, { x: sideX, y: margin, w: sideW, h: contentH, fill:{ color: lightGrey } }); }catch(e){}

    // Add images to the slide
    group.forEach((item, idx) => {
      const r = Math.floor(idx / grid.cols);
      const c = idx % grid.cols;
      const cellX = margin + c * cellW;
      const cellY = margin + r * cellH;

      // Reserve space for text below image (e.g., 20% of cellH for text)
      const maxImageH = cellH * 0.8;
      
      // Calculate scaled image size to fit within cellW and maxImageH, preserving aspect ratio
      const imgAspect = item.w / item.h;
      let imgW = cellW;
      let imgH = imgW / imgAspect;
      
      // Fit to height constraint
      if (imgH > maxImageH) {
        imgH = maxImageH;
        imgW = imgH * imgAspect;
      }
      // Fit to width constraint (safety check)
      if (imgW > cellW) {
        imgW = cellW;
        imgH = imgW / imgAspect;
      }

      // Center the image horizontally
      const imgX = cellX + (cellW - imgW) / 2;
      
      // CHANGED: Center the image vertically within the allocated image area
      // This ensures portrait images float in the middle rather than sticking to the top
      const imgY = cellY + (maxImageH - imgH) / 2;
      
      try {
        slide.addImage({ data: item.dataURL, x: imgX, y: imgY, w: imgW, h: imgH });
      } catch (e) {
        console.warn('Failed to add image to slide', e);
      }

      // --- NEW caption logic: two lines (Photo + timestamp, then BNG/coords) ---
      globalPhotoIndex++;
      const dt = item.whenISO ? new Date(item.whenISO) : (item.created ? new Date(item.created) : new Date());
      // Locale-friendly compact timestamp (DD/MM/YYYY HH:MM)
      const ts = dt.toLocaleString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      }).replace(',', '');

      // Line 1: Photo number + optional timestamp + optional photographer initials
      let line1 = `Photo ${globalPhotoIndex}`;
      if (includeTimestamp) {
        line1 += ` â€“ ${ts}`;
        if (includePhotographer && photographerInitials) {
          line1 += ` â€“ ${photographerInitials}`;
        }
      }

      // Line 2 (position + optional accuracy)
      let line2 = '';
      if (item.gps && includePosition) {
        if (typeof item.gps.bngE !== 'undefined') {
          line2 = `BNG: E ${item.gps.bngE} N ${item.gps.bngN}`;
        } else if (typeof item.gps.lat === 'number' && typeof item.gps.lon === 'number') {
          line2 = `Lat ${item.gps.lat.toFixed(6)}, Lon ${item.gps.lon.toFixed(6)}`;
        }
        if (includeAccuracy && typeof item.gps.accuracy === 'number' && !isNaN(item.gps.accuracy)) {
          line2 += ` [â‰ˆ${Math.round(item.gps.accuracy)} m]`;
        }
      } else if (item.gps && !includePosition && includeAccuracy &&
                 typeof item.gps.accuracy === 'number' && !isNaN(item.gps.accuracy)) {
        line2 = `[â‰ˆ${Math.round(item.gps.accuracy)} m]`;
      }

      const captionText = line2 ? `${line1}\n${line2}` : line1;

      // Calculate text position relative to the actual image position
      const textY = imgY + imgH + 0.05;
      // Ensure text box doesn't exceed cell bounds
      const textH = Math.max(0.3, (cellY + cellH) - textY);

      slide.addText(captionText, {
        x: cellX + 0.05,
        y: textY,
        w: cellW - 0.1,
        h: textH,
        fontSize: 8,
        color: textGrey,
        align: 'center',
        valign: 'top'
      });
    });

    // Build descItems for this slide using the sequential globalPhotoIndex.
    // globalPhotoIndex was incremented while adding images above.
    const startNum = Math.max(1, globalPhotoIndex - group.length + 1);
    const descItems = group.map((item, idx) => ({
      num: startNum + idx,
      text: (item.desc || '').replace(/\r?\n/g, ' ')
    }));

    // Draw the entire right panel using the helper (logo, desc rows, footer fields, page number)
    addRightPanel(slide, {
      pptx,
      sideX,
      sideW,
      panelTopY: margin,
      panelH: contentH,
      textGrey,
      borderBlue: blueBar,
      panelFill: lightGrey,
      logoDataUrl,
      logoRatio, // NEW: Pass ratio
      pageNumber: slideIndex,
      descItems,
      // CHANGED: Force uppercase for project details
      client:       (activeSession.client || '').toUpperCase(),
      project:      (activeSession.project || '').toUpperCase(),
      collection:   (activeSession.name || '').toUpperCase(),
      photographer: (activeSession.photographer || '').toUpperCase(),
      includeAccuracy // NEW: pass the flag
    });

    // Slide number bottom-right outside panel is now handled by addRightPanel; if you still
    // want an extra page text outside, keep previous call (optional).
  }

  // Write blob and ensure PPTX MIME
  try{
    const rawBlob = await pptx.write('blob');
    const pptxMime = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';

    let outBlob = rawBlob;
    try{ if(!rawBlob.type || !rawBlob.type.includes('presentation')) outBlob = new Blob([rawBlob], { type: pptxMime }); }catch(e){ outBlob = rawBlob; }
    
    // NEW: If we have a directory handle, save directly to the file system.
    if (dirHandle && (await dirHandle.queryPermission({ mode: 'readwrite' })) === 'granted') {
      try {
        const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(outBlob);
        await writable.close();
        alert(`Successfully saved "${fileName}" to your chosen directory.`);
        return null; // Indicate that download is not needed
      } catch (err) {
        console.error('Failed to save file directly:', err);
        alert(`Failed to save to directory. Falling back to download.\nError: ${err.message}`);
        // Fall through to return blob for normal download
      }
    }
    
    return outBlob;
  }catch(err){
    console.warn('pptx write(blob) failed, trying fallback writeFile/save', err);
    try{
      const name = fileName || `evidence_${new Date().toISOString().slice(0,10)}_${layoutSel.value}ppA4.pptx`;
      if(typeof pptx.writeFile === 'function'){ await pptx.writeFile({ fileName: name }); return null; }
      else if(typeof pptx.save === 'function'){ await pptx.save(name); return null; }
      else throw err;
    }catch(e){ console.error('pptx fallback failed', e); throw e; }
  }
}
/* local downloads for manual export */
btnExportPPTX.addEventListener('click', async ()=>{
  // NEW: Warn about missing logo if not installed
  if (!computeInstalled()) {
    if (!confirm("Warning: When running in the browser (not installed), the company logo may not be included in the PowerPoint export due to browser security restrictions.\n\nDo you want to continue?")) {
      return;
    }
  }

  try {
    const fileName = `evidence_${new Date().toISOString().slice(0,10)}_${layoutSel.value}ppA4.pptx`;
    const blob = await buildPPTXBlob(fileName);
    if(!blob) return; // fallback handled download
    const a=document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = fileName;
    a.click();
  } catch (err) {
    alert('PPTX export failed: ' + err.message);
    console.error('PPTX export error:', err);
  }
});
</script>

<script>
/* ---------- Session Manager (clean implementation) ---------------- */
const sessions = {};           // id -> session object
let activeSessionId = null;

// NEW: Helper to save current global state into the session object
async function saveGlobalsToSession(id) {
  if (!id || !sessions[id]) return;
  const s = sessions[id];
  
  // Sync state to session object, stripping transient UI props
  s.items = state.items.map(i => {
    const clean = { ...i };
    delete clean._preview;
    delete clean._loading;
    delete clean._needsPreview;
    return clean;
  });
  
  s.client = state.client;
  s.project = state.project;
  s.photographer = state.photographer;
  s.photographerInitials = state.photographerInitials;
  
  // Ensure title is synced if this is the active session
  if (id === activeSessionId && collectionTitleInput) {
    s.name = collectionTitleInput.value.trim() || s.name;
  }

  await persistSession(s);
}

async function persistSession(session) {
  // ensure session has an id
  if (!session || !session.id) throw new Error('Invalid session');
  await idbAddSession(session);
}

async function createNewSession(fromData = null) {
  const id = Date.now(); // CHANGED: Use numeric ID to play nice with autoIncrement
  const name = fromData?.name || `Collection ${new Date().toLocaleString()}`;
  
  const newSession = {
    id,
    name,
    client: fromData?.client || '',
    project: fromData?.project || '',
    photographer: fromData?.photographer || '',
    photographerInitials: fromData?.photographerInitials || '',
    items: fromData?.items ? fromData.items.slice() : []
  };
  sessions[id] = newSession;
  await persistSession(newSession);
  await activateSession(id);
  return id;
}

async function importSession(data) {
  const id = Date.now(); // CHANGED: Use numeric ID
  const name = `${data.name || 'Untitled'} (Imported)`;

  // Ensure items array exists and normalise them
  const items = Array.isArray(data.items) 
    ? data.items.map(i => normaliseLegacyItem({ ...i })) 
    : [];

  // Construct the session object
  const newSession = {
    id,
    name,
    created: Date.now(),
    items: items, // Contains the dataURL and metadata
    client: data.client || '',
    project: data.project || '',
    photographer: data.photographer || '',
    photographerInitials: data.photographerInitials || ''
  };

  // 1. INJECT INTO MEMORY
  sessions[id] = newSession;
  
  // 2. INJECT INTO INDEXEDDB
  await idbAddSession(newSession);
  
  // 3. TRIGGER UI UPDATE
  await activateSession(id);
  
  alert(`Imported "${name}" with ${items.length} items.`);
}

async function activateSession(id) {
  if (!id || !sessions[id] || id === activeSessionId) return;
  
  // Persist current session first before switching
  if (activeSessionId && sessions[activeSessionId]) {
    saveGlobalsToSession(activeSessionId);
  }
  
  await loadSessionToGlobals(id);
}

async function loadSessionToGlobals(id) {
  if (!id || !sessions[id]) return;
  const s = sessions[id];
  activeSessionId = id;

  // Copy items to global state
  state.items = s.items ? s.items.map(i => ({ ...i })) : [];
  
  // Populate text inputs
  state.client = s.client || '';
state.project = s.project || '';
state.photographer = s.photographer || '';
state.photographerInitials = s.photographerInitials || '';

collectionTitleInput.value = s.name || '';
clientNameInput.value = state.client;
projectTitleInput.value = state.project;
photographerNameInput.value = state.photographer;
photographerInitialsInput.value = state.photographerInitials;

  // PREPARE FOR UI: Mark items for lazy loading
  state.items.forEach(item => {
    if (item.dataURL && !item._preview) {
      item._needsPreview = true; // This triggers createPreviewCanvas() in renderGallery
    }
  });

  // UPDATE UI
  renderGallery();   // Re-draws the grid of photos
  renderSessions();  // Updates the sidebar list
}

function renderSessions() {
  const listEl = document.getElementById('collectionsList');
  if (!listEl) return;
  listEl.innerHTML = '';

  Object.values(sessions).forEach(s => {
    const li = document.createElement('li');
    li.className = 'session-tab' + (s.id == activeSessionId ? ' active' : ''); // CHANGED: Loose equality for ID match

    const albumBtn = document.createElement('button');
    albumBtn.type = 'button';
    albumBtn.className = 'album-btn';
    albumBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="5" width="18" height="14" rx="2"></rect><path d="M7 11h4l1.5-2 4 5"></path><circle cx="9" cy="14.5" r="2.1"></circle></svg>`;
    if (s.id == activeSessionId) { // CHANGED: Loose equality
      albumBtn.classList.add('active');
      albumBtn.title = 'Current collection';
    } else {
      albumBtn.title = 'Set as current collection';
    }
    albumBtn.addEventListener('click', async ev => {
      ev.stopPropagation();
      if (s.id != activeSessionId) await activateSession(s.id); // CHANGED: Loose equality
    });

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = s.name || '(untitled)';
    nameInput.className = 'tab';
    nameInput.style.flex = '1'; // Allow it to grow
    nameInput.title = 'Edit collection name';
    nameInput.addEventListener('change', async (ev) => {
      s.name = nameInput.value.trim() || s.name;
      await persistSession(s);
      if (s.id == activeSessionId) collectionTitleInput.value = s.name; // CHANGED: Loose equality
      renderSessions();
    });
    nameInput.addEventListener('click', ev => ev.stopPropagation());

    // NEW: Action buttons container (for export)
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'collection-actions';

    const exportBtn = document.createElement('button');
    exportBtn.type = 'button';
    exportBtn.className = 'btn';
    exportBtn.title = 'Export this collection to JSON';
    exportBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-width="1.8" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>`;
    exportBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      handleExportCollection(s.id);
    });

    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'close';
    closeBtn.innerHTML = '&times;';
    closeBtn.title = 'Delete collection';
    closeBtn.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      const hasData = s.items && s.items.length > 0;
      const promptMsg = hasData ? 'Delete this collection and all its photos? This cannot be undone.' : 'Delete this empty collection?';
      if (!confirm(promptMsg)) return;
      // delete from memory and IDB
      delete sessions[s.id];
      await idbDeleteSession(s.id);
      // if it was active, pick another or create default
      if (activeSessionId == s.id) { // CHANGED: Loose equality
        const keys = Object.keys(sessions);
        if (keys.length) await activateSession(keys[0]);
        else await createNewSession();
      } else {
        renderSessions();
      }
    });

    li.addEventListener('click', () => { activateSession(s.id); });

    li.appendChild(albumBtn);
    li.appendChild(nameInput);
    
    actionsDiv.appendChild(exportBtn);
    li.appendChild(actionsDiv);

    li.appendChild(closeBtn);
    listEl.appendChild(li);
  });

  // Emphasised header summary with album icon that opens Collections panel
  const summary = document.getElementById('tabsSummary');
  if (summary) {
    const name = sessions[activeSessionId]?.name || '';
    summary.innerHTML = name
      ? `<button id="activeCollectionChip" class="collection-chip" title="Open collections">
             <svg viewBox="0 0 24 24" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
               <rect x="3" y="5" width="18" height="14" rx="2"></rect>
               <path d="M7 11h4l1.5-2 4 5"></path>
               <circle cx="9" cy="14.5" r="2.1"></circle>
             </svg>
             <span>${escapeHTML(name)}</span>
           </button>`
        : '';
      const chip = document.getElementById('activeCollectionChip');
      if (chip) {
        chip.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          // open Collections panel
          openCollectionsPanel?.();
        });
      }
    }
  }

  async function loadPersistedSessions() {
    // read all sessions from indexeddb
    const arr = await idbAllSessions();
    if (Array.isArray(arr) && arr.length) {
      arr.forEach(s => { sessions[s.id] = s; }); // CHANGED: Use raw ID (Number)
      // pick first session as active
      const firstId = arr[0].id; // CHANGED: Use raw ID
      await activateSession(firstId);
    } else {
      // create default session and activate it
      await createNewSession({ name: 'Default Collection' });
    }
    renderSessions();
  }

  /* Wire session UI controls (Collections panel new/close already wired elsewhere) */
  const collectionsPanel = document.getElementById('collections');
  const collectionsClose = document.getElementById('collectionsClose');
  const newCollectionBtn = document.getElementById('newCollectionBtn');
  // NEW: Import button refs
  const importCollectionBtn = document.getElementById('importCollectionBtn');
  const importCollectionInput = document.getElementById('importCollectionInput');

  if (collectionsClose) {
    collectionsClose.addEventListener('click', () => {
      collectionsPanel.classList.remove('open');
      collectionsPanel.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('collections-open');
    });
  }
  if (newCollectionBtn) {
    newCollectionBtn.addEventListener('click', async () => {
      await createNewSession();
      collectionsPanel.classList.remove('open');
      collectionsPanel.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('collections-open');
      collectionTitleInput.focus();
    });
  }

  /* ensure global save on unload */
  window.addEventListener('beforeunload', () => { if (activeSessionId) saveGlobalsToSession(activeSessionId); });

  /* ensure sessions load once DOM is ready (mobile reliable) */
  document.addEventListener('DOMContentLoaded', () => {
    loadPersistedSessions().catch(err => console.error('loadPersistedSessions failed', err));
  });
</script>

<script>
// Save client, project title, and photographer to state on input change
clientNameInput.addEventListener('input', () => {
  state.client = (clientNameInput.value || '').trim();
  if (activeSessionId && sessions[activeSessionId]) {
    sessions[activeSessionId].client = state.client;
    persistSession(sessions[activeSessionId]).catch(() => {});
  }
});

projectTitleInput.addEventListener('input', () => {
  state.project = (projectTitleInput.value || '').trim();
  if (activeSessionId && sessions[activeSessionId]) {
    sessions[activeSessionId].project = state.project;
    persistSession(sessions[activeSessionId]).catch(() => {});
  }
});

photographerNameInput.addEventListener('input', () => {
  state.photographer = (photographerNameInput.value || '').trim();
  if (activeSessionId && sessions[activeSessionId]) {
    sessions[activeSessionId].photographer = state.photographer;
    persistSession(sessions[activeSessionId]).catch(() => {});
  }
});

collectionTitleInput.addEventListener('input', () => {
  const name = (collectionTitleInput.value || '').trim();
  if (activeSessionId && sessions[activeSessionId]) {
    sessions[activeSessionId].name = name || sessions[activeSessionId].name;
    persistSession(sessions[activeSessionId]).catch(() => {});
    // update the sessions UI to reflect the new name
    renderSessions();
  }
});

// NEW: photographer initials input persistence
photographerInitialsInput.addEventListener('input', () => {
  state.photographerInitials = (photographerInitialsInput.value || '').trim();
  if (activeSessionId && sessions[activeSessionId]) {
    sessions[activeSessionId].photographerInitials = state.photographerInitials;
    persistSession(sessions[activeSessionId]).catch(() => {});
  }
});

// NEW: Import/Export handlers
async function handleExportCollection(sessionId) {
  const session = sessions[sessionId];
  if (!session) {
    alert('Collection not found.');
    return;
  }
  // Ensure the latest data is in the session object before exporting
  if (sessionId === activeSessionId) {
    saveGlobalsToSession(sessionId);
  }
  const sessionData = sessions[sessionId]; // re-fetch after save
  const jsonString = JSON.stringify(sessionData, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const safeName = (sessionData.name || 'untitled').replace(/[^a-z0-9]/gi, '_').toLowerCase();
  a.download = `collection-export-${safeName}-${new Date().toISOString().slice(0,10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function handleImportCollection(event) {
  const file = event.target.files?.[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async (e) => {
    try {
      const json = e.target.result;
      const data = JSON.parse(json);
      
      // Basic validation
      if (!data || typeof data !== 'object') throw new Error('Invalid JSON file');
      
      await importSession(data);
      
      // Reset input so the same file can be selected again if needed
      event.target.value = '';
    } catch (err) {
      console.error('Import failed', err);
      alert('Failed to import collection: ' + err.message);
    }
  };
  reader.readAsText(file);
}

// NEW: Wire up import functionality (placed here to ensure handleImportCollection is defined)
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('importCollectionBtn');
  const inp = document.getElementById('importCollectionInput');
  if (btn && inp) {
    btn.addEventListener('click', () => inp.click());
    inp.addEventListener('change', handleImportCollection);
  }
});
</script>

<footer class="app-footer">
  <div class="wrap">
    <span id="appStatusFooter" class="footer-chip not-installed">
      <span class="dot" aria-hidden="true"></span>
      <span class="txt">v1.2 â€¢ Not installed</span>
    </span>
  </div>
</footer>

<script>
  // App version and install status footer updater
  const APP_VERSION = 'v1.2';
  let deferredPrompt = null; // Store the install prompt event

  function computeInstalled() {
    return (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches)
      || (navigator.standalone === true); // iOS Safari
  }

  function updateInstallStatus() {
    const el = document.getElementById('appStatusFooter');
    if (!el) return;
    const installed = computeInstalled();
    
    // Reset classes
    el.classList.remove('installed', 'not-installed', 'install-ready');
    
    const txt = el.querySelector('.txt');
    if (!txt) return;

    if (installed) {
      el.classList.add('installed');
      txt.textContent = `${APP_VERSION} â€¢ Installed`;
      el.onclick = null;
      el.style.cursor = 'default';
    } else if (deferredPrompt) {
      // If not installed and we have a prompt, make it an install button
      el.classList.add('install-ready');
      txt.textContent = `${APP_VERSION} â€¢ Install App`;
      el.onclick = async () => {
        if (deferredPrompt) {
          deferredPrompt.prompt();
          const { outcome } = await deferredPrompt.userChoice;
          if (outcome === 'accepted') {
            deferredPrompt = null;
          }
          updateInstallStatus();
        }
      };
    } else {
      // Not installed, no prompt available
      el.classList.add('not-installed');
      txt.textContent = `${APP_VERSION} â€¢ Not installed`;
      el.onclick = null;
      el.style.cursor = 'default';
    }
  }

  // Capture the install prompt
  window.addEventListener('beforeinstallprompt', (e) => {
    console.log('Install prompt captured'); // Check console if this appears
    e.preventDefault();
    deferredPrompt = e;
    updateInstallStatus();
  });

  window.addEventListener('DOMContentLoaded', updateInstallStatus);
  window.addEventListener('appinstalled', () => {
    deferredPrompt = null;
    updateInstallStatus();
  });
  
  try {
    const dm = window.matchMedia && window.matchMedia('(display-mode: standalone)');
    dm && dm.addEventListener && dm.addEventListener('change', updateInstallStatus);
  } catch (_) {}

  // Theme toggle logic
  const btnTheme = document.getElementById('btnTheme');
  function setTheme(isLight) {
    document.documentElement.setAttribute('data-theme', isLight ? 'light' : 'dark');
    if(btnTheme) btnTheme.textContent = isLight ? 'â˜€ï¸' : 'ðŸŒ™';
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
    const meta = document.querySelector('meta[name="theme-color"]');
    if(meta) meta.setAttribute('content', isLight ? '#f8fafc' : '#0f172a');
  }
  btnTheme?.addEventListener('click', () => {
    const isLight = document.documentElement.getAttribute('data-theme') === 'light';
    setTheme(!isLight);
  });
  // Init theme
  if (localStorage.getItem('theme') === 'light') setTheme(true);
</script>
</body>
</html>
