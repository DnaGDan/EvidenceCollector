<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Site Evidence Capture (PWA)</title> <!-- CHANGED: removed v1.2 -->
<meta name="theme-color" content="#0f172a" />
<!-- Favicons from ./icons -->
<link rel="icon" type="image/png" sizes="32x32" href="./icons/favicon-32.png" />
<link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
<link rel="apple-touch-icon" sizes="180x180" href="./icons/apple-touch-icon.png" />
<link rel="manifest" href="./manifest.webmanifest" />
<!-- removed static manifest link so dynamic manifest below is used -->
<style>
  :root{
    --bg:#0f172a;--card:#111827;--muted:#1f2937;--text:#e5e7eb;--accent:#22c55e;--danger:#ef4444;--warn:#f59e0b;
    --border:#333; --header-bg:rgba(15,23,42,.95); --input-bg:#111827; --thumb-bg:#0b1220;
  }
  [data-theme="light"]{
    --bg:#f8fafc;--card:#ffffff;--muted:#f1f5f9;--text:#0f172a;--accent:#16a34a;--danger:#ef4444;--warn:#f59e0b;
    --border:#cbd5e1; --header-bg:rgba(255,255,255,.95); --input-bg:#ffffff; --thumb-bg:#e2e8f0;
  }
  *{box-sizing:border-box}
  /* CHANGED: Added overscroll-behavior-y:none to prevent pull-to-refresh */
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,Segoe UI,Roboto,Helvetica,Arial;overscroll-behavior-y:none}
  header{position:sticky;top:0;z-index:10;background:var(--header-bg);backdrop-filter:blur(6px);border-bottom:1px solid var(--border)}
  .wrap{max-width:1040px;margin:0 auto;padding:16px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;width:100%}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px}
  button,.btn{cursor:pointer;border:1px solid var(--border);background:var(--muted);color:var(--text);padding:10px 14px;border-radius:12px}
  button:disabled{opacity:.5;cursor:not-allowed}
  .primary{background:#16a34a;border-color:#15803d}
  .danger{background:#991b1b;border-color:#7f1d1d}
  .warn{background:#b45309;border-color:#92400e}
  /* CHANGED: Added input[type="datetime-local"] to selector so it inherits theme colors */
  select,input[type="number"],input[type="text"],input[type="datetime-local"]{background:var(--input-bg);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:8px}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
  
  /* NEW: Zoom levels - Adjusted for distinct steps */
  /* Default (Zoom 0): minmax(240px, 1fr) -> Large cards */
  /* Zoom 1: Medium cards */
  .grid.zoom-1 { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
  /* Zoom 2: Small cards (dense) */
  .grid.zoom-2 { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
  .grid.zoom-2 .meta { font-size: 10px; line-height: 1.2; }
  .grid.zoom-2 .badge { display: none; }

  /* NEW: Floating Zoom Button - Fixed to bottom-left to avoid layout shift issues */
  .floating-zoom {
    position: fixed;
    left: 16px;
    bottom: 88px; /* Positioned above the footer area */
    z-index: 50;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 999px;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    cursor: pointer;
    color: var(--text);
    transition: all 0.2s ease;
  }
  .floating-zoom:hover { transform: scale(1.1); background: var(--muted); }
  .floating-zoom:active { transform: scale(0.95); }

  .thumb{position:relative;border-radius:12px;overflow:hidden;border:1px solid var(--border);background:var(--thumb-bg)}
  .thumb canvas{width:100%;height:auto;display:block}
  .meta{padding:8px 10px;border-top:1px solid var(--border);font-size:14px}
  .meta small{opacity:.7}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#0b4; font-size:12px; margin-left:6px}
  .footer{opacity:.8;font-size:13px}
  dialog{border:none;border-radius:16px;padding:0;max-width:520px;width:90%;background:var(--thumb-bg);color:var(--text)}
  dialog header{padding:16px;border-bottom:1px solid var(--border)}
  dialog .content{padding:16px}
  dialog .actions{display:flex;gap:10px;justify-content:flex-end;padding:16px;border-top:1px solid var(--border)}
  .count{font-variant-numeric: tabular-nums}
  .hint{opacity:.7;font-size:12px}

  /* Slide-out panel for sessions */
  .section {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    transition: transform 0.28s ease; /* Smooth slide-in/out */
    z-index: 1000;
    box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
    border-right: 1px solid var(--border);
    overflow: auto;
    background: var(--card);
    padding: 16px;
    transform: translateX(-110%); /* Hidden by default */
  }
  .section.open {
    transform: translateX(0); /* Slide in when open */
  }
  .tab-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .tab {
    flex: 1;
    padding: 10px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--card);
    color: var(--text);
    cursor: pointer;
    transition: background .2s;
  }
  .tab:hover {
    background: #1f2937;
  }
  .tab.active {
    background: #15803d;
    color: #fff;
  }
  .close {
    background: none;
    border: none;
    color: #ef4444;
    font-size: 18px;
    cursor: pointer;
  }

  /* Session Manager styles */
  .sessions-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    background: var(--card);
    color: var(--text);
    border-right: 1px solid var(--border);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
    padding: 16px;
    overflow-y: auto;
    z-index: 1000;
    transform: translateX(-110%); /* Hidden by default */
    transition: transform 0.28s ease;
  }
  .sessions-panel.open {
    transform: translateX(0); /* Visible when open */
  }
  body.sessions-open #sessionsToggle {
    opacity: 1; /* Ensure the button is fully visible */
    pointer-events: auto; /* Allow interaction */
  }
  .sessions-header-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .sessions-title {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
  }
  .flex-spacer {
    flex: 1;
  }
  .sessions-hint {
    margin-top: 6px;
    font-size: 0.9rem;
    color: var(--muted, #8b93b8);
  }
  .sessions-new-btn-row {
    margin-top: 8px;
  }
  .sessions-list {
    list-style: none;
    padding: 0;
    margin-top: 10px;
  }
  .session-tab {
    display: flex; /* CHANGED from inline-flex */
    align-items: center;
    justify-content: space-between;
    width: 100%;
    gap: 8px;
    padding: 8px 10px;
    margin-bottom: 8px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: var(--card);
    color: var(--text);
    font-weight: 600;
    text-align: left;
    cursor: pointer;
  }
  .session-tab.active {
    outline: 3px solid var(--focus-ring, #7aa9f6);
    outline-offset: 0;
  }
  /* NEW: Group actions to prevent squashing */
  .session-actions {
    display: flex;
    align-items: center;
    gap: 2px;
    flex-shrink: 0; /* Prevent buttons from shrinking */
    margin-left: auto;
  }
  /* NEW: Unified style for session action buttons */
  .session-actions .btn-action {
    background: transparent;
    border: 1px solid transparent;
    color: var(--muted, #8b93b8);
    cursor: pointer;
    padding: 6px;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: all 0.2s;
  }
  .session-actions .btn-action:hover {
    background: var(--muted);
    color: var(--text);
    border-color: #333;
  }
  .session-actions .btn-action.delete:hover {
    background: rgba(239, 68, 68, 0.15);
    color: #ef4444;
    border-color: rgba(239, 68, 68, 0.3);
  }
  .session-actions .btn-action svg {
    width: 18px;
    height: 18px;
    stroke: currentColor;
    fill: none;
    pointer-events: none;
  }
  
  /* NEW: Input styling to play nice with flex */
  .session-tab .tab-name {
    flex: 1;
    min-width: 0; /* Allow shrinking */
    margin: 0 4px;
    background: transparent; /* Blend in */
    border: 1px solid transparent;
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--text);
  }
  .session-tab .tab-name:focus {
    background: var(--input-bg);
    border-color: var(--border);
  }
  .session-tab .tab-name:hover {
    border-color: var(--border); /* Hint it's editable */
  }
  
  .session-summary-chip {
    display: inline-block;
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--muted);
    border: 1px solid var(--border);
    background: rgba(127, 146, 190, 0.08);
    border-radius: 999px;
    padding: 2px 8px;
    max-width: 40vw;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Update styles for the renamed Collections panel */
  .collections-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    background: var(--card);
    color: var(--text);
    border-right: 1px solid var(--border);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
    padding: 16px;
    overflow-y: auto;
    z-index: 1000;
    transform: translateX(-110%); /* Hidden by default */
    transition: transform 0.28s ease;
  }
  .collections-panel.open {
    transform: translateX(0); /* Slide in when open */
  }
  /* body.collections-open #collectionsToggle {
    opacity: 1;
    pointer-events: auto;
  } */

  /* Collection Parameters slide-out (left) */
  .params-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: min(360px, 92vw);
    height: 100%;
    background: var(--card);
    color: var(--text);
    border-right: 1px solid var(--border);
    box-shadow: 8px 0 24px rgba(0,0,0,0.6);
    padding: 16px;
    transform: translateX(-110%);
    transition: transform 0.28s ease;
    z-index: 1200;
    overflow-y: auto;
  }
  .params-panel.open { transform: translateX(0); }
  .params-panel h3 { margin:0 0 8px; font-size:1rem; font-weight:600; }
  .params-panel .field { display:flex; flex-direction:column; gap:6px; margin-bottom:12px; }

  /* location button state colours */
  .btn.loc-on { background:#16a34a !important; border-color:#15803d !important; color:#fff; }
  .btn.loc-off { background:#991b1b !important; border-color:#7f1d1d !important; color:#fff; }

  /* make svg inside control inherit button foreground */
  .btn svg { vertical-align: middle; fill: none; stroke: currentColor; }

  /* icon-only button style (tight square for header icons) */
  .btn.icon-btn { width:40px; height:40px; padding:6px; display:inline-flex; align-items:center; justify-content:center; border-radius:10px; }

  /* export button: inline icon + label, slightly tighter */
  .btn.export { display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px; font-weight:600; }
  .btn.export svg { width:18px; height:18px; }

  /* group two buttons so they look related (export + settings) */
  .btn.group-left { border-top-right-radius:0; border-bottom-right-radius:0; margin-left:8px; }
  .btn.group-right { border-top-left-radius:0; border-bottom-left-radius:0; margin-left:0; border-left:1px solid rgba(0,0,0,0.25); }
  /* NEW: middle-group style for 3-button groups */
  .btn.group-mid { border-radius:0; margin-left:0; border-left:1px solid rgba(0,0,0,0.25); }

  /* keep grouped header buttons together on small screens */
  .btn-group {
    display: inline-flex;
    flex-wrap: nowrap;
    gap: 0;
    align-items: center;
    white-space: nowrap;
  }
  .btn-group .btn {
    flex: 0 0 auto; /* do not grow or shrink */
  }
  /* Header logo sizing (prevents huge rendering on mobile) */
  .brand-logo {
    height: 64px; /* CHANGED: was 32px */
    width: auto;
    margin-right: 12px;
    display: inline-block;
  }

  /* Album icon button in Collections list (restore visible strokes and active colour) */
  .album-btn {
    background: transparent;
    border: 0;
    padding: 0 4px 0 0;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
  }
  .album-btn svg {
    width: 20px;
    height: 20px;
    stroke: #a7acc4; /* light grey stroke on dark panel */
    fill: none;
    transition: stroke .2s, fill .2s;
  }
  .album-btn:hover svg { stroke: #e5e7eb; }
  .album-btn.active svg {
    stroke: var(--accent); /* #22c55e */
    fill: rgba(34,197,94,0.18);
  }

  /* header collection chip */
  .collection-chip {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 4px 10px;
    border-radius: 999px;
    background: rgba(34,197,94,0.12);
    border: 1px solid rgba(34,197,94,0.33);
    color: var(--text); /* CHANGED: use theme text color */
    font-weight: 700;
    cursor: pointer;
    user-select: none;
  }
  .collection-chip:hover {
    background: rgba(34,197,94,0.18);
    border-color: rgba(34,197,94,0.55);
  }
  .collection-chip svg {
    width: 16px;
    height: 16px;
    stroke: #22c55e;
    fill: rgba(34,197,94,0.15);
  }

  .app-footer {
    position: sticky;
    bottom: 0;
    background: var(--header-bg);
    border-top: 1px solid var(--border);
    z-index: 10;
    width: 100%;
  }
  .app-footer .wrap {
    padding: 10px 16px;
    font-size: 12px;
    opacity: .9;
    display: flex;
    justify-content: flex-start;
    align-items: center;
  }
  /* Footer status chip */
  .footer-chip {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 4px 10px;
    border-radius: 999px;
    background: rgba(148,163,184,0.12); /* slate-300-ish */
    border: 1px solid rgba(148,163,184,0.35);
    color: var(--text); /* CHANGED: use theme text color */
    font-weight: 600;
    white-space: nowrap;
  }
  .footer-chip .dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: #94a3b8; /* default grey */
    box-shadow: 0 0 0 2px rgba(148,163,184,0.25);
  }
  .footer-chip.installed {
    background: rgba(34,197,94,0.12);
    border-color: rgba(34,197,94,0.45);
    color: #d1fae5;
  }
  /* NEW: Light theme override for installed chip */
  [data-theme="light"] .footer-chip.installed {
    color: #14532d; /* CHANGED: Darker green (green-900) for better contrast */
    background: rgba(34,197,94,0.2);
    border-color: rgba(34,197,94,0.5);
  }
  .footer-chip.installed .dot {
    background: #22c55e;
    box-shadow: 0 0 0 3px rgba(34,197,94,0.2);
  }
  .footer-chip.not-installed {
    background: rgba(148,163,184,0.12);
    border-color: rgba(148,163,184,0.35);
    color: #e5e7eb;
  }
  /* NEW: Light theme override for not-installed chip */
  [data-theme="light"] .footer-chip.not-installed {
    color: #0f172a; /* Slate-900 */
    border-color: #94a3b8;
    background: rgba(148,163,184,0.25);
  }
  /* NEW: Distinct style for when install is available */
  .footer-chip.install-ready {
    background: rgba(37, 99, 235, 0.15); /* blue-600 */
    border-color: rgba(37, 99, 235, 0.4);
    color: #bfdbfe;
    cursor: pointer;
    animation: pulse-border 2s infinite;
  }
  @keyframes pulse-border {
    0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.4); }
    70% { box-shadow: 0 0 0 6px rgba(37, 99, 235, 0); }
    100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
  }

  /* Base action button (icon + label) */
  .btn.action {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 12px;
    font-weight: 600;
  }
  .btn.action svg { width: 18px; height: 18px; }

  /* Make capture group a full-width toolbar with tall, stacked buttons */
  /* REMOVED old #captureGroup styles */

  /* Small warning chip shown in header when location is OFF */
  .loc-warning {
    display: none;
    margin-left: 8px;
    padding: 2px 8px;
    border-radius: 999px;
    background: rgba(239,68,68,0.15); /* red-500 bg */
    border: 1px solid rgba(239,68,68,0.35);
    color: #fecaca; /* red-200 text */
    font-size: 12px;
    font-weight: 700;
    white-space: nowrap;
  }
  /* NEW: Light theme override for location warning */
  [data-theme="light"] .loc-warning {
    color: #991b1b;
    background: rgba(254, 202, 202, 0.5);
    border-color: #f87171;
  }
  /* NEW: Active state for location chip (Green) */
  .loc-warning.active {
    background: rgba(34,197,94,0.15);
    border-color: rgba(34,197,94,0.35);
    color: #bbf7d0;
  }
  [data-theme="light"] .loc-warning.active {
    color: #14532d;
    background: rgba(34,197,94,0.2);
    border-color: rgba(34,197,94,0.5);
  }

  /* NEW: Action button row styles */
  .button-row {
    display: flex;
    gap: 0.75rem;
    width: 100%;
  }
  .button-row .btn {
    flex: 1 1 0%;
    min-width: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.85rem 1rem;
    border-radius: 999px;
    border: none;
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--text); /* CHANGED: use theme text color */
    cursor: pointer;
    transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.15s;
  }
  .button-row .btn-photo {
    flex: 2; /* Two thirds of the space */
    color: #ffffff !important; /* CHANGED: Force white text for photo button */
  }
  .button-row .btn-params {
    flex: 1; /* One third of the space */
  }
  .button-row .btn .icon svg {
    width: 18px;
    height: 18px;
  }
  .button-row .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.4);
  }
  .button-row .btn:active {
    transform: translateY(1px);
    box-shadow: none;
    opacity: 0.9;
  }
  /* NEW: Header rows styling */
  .header-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 8px; /* Space between rows */
  }
  .header-row-1 {
    justify-content: space-between;
    overflow: hidden;
    max-height: 80px;
    margin-bottom: 8px;
    transition: opacity 0.3s ease, transform 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
  }
  .header-row-1.is-hidden {
    opacity: 0;
    transform: translateY(-16px);
    max-height: 0;
    margin-bottom: 0;
    pointer-events: none;
  }
  .header-row-2 .left-group {
    display: flex;
    align-items: center;
    gap: 8px; /* Space between button and chip */
  }
  .header-row-2 .right-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* NEW: floating actions bottom-right */
  .floating-actions {
    position: fixed;
    right: 24px;
    bottom: 24px;
    display: inline-flex;
    flex-direction: row;
    gap: 0;
    z-index: 60;
  }
  .floating-actions .btn-group {
    display: inline-flex;
    flex-wrap: nowrap;
  }
  .floating-actions .btn {
    box-shadow: 0 12px 24px rgba(0,0,0,0.35);
    border-radius: 999px;
    padding: 10px 16px;
  }
  /* override header spacing so the group joins tightly */
  .floating-actions .btn.group-left { margin-left: 0; }
  .floating-actions .btn svg { pointer-events: none; }
  @media (max-width: 640px) {
    .floating-actions { right: 16px; bottom: 16px; }
  }

  /* Added: delete button styling */
  .thumb .delete-btn {
    position:absolute;
    top:6px;
    right:6px;
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .delete-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .delete-btn:focus {
    outline:2px solid #f87171;
    outline-offset:2px;
  }
  .thumb .delete-btn svg {
    width:16px;
    height:16px;
    stroke:#f87171;
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }

  /* NEW: replace button styling (top-left) */
  .thumb .replace-btn {
    position:absolute;
    top:6px;
    left:6px;
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .replace-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .replace-btn:focus {
    outline:2px solid #22c55e;
    outline-offset:2px;
  }
  .thumb .replace-btn svg {
    width:16px;
    height:16px;
    stroke:#22c55e; /* accent */
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }

  /* NEW: rotate button styling (top-left, next to replace) */
  .thumb .rotate-btn {
    position:absolute;
    top:6px;
    left:42px; /* 6px + 30px width + 6px gap */
    width:30px;
    height:30px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    backdrop-filter:blur(3px);
    border:1px solid #444;
    border-radius:10px;
    cursor:pointer;
    padding:0;
    z-index:5;
  }
  .thumb .rotate-btn:hover {
    background:rgba(0,0,0,0.75);
    border-color:#555;
  }
  .thumb .rotate-btn:focus {
    outline:2px solid #3b82f6;
    outline-offset:2px;
  }
  .thumb .rotate-btn svg {
    width:16px;
    height:16px;
    stroke:#3b82f6;
    stroke-width:1.8;
    fill:none;
    pointer-events:none;
  }

  /* Empty gallery placeholder */
  .gallery-placeholder {
    grid-column: 1 / -1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 28px 16px;
    border: 1px dashed #334155;
    border-radius: 12px;
    color: #94a3b8;
    background: rgba(2, 6, 23, 0.35);
    text-align: center;
  }
  .gallery-placeholder svg {
    width: 36px;
    height: 36px;
    stroke: #64748b;
    fill: none;
  }
  .gallery-placeholder small { opacity: 0.8; }

  /* MODE STYLES: green (camera) / blue (gallery) */
  #btnSnap { position:relative; overflow:hidden; }
  #btnSnap.mode-camera {
    background:#16a34a !important;
    border-color:#15803d !important;
  }
  #btnSnap.mode-camera:hover { background:#18b152 !important; }
  #btnSnap.mode-gallery {
    background:#1d4ed8 !important;
    border-color:#1e40af !important;
  }
  #btnSnap.mode-gallery:hover { background:#235ae8 !important; }

  /* Long-press visual progress (leftâ†’right fade) */
  #btnSnap .press-progress {
    position:absolute;
    top:0; left:0;
    height:100%;
    width:0;
    background:linear-gradient(90deg,rgba(255,255,255,0.15),rgba(255,255,255,0.35));
    pointer-events:none;
  }
  #btnSnap.progressing .press-progress {
    animation: pressFill 1s linear forwards;
  }
  @keyframes pressFill {
    from { width:0; }
    to { width:100%; }
  }

  /* When mode changes flash subtle overlay */
  #btnSnap.mode-switch-flash::after {
    content:'';
    position:absolute; inset:0;
    background:radial-gradient(circle at 30% 50%, rgba(255,255,255,0.35), rgba(255,255,255,0));
    animation: flashFade .5s ease;
    pointer-events:none;
  }
  @keyframes flashFade { from { opacity:1; } to { opacity:0; } }

  .mode-hint { font-style: italic; }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <!-- Row 1: Logo left, title right -->
    <div class="header-row header-row-1">
      <div style="display:flex;align-items:center;font-weight:700;font-size:15px;letter-spacing:.2px">
        <img src="./brownfield_logo.png" alt="Brownfield Solutions" loading="lazy" class="brand-logo" />
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <button id="btnTheme" class="btn icon-btn" title="Toggle theme" aria-label="Toggle theme">ðŸŒ™</button>
        <img src="./icons/icon-512.png" alt="Site Evidence Capture" loading="lazy" style="height: 64px; width: auto;" />
      </div>
    </div>
    
    <!-- Row 2: Collection button + count chip left, location right -->
    <div class="header-row header-row-2">
      <div class="left-group">
        <div id="tabsSummary" style="font-weight: 500; opacity: 0.8;"></div>
        <span class="count-chip" id="count">0 items</span>
      </div>
      <div class="right-group">
        <span id="locWarning" class="loc-warning" role="status" aria-live="polite">Location OFF</span>
        <button id="btnEnableLoc" class="btn loc-off icon-btn" title="Enable location" aria-pressed="false" style="margin-right:0">
          <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 2C8.686 2 6 4.686 6 8c0 5.25 6 12 6 12s6-6.75 6-12c0-3.314-2.686-6-6-6z" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
            <circle cx="12" cy="8" r="2.2" stroke="currentColor" stroke-width="1.2" fill="none"/>
          </svg>
        </button>
      </div>
    </div>
  </div>
</header>

<main class="wrap" style="padding-top:14px;padding-bottom:72px">
  <section class="card">
    <div class="row">
      <input id="fileInput" type="file" accept="image/*,.heic,.HEIC" capture="environment" style="display:none" /> <!-- CHANGED: accept HEIC -->
      <!-- REPLACED: button group with new structure and styles -->
      <div class="button-row" id="captureGroup">
        <button id="btnSnap" class="btn btn-photo" title="Take or select photo" aria-label="Take or select photo" data-mode="camera">
          <span class="press-progress" aria-hidden="true"></span>
          <span class="icon">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M9 4l1.5-2h3L15 4h3a2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h3z"/>
              <circle cx="12" cy="12" r="3.25"/>
            </svg>
          </span>
          <span>Photo</span>
          <span class="mode-hint" id="captureModeHint">Camera</span>
        </button>
      
        <!-- Parameters -->
        <button id="paramsToggle" class="btn btn-params" title="Open collection parameters" aria-label="Open collection parameters">
          <span class="icon">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M9 3h6a2 2 0 012 2h1a2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V7a2 2 0 012-2h1a2 2 0 012-2z"/>
              <path d="M10 3h4v2h-4z"/>
              <path d="M9 10h6"/>
              <path d="M9 13h6"/>
              <path d="M9 16h4"/>
            </svg>
          </span>
          <span>Project Details</span>
        </button>
      </div>

      <!-- location control moved to header; status text removed (indicator is the icon colour) -->

      <!-- layout/orientation moved into Settings panel -->
      <input id="collectionTitle" type="hidden" value="Site Evidence Photos" />
    </div>

    <!-- New: Client, Project Title, and Photographer fields (moved to slide-out panel â€” keep hidden fields for compatibility) -->
    <div style="display:none;">
      <input id="clientName" type="hidden" value="" />
      <input id="projectTitle" type="hidden" value="" />
      <input id="photographerName" type="hidden" value="" />
    </div>

    <!-- Slide-out settings panel -->
    <div id="settingsPanel" style="position:fixed;right:-320px;top:0;width:320px;max-width:90vw;height:100%;background:var(--card);border-left:1px solid var(--border);padding:16px;box-shadow:-8px 0 24px rgba(0,0,0,.6);transition:right .25s ease;z-index:1200;">
      <!-- CHANGED: added header row with close button -->
      <div class="settings-header" style="display:flex;align-items:center;justify-content:space-between;margin:0 0 12px">
        <h3 style="margin:0">Export Settings</h3>
        <button id="btnCloseSettings" class="btn icon-btn" aria-label="Close settings" title="Close settings" style="width:36px;height:36px;padding:4px;display:flex;align-items:center;justify-content:center">&times;</button>
      </div>
      <div style="display:flex;flex-direction:column;gap:10px">
        
        <label>Layout:
          <select id="layout" style="width:100%">
            <option value="2">2 per A4 page</option>
            <option value="4" selected>4 per A4 page</option>
          </select>
        </label>
        <label>Orientation:
          <select id="orientation" style="width:100%">
            <option value="portrait">Portrait (A4)</option>
            <option value="landscape" selected>Landscape (A4)</option>
          </select>
        </label>
        
        <!-- NEW: Auto Sort Checkbox -->
        <div style="margin-top:8px;padding:8px;border:1px solid var(--border);border-radius:10px;background:rgba(0,0,0,0.1)">
          <label style="display:flex;align-items:center;gap:8px;font-size:13px;font-weight:600;cursor:pointer">
            <input id="chkAutoSort" type="checkbox" /> 
            Automatic Image Sorting
          </label>
          <small class="hint" style="display:block;margin-top:4px;line-height:1.3">
            Groups images by shape (Landscape/Portrait) to minimize white space gaps on pages.
          </small>
          
          <!-- NEW: No Mix Checkbox (Dependent on AutoSort) -->
          <div style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border)">
            <label id="lblNoMix" style="display:flex;align-items:center;gap:8px;font-size:13px;font-weight:600;cursor:pointer;opacity:0.5">
              <input id="chkNoMix" type="checkbox" disabled /> 
              Don't Mix Orientations
            </label>
            <small class="hint" style="display:block;margin-top:4px;line-height:1.3">
              Starts a new page when image orientation changes (prevents mixing Landscape/Portrait on one slide).
            </small>
          </div>
        </div>
        
        <!-- NEW: PPTX attribute toggles -->
        <div style="display:flex;flex-direction:column;gap:6px;margin-top:4px;padding:8px;border:1px solid var(--border);border-radius:10px;">
          <strong style="font-size:13px">PPTX Caption Attributes</strong>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrTimestamp" type="checkbox" checked /> Timestamp
          </label>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrPosition" type="checkbox" checked /> Position (BNG / Lat,Lon)
          </label>
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrAccuracy" type="checkbox" checked /> Accuracy (Â± m)
          </label>
          <!-- NEW: Photographer toggle (input removed from here) -->
          <label style="display:flex;align-items:center;gap:6px;font-size:12px">
            <input id="attrPhotographer" type="checkbox" checked /> Photographer initials
          </label>
        </div>
        <div style="margin-top:6px"><small class="hint">These affect exports (A4 sizing)</small></div>

        <!-- NEW: Confirm Export Button inside Settings -->
        <div style="margin-top:12px; padding-top:12px; border-top:1px solid var(--border)">
          <button id="btnConfirmExport" class="btn primary" style="width:100%; padding:12px; font-weight:bold; display:flex; align-items:center; justify-content:center; gap:8px;">
            <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
            Generate PowerPoint
          </button>
        </div>
      </div>
    </div>

    <!-- REMOVED: Footer text paragraph as requested -->
  </section>

  <section id="gallery" class="grid" style="margin-top:14px"></section>

  <!-- NEW: Bulk Upload Area -->
  <div style="margin-top: 32px; margin-bottom: 20px; text-align: center;">
    <input id="bulkInput" type="file" accept="image/*,.heic,.HEIC" multiple style="display:none" /> <!-- CHANGED: accept HEIC -->
    <button id="btnBulkUpload" class="btn" style="width: 100%; padding: 16px; border: 2px dashed #334155; background: rgba(15, 23, 42, 0.6); color: #94a3b8;">
      <div style="font-weight:600; font-size:1.1em; margin-bottom:4px;">+ Bulk Upload Photos</div>
      <div style="font-size:0.85em; opacity:0.8;">GPS metadata will be imported if available</div>
    </button>
  </div>
</main>

<!-- NEW: floating primary actions -->
<div class="floating-actions" role="region" aria-label="Primary actions">
  <span class="btn-group">
    <!-- CHANGED: Removed group-left class, removed btnSettings -->
    <button id="btnExportPPTX" class="btn danger export" title="Export Options" aria-label="Export Options">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" stroke="currentColor" stroke-width="1.2" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="4" width="18" height="14" rx="2" />
        <path d="M8 9h8M8 13h5" />
        <path d="M12 18v3" />
      </svg>
      <span>PPT Export</span>
    </button>
  </span>
</div>

<!-- NEW: Floating Zoom Button -->
<button id="btnZoom" class="floating-zoom" title="Change zoom level" aria-label="Change zoom level">
  <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="11" cy="11" r="8"></circle>
    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
    <line x1="11" y1="8" x2="11" y2="14"></line>
    <line x1="8" y1="11" x2="14" y2="11"></line>
  </svg>
</button>

<!-- Description dialog -->
<dialog id="descDialog">
  <header style="display:flex;justify-content:space-between;align-items:center">
    <strong>Add description</strong>
    <button id="btnUnlockMeta" type="button" class="btn icon-btn" title="Unlock metadata" style="width:32px;height:32px;padding:4px;display:none;border:none;background:transparent">
      <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
    </button>
  </header>
  <div class="content">
    <p style="margin:0 0 8px">Describe the evidence in one or two lines (who/what/where/why).</p>
    <textarea id="descText" rows="4" style="width:100%;resize:vertical;background:var(--input-bg);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px" placeholder="e.g., TP03: Sub-base compaction adjacent to gridline Câ€“D. Roller: Bomag BW120."></textarea>
    <div class="row" style="margin-top:8px">
      <label>Date/time:
        <input id="descWhen" type="datetime-local" step="1" />
      </label>
      <label style="flex:1;min-width:100px">Initials:
        <input id="descInitials" type="text" placeholder="DG" style="width:100%" />
      </label>
    </div>
    <div style="margin-top:8px">
      <label style="display:block;font-size:13px;margin-bottom:6px">Position (device â†’ BNG) <span class="hint" style="font-size:12px">(*) approximate</span></label>
      <input id="descPosition" type="text" readonly style="width:100%;background:var(--input-bg);color:var(--text); border:1px solid var(--border);border-radius:8px;padding:8px" />
    </div>
  </div>
  <div class="actions">
    <button id="descCancel">Cancel</button>
    <button id="descOK" class="primary">Save</button>
  </div>
</dialog>

<!-- NEW: Bulk Upload Confirmation Dialog -->
<dialog id="bulkDialog">
  <header><strong>Bulk Upload</strong></header>
  <div class="content">
    <p id="bulkMsg" style="margin:0 0 12px">Selected 0 photos.</p>
    <div style="background:rgba(255,255,255,0.05);padding:10px;border-radius:8px;margin-bottom:12px">
      <label style="display:flex;align-items:center;gap:8px;font-weight:600;cursor:pointer">
        <input id="chkBulkRotate" type="checkbox" /> Force landscape
      </label>
      <small style="display:block;margin-top:4px;opacity:0.7;margin-left:24px">Rotates portrait images 90Â° clockwise to fit layout.</small>
    </div>
    <p class="hint" style="margin:0">Note: Descriptions are skipped during bulk upload.</p>
  </div>
  <div class="actions">
    <button id="btnBulkCancel">Cancel</button>
    <button id="btnBulkOk" class="primary">Upload</button>
  </div>
</dialog>

<!-- Rename the slide-out panel for managing collections -->
<div id="collections" class="collections-panel" aria-hidden="true">
  <div class="collections-header-row" style="display:flex;align-items:center;gap:8px;">
    <button id="collectionsClose" class="btn" type="button">Close</button>
    <h2 class="collections-title" style="margin:0;font-size:1rem;font-weight:600;">Collections</h2>
    <div class="flex-spacer" style="flex:1;"></div>
  </div>
  <p class="collections-hint">Manage active collections. Click one to switch to it.</p>
  <div class="collections-new-btn-row" style="margin-top:8px; display:flex; gap:8px;">
    <button id="newCollectionBtn" class="btn" type="button">ï¼‹ New Collection</button>
    <!-- NEW: Import button -->
    <button id="importCollectionBtn" class="btn" type="button">Import Collection</button>
    <input type="file" id="importCollectionInput" accept=".json,application/json" style="display:none" />
  </div>
  <ul id="collectionsList" class="collections-list" style="list-style:none;padding:0;margin-top:10px;"></ul>
</div>

<!-- Add the params panel markup (place near other slide-out panels) -->
<div id="paramsPanel" class="params-panel" aria-hidden="true">
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
    <button id="paramsClose" class="btn" type="button">Close</button>
    <h3 style="margin:0">Project Details</h3>
  </div>

  <div style="margin-top:8px">
    <div class="field">
      <label style="font-size:12px">Job Name</label>
      <input id="params_collectionTitle" type="text" placeholder="Job Name" />
    </div>
    <div class="field">
      <!-- CHANGED label from Job No. to Client -->
      <label style="font-size:12px">Client</label>
      <input id="params_clientName" type="text" placeholder="Client" />
    </div>
    <div class="field">
      <label style="font-size:12px">Job No.</label>
      <input id="params_projectTitle" type="text" placeholder="Job No." />
    </div>
    <div class="field">
      <label style="font-size:12px">Photoboard Title</label>
      <input id="params_photographerName" type="text" placeholder="Photoboard Title" />
    </div>
    <div style="margin-top:12px;text-align:right">
      <button id="paramsSave" class="btn primary">Save</button>
    </div>

    <!-- NEW: Moved Force Landscape button here -->
    <hr style="border:0;border-top:1px solid var(--border);margin:20px 0 12px" />
    <button id="btnForceLandscape" class="btn warn" style="width:100%;font-size:13px">
      Force all to Landscape
    </button>
    <small class="hint" style="display:block;margin-top:6px;text-align:center;opacity:0.7">Rotates all portrait images in this collection.</small>
  </div>
</div>

<!-- Libraries (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
<script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script> <!-- ADDED: HEIC conversion library -->
<!-- include the helper as an ES module so addBottomRightTable is available -->
<script type="module" src="./pptx_table.js"></script>

<script>
  // Register the static service worker so scope works correctly on GitHub Pages
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js', { scope: './' }).catch(()=>{});
    });
  }
</script>

<script>
/* ---------------- Minimal IndexedDB ---------------- */
const DB_NAME='evidenceDB', STORE='items', SESSIONS_STORE='sessions', FS_HANDLES_STORE = 'fsHandles'; // NEW STORE
function idbOpen(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 3); // DB version 3
    req.onupgradeneeded = (event) => {
      const db = event.target.result;
      // create legacy items store if missing
      if (!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
      }
      // create sessions store if missing (autoIncrement per spec)
      if (!db.objectStoreNames.contains(SESSIONS_STORE)) {
        db.createObjectStore(SESSIONS_STORE, { keyPath: 'id', autoIncrement: true });
      }
      // NEW: create fsHandles store
      if (!db.objectStoreNames.contains(FS_HANDLES_STORE)) {
        db.createObjectStore(FS_HANDLES_STORE);
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
    req.onblocked = () => console.warn('IndexedDB open blocked - close other tabs using this site to upgrade the database.');
  });
}
async function idbAdd(obj){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).add(obj).onsuccess=e=>res(e.target.result); tx.onerror=()=>rej(tx.error); }); }
// NEW: IDB Helpers for patching
async function idbPut(store, obj){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).put(obj).onsuccess=e=>res(e.target.result); tx.onerror=()=>rej(tx.error); }); }
async function idbGet(store, key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readonly'); const req=tx.objectStore(store).get(key); req.onsuccess=()=>res(req.result); tx.onerror=()=>rej(tx.error); }); }
async function idbDelete(store, key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); tx.objectStore(store).delete(key).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error); }); }
async function idbAll(){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const req=tx.objectStore(STORE).getAll(); req.onsuccess=()=>res(req.result||[]); req.onerror=()=>rej(req.error); }); }

// New helpers for sessions store
async function idbAddSession(session){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readwrite'); tx.objectStore(SESSIONS_STORE).put(session).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error); }); }
async function idbGetSession(id){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readonly'); const req=tx.objectStore(SESSIONS_STORE).get(id); req.onsuccess=()=>res(req.result||null); req.onerror=()=>rej(req.error); }); }
async function idbAllSessions(){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readonly'); const req=tx.objectStore(SESSIONS_STORE).getAll(); req.onsuccess=()=>res(req.result||[]); req.onerror=()=>rej(req.error); }); }
async function idbDeleteSession(id){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(SESSIONS_STORE,'readwrite'); tx.objectStore(SESSIONS_STORE).delete(id).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error); }); }

// NEW: Missing helper for saving individual items
async function saveItem(item) {
  // Create a shallow copy to avoid modifying the in-memory object used by the UI
  const clone = { ...item };
  // Strip transient UI properties that IDB cannot store (like DOM elements)
  delete clone._preview;
  delete clone._loading;
  delete clone._needsPreview;
  delete clone._objectURL;
  
  return idbPut(STORE, clone);
}

// NEW: Helpers for File System Access handles
async function saveDirectoryHandle(handle) {
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction(FS_HANDLES_STORE, 'readwrite');
    tx.objectStore(FS_HANDLES_STORE).put(handle, 'directory').onsuccess = () => res();
    tx.onerror = () => rej(tx.error);
  });
}
async function getDirectoryHandle() {
  const db = await idbOpen();
  return new Promise((res, rej) => {
    const tx = db.transaction(FS_HANDLES_STORE, 'readonly');
    const req = tx.objectStore(FS_HANDLES_STORE).get('directory');
    req.onsuccess = () => res(req.result || null);
    req.onerror = () => rej(req.error);
  });
}

/* ---------------- App state + UI refs ---------------- */
const state = { items: [], client: '', project: '', photographer: '', photographerInitials: '' };
const fileInput = document.getElementById('fileInput');
const btnSnap = document.getElementById('btnSnap');
const captureModeLabel = document.getElementById('captureModeLabel');
const captureModeHint = document.getElementById('captureModeHint');
const gallery = document.getElementById('gallery');
const collectionTitleInput = document.getElementById('collectionTitle');
const clientNameInput = document.getElementById('clientName'); // New
const projectTitleInput = document.getElementById('projectTitle'); // New
const photographerNameInput = document.getElementById('photographerName'); // New
const descDialog = document.getElementById('descDialog');
const descText = document.getElementById('descText');
const descWhen = document.getElementById('descWhen');
const descInitials = document.getElementById('descInitials'); // NEW REF
const descPosition = document.getElementById('descPosition');
const descOK = document.getElementById('descOK');
const descCancel = document.getElementById('descCancel');
const btnUnlockMeta = document.getElementById('btnUnlockMeta'); // NEW
const btnExportPPTX = document.getElementById('btnExportPPTX');
const btnConfirmExport = document.getElementById('btnConfirmExport'); // NEW
const layoutSel = document.getElementById('layout');

/* NEW: Unlock metadata handler */
if(btnUnlockMeta){
  btnUnlockMeta.addEventListener('click', () => {
    const isLocked = descWhen.disabled;
    if (isLocked) {
      if (confirm("Unlock metadata fields? Modifying the date or position may overwrite original capture data.")) {
        descWhen.disabled = false;
        descWhen.style.opacity = '1';
        descPosition.disabled = false;
        descPosition.style.opacity = '1';
        descPosition.readOnly = false;
        // Open lock icon
        btnUnlockMeta.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;
      }
    } else {
      // Lock
      descWhen.disabled = true;
      descWhen.style.opacity = '0.5';
      descPosition.disabled = true;
      descPosition.style.opacity = '0.5';
      descPosition.readOnly = true;
      // Closed lock icon
      btnUnlockMeta.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;
    }
  });
}

const orientationSel = document.getElementById('orientation');
const btnForceLandscape = document.getElementById('btnForceLandscape');
const chkAutoSort = document.getElementById('chkAutoSort'); // NEW
const chkNoMix = document.getElementById('chkNoMix'); // NEW
const lblNoMix = document.getElementById('lblNoMix'); // NEW

// NEW: Handle NoMix dependency
if(chkAutoSort && chkNoMix){
  chkAutoSort.addEventListener('change', ()=>{
    const isOn = chkAutoSort.checked;
    chkNoMix.disabled = !isOn;
    if(lblNoMix) lblNoMix.style.opacity = isOn ? '1' : '0.5';
    if(!isOn) chkNoMix.checked = false;
  });
}

// NEW: Bulk Dialog Refs
const bulkDialog = document.getElementById('bulkDialog');

/* REMOVED: maxwInput and marginsInput */
/* NEW: PPTX attribute checkboxes */
const attrTimestampChk = document.getElementById('attrTimestamp');
const attrPositionChk  = document.getElementById('attrPosition');
const attrAccuracyChk  = document.getElementById('attrAccuracy');
const attrPhotographerChk = document.getElementById('attrPhotographer');          // NEW
const countEl = document.getElementById('count');

const btnEnableLoc = document.getElementById('btnEnableLoc');
// REMOVED: const btnSettings = document.getElementById('btnSettings');
const settingsPanel = document.getElementById('settingsPanel');
const btnCloseSettings = document.getElementById('btnCloseSettings');
// NEW: folder picker refs
const btnChooseFolder = document.getElementById('btnChooseFolder');
const folderStatus = document.getElementById('folderStatus');
const btnClear = document.getElementById('btnClear'); // NEW: guard missing clear button
// NEW: Bulk upload refs
const btnBulkUpload = document.getElementById('btnBulkUpload');
const bulkInput = document.getElementById('bulkInput');
const btnZoom = document.getElementById('btnZoom'); // NEW

// NEW: Zoom toggle handler
if(btnZoom){
  let zoomLevel = 0; // 0=Max, 1=Med, 2=Small
  btnZoom.addEventListener('click', () => {
    zoomLevel = (zoomLevel + 1) % 3;
    // Reset classes
    gallery.classList.remove('zoom-1', 'zoom-2');
    if(zoomLevel === 1) gallery.classList.add('zoom-1');
    if(zoomLevel === 2) gallery.classList.add('zoom-2');
  });
}

// params panel refs
const paramsToggle = document.getElementById('paramsToggle');
const paramsPanel = document.getElementById('paramsPanel');
const paramsClose = document.getElementById('paramsClose');
const paramsSave = document.getElementById('paramsSave');
const params_collectionTitle = document.getElementById('params_collectionTitle');
const params_clientName = document.getElementById('params_clientName');
const params_projectTitle = document.getElementById('params_projectTitle');
const params_photographerName = document.getElementById('params_photographerName');

// location state
let pendingCanvas=null;
let pendingBlob=null; // NEW: Explicit declaration
let pendingGPS=null;
let editingItem=null; // NEW: Track item being edited
let locationEnabled = false;      // default to OFF so warning chip shows immediately
let lastKnownPos = null;
let watchId = null;
let dirHandle = null; // NEW: hold the directory handle in memory
let isLocationPending = false; // NEW: Track background location status
let locationTaskID = 0; // NEW: Track active location task
let shutterGPSPromise = null; // NEW: Snapshot GPS captured at shutter press

/* --- Simple long-press controller (1s) --- */
const MODE = {
  camera:  { capture: true,  label: 'Mode A', hint: 'Camera'  },
  gallery: { capture: false, label: 'Mode B', hint: 'Gallery' }
};
let captureMode = 'camera';
const LONG_MS = 1000;
let lpTimer = null;
let isLongPress = false;  // Flag to track if long press occurred

function setCaptureMode(key){
  captureMode = key;
  btnSnap.dataset.mode = key;
  captureModeHint && (captureModeHint.textContent = MODE[key].hint);
  btnSnap.classList.remove('mode-camera','mode-gallery');
  btnSnap.classList.add('mode-'+key);
  // brief flash effect on mode switch
  btnSnap.classList.add('mode-switch-flash');
  setTimeout(()=>btnSnap.classList.remove('mode-switch-flash'),500);
  if (MODE[key].capture) fileInput.setAttribute('capture','environment');
  else fileInput.removeAttribute('capture');
}
function toggleMode(){ setCaptureMode(captureMode === 'camera' ? 'gallery' : 'camera'); }
function triggerCapture(){
  if (MODE[captureMode].capture) {
    fileInput.setAttribute('capture', 'environment');
    shutterGPSPromise = captureShutterLocation();
  } else {
    fileInput.removeAttribute('capture');
    shutterGPSPromise = null;
  }
  fileInput.click();
}

btnSnap.addEventListener('pointerdown', e => {
  if (!e.isPrimary) return;
  e.preventDefault();
  isLongPress = false;
  clearTimeout(lpTimer);
  btnSnap.classList.add('progressing'); // start visual fill
  lpTimer = setTimeout(() => {
    isLongPress = true;
    toggleMode();
    btnSnap.classList.remove('progressing'); // stop fill once toggled
  }, LONG_MS);
});

btnSnap.addEventListener('pointerup', e => {
  if (!e.isPrimary) return;
  clearTimeout(lpTimer);
  if (!isLongPress) triggerCapture();
  btnSnap.classList.remove('progressing'); // cancel fill
});

// Remove pointerleave and pointercancel listeners (no longer needed)

/* --- end simple long-press controller --- */

/* --- wire up other handlers (remove conflicting click) --- */
// REMOVED: btnSnap.addEventListener('click', ()=> fileInput.click());
btnExportPPTX.addEventListener('click', ()=> { 
  settingsPanel.style.right = (settingsPanel.style.right === '0px') ? '-320px' : '0px'; 
});
btnCloseSettings.addEventListener('click', ()=> { settingsPanel.style.right = '-320px'; });
// also allow closing when panel is open and user clicks outside (optional)
document.addEventListener('keydown', e=>{ if(e.key === 'Escape'){ settingsPanel.style.right='-320px'; descDialog.close?.(); /* NEW: close params panel on Esc */ paramsPanel?.classList.remove('open'); paramsPanel?.setAttribute('aria-hidden','true'); } });

// NEW: params panel open/close/save
paramsToggle?.addEventListener('click', ()=>{
  // populate from current state before showing
  if (params_collectionTitle) params_collectionTitle.value = collectionTitleInput.value || '';
  if (params_clientName) params_clientName.value = state.client || '';
  if (params_projectTitle) params_projectTitle.value = state.project || '';
  if (params_photographerName) params_photographerName.value = state.photographer || '';
  
  paramsPanel?.classList.add('open');
  paramsPanel?.setAttribute('aria-hidden','false');
});
paramsClose?.addEventListener('click', ()=>{
  paramsPanel?.classList.remove('open');
  paramsPanel?.setAttribute('aria-hidden','true');
});

// NEW: Force Landscape Handler
if (btnForceLandscape) {
  btnForceLandscape.addEventListener('click', async () => {
    const portraitItems = state.items.filter(i => i.h > i.w);
    if (portraitItems.length === 0) {
      alert('No portrait images found.');
      return;
    }
    if (!confirm(`Rotate ${portraitItems.length} portrait images to landscape?`)) return;

    const originalText = btnForceLandscape.textContent;
    btnForceLandscape.disabled = true;
    
    let count = 0;
    for (const item of portraitItems) {
      count++;
      btnForceLandscape.textContent = `Rotating ${count}/${portraitItems.length}...`;
      
      try {
        // Load image
        const img = new Image();
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          // Handle Blob or DataURL source
          if (item.blob) {
             img.src = URL.createObjectURL(item.blob);
          } else {
             img.src = item.dataURL;
          }
        });

        // Rotate logic (90 degrees clockwise)
        const w = img.width;
        const h = img.height;
        const canvas = document.createElement('canvas');
        canvas.width = h; // Swap
        canvas.height = w;
        const ctx = canvas.getContext('2d');
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.rotate(90 * Math.PI / 180);
        ctx.drawImage(img, -w/2, -h/2);

        // Convert to Blob
        const blob = await canvasToBlob(canvas, 0.9);
        
        // Update item
        item.blob = blob;
        delete item.dataURL; // Remove legacy
        
        // Cleanup old URL if exists
        if (item._objectURL) URL.revokeObjectURL(item._objectURL);
        item._objectURL = URL.createObjectURL(blob); // Update for UI

        item.w = canvas.width;
        item.h = canvas.height;
        item._preview = createThumbnailFromCanvas(canvas);

        // Save using the fixed helper
        await saveItem(item);
        
        // Cleanup temp image src created for rotation
        if (item.blob) URL.revokeObjectURL(img.src);

      } catch (e) {
        console.error('Failed to rotate item', item.id, e);
      }
    }

    // Refresh UI
    renderGallery();
    btnForceLandscape.textContent = originalText;
    btnForceLandscape.disabled = false;
    
    // Close panel
    paramsPanel?.classList.remove('open');
    paramsPanel?.setAttribute('aria-hidden','true');
  });
}

// NEW: File System Access API logic
if (btnChooseFolder) {
  if ('showDirectoryPicker' in window) {
    btnChooseFolder.addEventListener('click', async () => {
      try {
        const handle = await window.showDirectoryPicker();
        // Request permission. This must be done within the user gesture.
        const permStatus = await handle.requestPermission({ mode: "readwrite" });

        // Explicitly verify the permission state after the request.
        if (permStatus === "granted") {
          // Verify we can actually use the handle (some mobile browsers require this).
          try {
            // `keys()` is a simple async iterator to check usability.
            // We don't need to do anything with the result.
            // If this fails, the handle is stale.
            await handle.keys().next(); 
            dirHandle = handle;
            await saveDirectoryHandle(handle);
            folderStatus.textContent = `Status: Saving to "${handle.name}" folder.`;
            alert(`Successfully linked to folder: ${handle.name}`);
          } catch (e) {
            console.warn('Stale directory handle, re-selection needed.', e);
            folderStatus.textContent = `Status: Re-select "${savedHandle.name}" to grant access.`;
            dirHandle = null;
          }





        } else {
          // Permission was not persisted or was revoked. User must re-grant it.
          folderStatus.textContent = `Status: Permission needed for "${savedHandle.name}". Click "Choose Folder" to re-enable.`;
          dirHandle = null; // Clear the stale handle.
        }
      } catch (err) {
        console.error('Failed to check saved directory handle:', err);
      }
    });
  } else {
    btnChooseFolder.disabled = true;
    folderStatus.textContent = 'Status: Your browser does not support local directory saving.';
  }
}

function isImportedGPS(pos){
  return !!pos && (pos.source === 'exif' || pos.accuracy === 0);
}

function fmtBNGDisplay(pos){
  if(!pos) return '';
  // CHANGED: Handle imported items (accuracy 0 or EXIF source) -> show * and hide accuracy
  const isImport = isImportedGPS(pos);
  const suffix = isImport ? ' *' : '';
  const accText = isImport ? '' : ` (~${Math.round(pos.accuracy||3)} m)`;

  if(typeof pos.bngE !== 'undefined' && typeof pos.bngN !== 'undefined' && typeof pos.lat === 'number' && typeof pos.lon === 'number'){
    return `BNG: E ${pos.bngE} N ${pos.bngN} | Lat ${pos.lat.toFixed(6)}, Lon ${pos.lon.toFixed(6)}${suffix}${accText}`;
  }
  if(typeof pos.lat === 'number' && typeof pos.lon === 'number'){
    return `Lat ${pos.lat.toFixed(6)}, Lon ${pos.lon.toFixed(6)}${suffix}${accText}`;
  }
  return '';
}
// NEW: Missing helper to request location once (prompts permission)
function requestLocationOnce() {
  return new Promise((resolve) => {
    if (!navigator.geolocation) return resolve(null);
    navigator.geolocation.getCurrentPosition(
      (pos) => resolve(pos),
      (err) => {
        console.warn('Location request failed', err);
        resolve(null);
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
    );
  });
}

// NEW: Capture a one-off GPS fix at shutter time (WGS84 -> BNG)
function captureShutterLocation(){
  const task = (async () => {
    try{
      const pos = await requestLocationOnce();
      if(!pos) return null;
      const { latitude: lat, longitude: lon, accuracy } = pos.coords;
      try{
        const bng = latLonToBNG(lat, lon);
        return { lat, lon, accuracy, bngE: bng.easting, bngN: bng.northing, source: 'shutter' };
      }catch(convErr){
        console.warn('Shutter BNG conversion failed', convErr);
        return { lat, lon, accuracy, source: 'shutter' };
      }
    }catch(err){
      console.warn('Shutter location failed', err);
      return null;
    }
  })();
  shutterGPSPromise = task;
  return task;
}

// CHANGED: Precise WGS84 â†’ OSGB36 conversion + Transverse Mercator
function latLonToBNG(wgsLat, wgsLon) {
  // Quick bounds check (UK extent)
  if (wgsLat < 49 || wgsLat > 61 || wgsLon < -8 || wgsLon > 2) return { easting: null, northing: null };

  // WGS84 ellipsoid
  const aW = 6378137.0, bW = 6356752.3141;
  const e2W = 1 - (bW * bW) / (aW * aW);

  // Airy 1830 ellipsoid (OSGB36)
  const aO = 6377563.396, bO = 6356256.909;
  const e2O = 1 - (bO * bO) / (aO * aO);

  // Convert degrees to radians
  const degToRad = d => d * Math.PI / 180;
  const radToDeg = r => r * 180 / Math.PI;

  const latRad = degToRad(wgsLat);
  const lonRad = degToRad(wgsLon);

  // Height assumed 0
  const h = 0;

  // WGS84 Cartesian
  const sinLat = Math.sin(latRad), cosLat = Math.cos(latRad);
  const sinLon = Math.sin(lonRad), cosLon = Math.cos(lonRad); // CHANGED: was Math.cos(latRad)
  const vW = aW / Math.sqrt(1 - e2W * sinLat * sinLat);
  const xW = (vW + h) * cosLat * cosLon;
  const yW = (vW + h) * cosLat * sinLon;
  const zW = ((1 - e2W) * vW + h) * sinLat;

  // Helmert transform parameters (WGS84 â†’ OSGB36)
  const tx = -446.448, ty = 125.157, tz = -542.060;          // meters
  const rxSec = -0.1502, rySec = -0.2470, rzSec = -0.8421;   // arcâ€‘seconds
  const sPpm = 20.4894;                                      // ppm

  const secToRad = s => s * Math.PI / (180 * 3600);
  const rx = secToRad(rxSec), ry = secToRad(rySec), rz = secToRad(rzSec);
  const s = sPpm * 1e-6;

  // Apply Helmert (small rotations)
  const xO = tx + (1 + s) * xW + (-rz) * yW + (ry) * zW;
  const yO = ty + (rz) * xW + (1 + s) * yW + (-rx) * zW;
  const zO = tz + (-ry) * xW + (rx) * yW + (1 + s) * zW;

  // Convert back to OSGB36 lat/lon (iterative)
  const p = Math.sqrt(xO * xO + yO * yO);
  let latO = Math.atan2(zO, p * (1 - e2O));
  let latPrev;
  for (let i = 0; i < 7; i++) {
    const sinLatO = Math.sin(latO);
    const vO = aO / Math.sqrt(1 - e2O * sinLatO * sinLatO);
    latPrev = latO;
    latO = Math.atan2(zO + e2O * vO * sinLatO, p);
    if (Math.abs(latO - latPrev) < 1e-12) break;
  }
  const lonO = Math.atan2(yO, xO);

  // Transverse Mercator projection constants
  const F0 = 0.9996012717;
  const lat0 = degToRad(49);
  const lon0 = degToRad(-2);
  const N0 = -100000;
  const E0 = 400000;
  const n = (aO - bO) / (aO + bO);
  const sinLatO = Math.sin(latO);
  const cosLatO = Math.cos(latO);
  const nu = aO * F0 / Math.sqrt(1 - e2O * sinLatO * sinLatO);
  const rho = aO * F0 * (1 - e2O) / Math.pow(1 - e2O * sinLatO * sinLatO, 1.5);
  const eta2 = nu / rho - 1;

  // Meridional arc
  function meridionalArc(lat) {
    return bO * F0 * (
      (1 + n + (5/4)*n*n + (5/4)*n*n*n) * (lat - lat0)
      - (3*n + 3*n*n + (21/8)*n*n*n) * Math.sin(lat - lat0) * Math.cos(lat + lat0)
      + ((15/8)*n*n + (15/8)*n*n*n) * Math.sin(2*(lat - lat0)) * Math.cos(2*(lat + lat0))
      - (35/24)*n*n*n * Math.sin(3*(lat - lat0)) * Math.cos(3*(lat + lat0))
    );
  }
  const M = meridionalArc(latO);
  const dLon = lonO - lon0;

  const I = M + N0;
  const II = (nu / 2) * sinLatO * cosLatO;
  const III = (nu / 24) * sinLatO * Math.pow(cosLatO, 3) * (5 - Math.tan(latO) * Math.tan(latO) + 9 * eta2);
  const IIIA = (nu / 720) * sinLatO * Math.pow(cosLatO, 5) * (61 - 58 * Math.tan(latO) * Math.tan(latO) + Math.pow(Math.tan(latO), 4));
  const IV = nu * cosLatO;
  const V = (nu / 6) * Math.pow(cosLatO, 3) * (nu / rho - Math.tan(latO) * Math.tan(latO));
  const VI = (nu / 120) * Math.pow(cosLatO, 5) * (5 - 18 * Math.tan(latO) * Math.tan(latO) + Math.pow(Math.tan(latO), 4) + 14 * eta2 - 58 * Math.tan(latO) * Math.tan(latO) * eta2);

  const N = I + II * dLon * dLon + III * Math.pow(dLon, 4) + IIIA * Math.pow(dLon, 6);
  const E = E0 + IV * dLon + V * Math.pow(dLon, 3) + VI * Math.pow(dLon, 5);

  return { easting: Math.round(E), northing: Math.round(N) };
}

function startWatch(){
  if(!navigator.geolocation || watchId) return;
  try{
    watchId = navigator.geolocation.watchPosition(pos=>{
      try{
        const lat = pos.coords.latitude, lon = pos.coords.longitude, acc = pos.coords.accuracy;
        const bng = latLonToBNG(lat, lon); // latLonToBNG()
        const latestPos = { lat, lon, accuracy: acc, bngE: bng.easting, bngN: bng.northing };
        lastKnownPos = latestPos;
        const gpsLocked = isImportedGPS(pendingGPS) || pendingGPS?.source === 'shutter';
        if(!gpsLocked){
          pendingGPS = latestPos;
        }
        // update dialog field if open
        // CHANGED: Do not update position if we are editing an existing item (lock position)
        // NEW: Also do not update if the field shows imported EXIF data (marked with *)
        if(descDialog.open && !editingItem && !gpsLocked && !descPosition.value.includes('*')){
          descPosition.value = fmtBNGDisplay(latestPos);
        }
        // visual indicator & tooltip include accuracy
        setLocationButtonState(true, Math.round(acc||0));
      }catch(err){
        console.warn('watchPosition -> BNG convert failed', err);
      }
    }, err=>{
      console.warn('watchPosition error', err);
      // turn off visual indicator on errors (permission/unavailable/etc)
      setLocationButtonState(false);
    }, { enableHighAccuracy:true, maximumAge:0, timeout:20000 });
  }catch(e){
    console.warn('startWatch failed', e);
    setLocationButtonState(false);
    watchId = null;
  }
}

function stopWatch(){
  if(watchId !== null && navigator.geolocation){
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
    // visual reset: icon shows disabled
    setLocationButtonState(false);
  }
}

// NEW: Handle visibility change to save battery
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Tab hidden: stop GPS to save battery
    if (watchId) stopWatch();
  } else {
    // Tab visible: restart if user intent was "Enabled"
    if (locationEnabled) startWatch();
   }
});

btnEnableLoc.addEventListener('click', async ()=>{
  // CHANGED: Toggle based on INTENT (locationEnabled flag), not just current watchId status.
  // This fixes the issue where an error state (watchId set but UI red) required double-clicking.
  if(locationEnabled){
    // User wants to disable
    locationEnabled = false;
    stopWatch();
    return;
  }

  // User wants to enable
  // User gesture: do a oneâ€‘shot getCurrentPosition to force browser permission prompt
  btnEnableLoc.setAttribute('title','Requestingâ€¦');
  const pos = await requestLocationOnce();
  if(!pos){
    setLocationButtonState(false, 'Denied / unavailable');
    locationEnabled = false;
    return;
  }

  try{
    const lat = pos.coords.latitude, lon = pos.coords.longitude, acc = pos.coords.accuracy;
    const bng = latLonToBNG(lat, lon, acc);
    lastKnownPos = { lat, lon, accuracy: acc, bngE: bng.easting, bngN: bng.northing };
    const gpsLocked = isImportedGPS(pendingGPS) || pendingGPS?.source === 'shutter';
    if(!gpsLocked){
      pendingGPS = lastKnownPos;
      descPosition.value = fmtBNGDisplay(lastKnownPos);
    }
    
    // Set intent flag and start
    locationEnabled = true;
    startWatch();
    setLocationButtonState(true, Math.round(acc||0));
  }catch(err){
    console.warn('Enable location failed', err);
    setLocationButtonState(false, 'Error');
    locationEnabled = false;
    stopWatch();
  }
});

function setLocationButtonState(enabled, accOrMsg){
  const btn = document.getElementById('btnEnableLoc');
  const warn = document.getElementById('locWarning');
  if(btn){
    if(enabled){
      btn.classList.remove('loc-off'); btn.classList.add('loc-on');
      btn.classList.remove('loc-off'); btn.classList.add('loc-on');
           const title = (typeof accOrMsg === 'number') ? `Disable location (~${accOrMsg} m)` : 'Disable location';
      btn.setAttribute('title', title);
      btn.setAttribute('aria-pressed','true');
    }else{
      btn.classList.remove('loc-on'); btn.classList.add('loc-off');
      const title = (typeof accOrMsg === 'string') ? accOrMsg : 'Enable location';
      btn.setAttribute('title', title);
      btn.setAttribute('aria-pressed','false');
    }
  }
  // Toggle header warning chip
  if (warn) {
    if (enabled) {
      // CHANGED: Show accuracy chip when enabled instead of hiding it
      if (typeof accOrMsg === 'number') {
        warn.textContent = `Â± ${accOrMsg}m`;
        warn.classList.add('active');
        warn.style.display = 'inline-flex';

      } else {
        warn.style.display = 'none';
      }
    } else {
      warn.classList.remove('active');
      warn.textContent = 'Location OFF';
      warn.style.display = 'inline-flex';
    }
  }
  // NEW: Update footer status chip
  const statusChip = document.getElementById('appStatusFooter');
  if (statusChip) {
    if (enabled) {
      statusChip.classList.add('installed');
      statusChip.classList.remove('not-installed');
      statusChip.querySelector('.txt').textContent = 'v2.02 â€¢ Installed';
    } else {
      statusChip.classList.remove('installed');
      statusChip.classList.add('not-installed');
      statusChip.querySelector('.txt').textContent = 'v2.02 â€¢ Not installed';
    }
  }
}

/* initialize location button visual state (off by default) */
document.addEventListener('DOMContentLoaded', ()=> {
  setLocationButtonState(false, 'Enable location');
  setCaptureMode(captureMode); // ensure initial green mode class
});

/* ---------------- Helpers needed by capture / UI ---------------- */
function escapeHTML(s){ return (s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quote;',"'":'&#039;' }[m])); }
function fmtCount(n){ return `${n} item${n===1?'':'s'}`; }
function toDataURL(canvas, quality=0.92){ return canvas.toDataURL('image/jpeg', quality); }

/* NEW: Debounce helper (Fixes "debounce is not defined" error)
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}
*/

// NEW: Blob helpers for memory optimization
function canvasToBlob(canvas, quality=0.92) {
  return new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', quality));
}
function blobToDataURL(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function dataURLtoBlob(dataURL){
  const parts = dataURL.split(',');
  const mime = parts[0].match(/:(.*?);/)[1];
  const binStr = atob(parts[1]);
  const len = binStr.length;
  const u8 = new Uint8Array(len);
  for(let i=0;i<len;i++) u8[i]=binStr.charCodeAt(i);
  return new Blob([u8], {type:mime});
}

// NEW: EXIF Helpers
function getExifData(file) {
  return new Promise((resolve) => {
    if(!window.EXIF) return resolve({});
    EXIF.getData(file, function() {
      resolve(EXIF.getAllTags(this));
    });
  });
}
function convertDMSToDD(d, m, s, ref) {
  // Ensure inputs are numbers. EXIF data can sometimes be messy (e.g. Number objects, strings, or NaN).
  let deg = Number(d);
  let min = Number(m);
  let sec = Number(s);
  
  // Handle invalid numbers gracefully by treating as 0
  if (isNaN(deg)) deg = 0;
  if (isNaN(min)) min = 0;
  if (isNaN(sec)) sec = 0;

  let dd = deg + min/60 + sec/3600;
  
  // Check ref. Sometimes it's not a string, or has whitespace.
  if (typeof ref === 'string') {
    ref = ref.toUpperCase().trim();
    if (ref === "S" || ref === "W") dd = dd * -1;
  }
  return dd;
}
function parseExifLocation(tags) {
  // Check if tags exist and have length. Some EXIF readers return length 0 arrays for missing data.
  if (tags && tags.GPSLatitude && tags.GPSLatitude.length >= 3 && tags.GPSLongitude && tags.GPSLongitude.length >= 3) {
    const lat = convertDMSToDD(tags.GPSLatitude[0], tags.GPSLatitude[1], tags.GPSLatitude[2], tags.GPSLatitudeRef);
    const lon = convertDMSToDD(tags.GPSLongitude[0], tags.GPSLongitude[1], tags.GPSLongitude[2], tags.GPSLongitudeRef);
    
    // Safety check: if calculation resulted in NaN, reject it.
    if (isNaN(lat) || isNaN(lon)) return null;
    
    // Basic bounds check (Lat -90 to 90, Lon -180 to 180)
    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return null;
    
    // Check for 0,0 which is often a default/error value in EXIF (Null Island)
    if (Math.abs(lat) < 0.0001 && Math.abs(lon) < 0.0001) return null;

    return { lat, lon };
  }
  return null;
}
function parseExifDate(tags) {
  const str = tags.DateTimeOriginal || tags.DateTime;
  if(typeof str === 'string') {
    const parts = str.split(' ');
    if(parts.length === 2) {
      const dParts = parts[0].split(':');
      const tParts = parts[1].split(':');
      if(dParts.length === 3 && tParts.length === 3) {
        return new Date(dParts[0], dParts[1]-1, dParts[2], tParts[0], tParts[1], tParts[2]);
      }
    }
  }
  return null;
}

// NEW: Helper to ensure imported items match current structure
function normaliseLegacyItem(item) {
  // If item has flat GPS props (legacy), move them to .gps object
  if (!item.gps && (typeof item.lat === 'number' || typeof item.bngE !== 'undefined')) {
    item.gps = {
      lat: item.lat,
      lon: item.lon,
      accuracy: item.accuracy,
      bngE: item.bngE,
      bngN: item.bngN
    };
    // clean up flat props to avoid confusion
    delete item.lat; delete item.lon; delete item.accuracy; delete item.bngE; delete item.bngN;
  }
  // Tag imported GPS so live location updates do not overwrite it
  if (item.gps && !item.gps.source && item.gps.accuracy === 0) {
    item.gps.source = 'exif';
  }
  // Strip transient UI properties
  delete item._preview;
  delete item._loading;
  delete item._needsPreview;
  delete item._objectURL; // NEW: Ensure transient URL is stripped
  return item;
}

/** Normalize an image file. 
    - Loads image reliably into an HTMLImageElement
    - Preserves aspect ratio
    - Optionally rotates portrait sources 90Â° to yield landscape output (if forceRotate=true)
*/
async function normalizeImage(file, maxW, forceRotate=true){
  // CHANGED: Detect and convert HEIC before loading
  let sourceBlob = file;
  try {
    if (file && (
        /\.heic$/i.test(file.name || '') ||
        file.type === 'image/heic' ||
        file.type === 'image/heif'
      ) && typeof heic2any === 'function') {
      const converted = await heic2any({ blob: file, toType: 'image/jpeg', quality: 0.92 });
      // heic2any may return a single Blob or an array
      if (converted) {
        sourceBlob = Array.isArray(converted) ? converted[0] : converted;
      }
    }
  } catch (heicErr) {
    console.warn('HEIC conversion failed, falling back to original file', heicErr);
  }
  const loadImg = (blob) => new Promise((res, rej) => {
    const img = new Image();
    img.onload = () => res(img);
    img.onerror = (e) => rej(e);
    // Avoid tainting from cross-origin; blob URL is same-origin
    img.src = URL.createObjectURL(blob);
  });

  const img = await loadImg(sourceBlob);

  // source dimensions
  const sw = img.width;
  const sh = img.height;

  // determine if source is portrait
  const isPortrait = sh > sw;
  // Rotate only if forced AND it is portrait
  const rotate = forceRotate && isPortrait;

  // Scale based on the longest side (if rotating, dimensions swap, but max is same)
  const sourceLong = Math.max(sw, sh);
  const scale = Math.min(1, (maxW || 1920) / sourceLong);

  // Output dimensions
  const outW = Math.round((rotate ? sh : sw) * scale);
  const outH = Math.round((rotate ? sw : sh) * scale);
  const canvas = document.createElement('canvas');
  canvas.width = outW;
  canvas.height = outH;
  const ctx = canvas.getContext('2d');

  if (rotate) {
    ctx.save();
    ctx.translate(outW / 2, outH / 2);
    ctx.rotate(Math.PI / 2);
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    ctx.drawImage(img, -dw /  2, -dh / 2, dw, dh);
    ctx.restore();
  } else {
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    const dx = Math.round((outW - dw) / 2);
    const dy = Math.round((outH - dh) / 2);
    ctx.drawImage(img, dx, dy, dw, dh);
  }

  // release object URL created by loadImg (best-effort)
  try { URL.revokeObjectURL(img.src); } catch (e) {}

  return canvas;
}

// NEW: Lazy preview generator updated for Blobs
function createPreviewCanvas(item) {
  if (item._preview) return item._preview;
  if (!item._needsPreview) return null;
  if (item._loading) return null; // Prevent duplicate loads

  item._loading = true;
  const img = new Image();
  img.onload = () => {
    delete item._loading;
    const canvas = document.createElement('canvas');
    // Create a thumbnail (max 300px)
    const scale = Math.min(300 / img.width, 300 / img.height, 1);
    canvas.width = Math.floor(img.width * scale);
    canvas.height = Math.floor(img.height * scale);
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    
    item._preview = canvas;
    item._needsPreview = false;
    
    // Update DOM if visible
    const thumb = document.querySelector(`.thumb[data-id="${item.id}"] canvas`);
    if (thumb) {
      const newC = document.createElement('canvas');
      newC.width = canvas.width;
      newC.height = canvas.height;
      newC.getContext('2d').drawImage(canvas, 0, 0);
      thumb.replaceWith(newC);
    }
  };
  img.onerror = () => { 
    delete item._loading;
    item._needsPreview = false; 
  };
  
  // CHANGED: Handle Blob URL
  if (item.blob) {
    if (!item._objectURL) item._objectURL = URL.createObjectURL(item.blob);
    img.src = item._objectURL;
  } else {
    img.src = item.dataURL;
  }
  return null;
}

// NEW: Helper to create small thumbnail from full canvas (Fixes memory leak)
function createThumbnailFromCanvas(sourceCanvas) {
  const thumbScale = Math.min(300 / sourceCanvas.width, 300 / sourceCanvas.height, 1);
  const t = document.createElement('canvas');
  t.width = Math.floor(sourceCanvas.width * thumbScale);
  t.height = Math.floor(sourceCanvas.height * thumbScale);
  t.getContext('2d').drawImage(sourceCanvas, 0, 0, t.width, t.height);
  return t;
}

/* Render gallery from state.items (uses item._preview canvas if present) */
function renderGallery(){
  const gallery = document.getElementById('gallery');
  gallery.innerHTML = '';

  // NEW: show placeholder when empty
  const items = [...state.items].sort((a, b) => {
    const ta = new Date(a.whenISO || a.created).getTime() || 0;
    const tb = new Date(b.whenISO || b.created).getTime() || 0;
    return tb - ta;
  });
  if (items.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'gallery-placeholder';
    empty.setAttribute('role', 'status');
    empty.setAttribute('aria-live', 'polite');
    empty.innerHTML = `
      <svg viewBox="0 0 24 24" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <rect x="3" y="7" width="18" height="12" rx="2"></rect>
        <path d="M7 7l2-3h6l2 3"></path>
        <circle cx="12" cy="13" r="4"></circle>
      </svg>
      <div>No photos yet</div>
      <small>Tap â€œPhotoâ€ to add images to this collection.</small>
    `;
    gallery.appendChild(empty);
    const countEl = document.getElementById('count');
    if (countEl) countEl.textContent = '0 items';
    return;
  }

  items.forEach(item=>{
    const card=document.createElement('div'); card.className='thumb';
    card.dataset.id = item.id; // NEW: ID for lazy update

    // NEW: Long press to edit description
    let pressTimer;
    const cancelPress = () => clearTimeout(pressTimer);
    card.addEventListener('pointerdown', (e) => {
      if (e.target.closest('button')) return; // Ignore buttons
      pressTimer = setTimeout(() => {
        editingItem = item;
        // Populate dialog
        descText.value = item.desc || '';
        descInitials.value = item.tech || ''; // NEW: Populate initials
        const dt = item.whenISO ? new Date(item.whenISO) : (item.created ? new Date(item.created) : new Date());
        // Adjust to local ISO for datetime-local input
        descWhen.value = new Date(dt.getTime() - dt.getTimezoneOffset() * 60000).toISOString().slice(0, 19);
        descPosition.value = fmtBNGDisplay(item.gps);
        
        // CHANGED: Lock position AND date fields visually when editing
        descWhen.disabled = true;
        descWhen.style.opacity = '0.5';
        descPosition.disabled = true;
        descPosition.style.opacity = '0.5';
        descPosition.readOnly = true;

        // Show lock button and reset to locked state
        if(btnUnlockMeta) {
          btnUnlockMeta.style.display = 'inline-flex';
          btnUnlockMeta.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;
        }
        
        const header = descDialog.querySelector('header strong');
        if(header) header.textContent = 'Edit description';
        
        descDialog.showModal();
        if(navigator.vibrate) navigator.vibrate(40);
      }, 600);
    });
    card.addEventListener('pointerup', cancelPress);
    card.addEventListener('pointerleave', cancelPress);
    card.addEventListener('pointercancel', cancelPress);
    // End long press logic

    // Lazy load logic
    const preview = createPreviewCanvas(item);
    let c;
    
    if (preview) {
      c = document.createElement('canvas');
      c.width = preview.width;
      c.height = preview.height;
      c.getContext('2d').drawImage(preview, 0, 0);
    } else {
      // Placeholder
      c = document.createElement('canvas');
      c.width = 300;
      c.height = 225;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#1f2937';
      ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle = '#4b5563';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Loading...', c.width/2, c.height/2);
    }

    const meta=document.createElement('div'); meta.className='meta';
    const when=item.whenISO?new Date(item.whenISO):new Date(item.created);
    let gpsText = '';
    if(item.gps){
      // CHANGED: Handle imported items (accuracy 0)
      const isImport = isImportedGPS(item.gps);
      const suffix = isImport ? ' *' : '';

      if(typeof item.gps.bngE !== 'undefined'){
        // CHANGED: Show only BNG on gallery cards (no Lat/Lon)
        const acc = (!isImport && item.gps.accuracy && item.gps.accuracy > 0) ? ` (~${Math.round(item.gps.accuracy)} m)` : '';
        gpsText = ` â€¢ BNG: E ${item.gps.bngE} N ${item.gps.bngN}${suffix}${acc}`;
      }else if(typeof item.gps.lat === 'number' && typeof item.gps.lon === 'number'){
        const acc = (!isImport) ? ` (~${Math.round(item.gps.accuracy||3)} m)` : '';
        gpsText = ` â€¢ Lat ${item.gps.lat.toFixed(6)}, Lon ${item.gps.lon.toFixed(6)}${suffix}${acc}`;
      }
    }
    meta.innerHTML = `<div><strong>${escapeHTML(item.desc||'(no description)')}</strong><span class="badge">${item.w||'?'}Ã—${item.h||'?'}</span></div>
      <small>${when.toLocaleString()}${gpsText} â€¢ ${escapeHTML(item.tech||'')} â€¢ ${escapeHTML(item.loc||'')}</small>`;
    
    // NEW: replace button (top-left)
    const replaceBtn = document.createElement('button');
    replaceBtn.type = 'button';
    replaceBtn.className = 'replace-btn';
    replaceBtn.title = 'Replace this image';
    replaceBtn.setAttribute('aria-label','Replace this image');
    replaceBtn.innerHTML = `
      <svg viewBox="0 0 24 24" aria-hidden="true" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="7" width="18" height="12" rx="2"></rect>
        <path d="M7 7l2-3h6l2 3"></path>
        <circle cx="12" cy="13" r="4"></circle>
      </svg>`;
    replaceBtn.addEventListener('click', () => {
      const picker = document.createElement('input');
      picker.type = 'file';
      picker.accept = 'image/*';
      picker.style.display = 'none';
           document.body.appendChild(picker);
      picker.addEventListener('change', async () => {
        const file = picker.files?.[0];
        if (!file) { picker.remove(); return; }
        try {
          const maxW = 1920;
          // CHANGED: Always preserve orientation for single replace (pass false)
          const canvas = await normalizeImage(file, maxW, false);
          
          // CHANGED: Store as Blob
          const blob = await canvasToBlob(canvas, 0.9);
          item.blob = blob;
          delete item.dataURL; // Remove legacy dataURL if present
          if (item._objectURL) URL.revokeObjectURL(item._objectURL);
          item._objectURL = URL.createObjectURL(blob);

          item.w = canvas.width;
          item.h = canvas.height;
          item._preview = createThumbnailFromCanvas(canvas); // CHANGED: Store thumbnail only
          
          // CHANGED: Patch item only (no session rewrite)
          await saveItem(item);
          renderGallery();
        } catch ( err) {
          alert('Failed to replace image: ' + err.message);
          console.error(err);
        } finally {
          picker.remove();
        }
      }, { once: true });
      picker.click();
    });

    // NEW: Rotate button
    const rotateBtn = document.createElement('button');
    rotateBtn.type = 'button';
    rotateBtn.className = 'rotate-btn';
    rotateBtn.title = 'Rotate 90Â°';
    rotateBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`;
    rotateBtn.addEventListener('click', async () => {
        const img = new Image();
        img.onload = async () => {
            // FIX: Use actual image dimensions, not stored metadata, to prevent skewing
            const w = img.width;
            const h = img.height;
            const canvas = document.createElement('canvas');
            canvas.width = h;  // Swap dimensions
            canvas.height = w;
            
            const ctx = canvas.getContext('2d');
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(90 * Math.PI / 180);
            ctx.drawImage(img, -w/2, -h/2);
            
            // CHANGED: Store as Blob
            const blob = await canvasToBlob(canvas, 0.9);
            item.blob = blob;
            delete item.dataURL;
            if (item._objectURL) URL.revokeObjectURL(item._objectURL);
            item._objectURL = URL.createObjectURL(blob);

            item.w = canvas.width;
            item.h = canvas.height;
            item._preview = createThumbnailFromCanvas(canvas); 
            
            // FIX: Ensure saveItem exists (see helper added above)
            await saveItem(item);
            renderGallery();
        };
        // Handle Blob or DataURL source
        if (item.blob) {
            if (!item._objectURL) item._objectURL = URL.createObjectURL(item.blob);
            img.src = item._objectURL;
        } else {
            img.src = item.dataURL;
        }
    });

    // Updated delete button (uses CSS class, removed duplicate appends)
    const deleteBtn = document.createElement('button');
    deleteBtn.type='button';
    deleteBtn.className='delete-btn';
    deleteBtn.title='Delete this image';
    deleteBtn.setAttribute('aria-label','Delete this image');
    deleteBtn.innerHTML = `
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2"/>
        <path d="M10 11v6M14 11v6" stroke="#f87171" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    deleteBtn.addEventListener('click', async () => {
      if (!confirm('Delete this image from this collection?')) return;
      const index = state.items.indexOf(item);
      if (index > -1) {
        // CHANGED: Revoke URL on delete
        if (item._objectURL) URL.revokeObjectURL(item._objectURL);
        
        // CHANGED: Delete from store and update session
        await idbDelete(STORE, item.id);
        state.items.splice(index, 1);
        saveGlobalsToSession(activeSessionId); // Updates ID list
        renderGallery();
      }
    });

    card.appendChild(c);
    card.appendChild(meta);
    card.appendChild(replaceBtn);
    card.appendChild(rotateBtn); // NEW
    card.appendChild(deleteBtn);
    gallery.appendChild(card);
  });
  const countEl = document.getElementById('count');
  countEl.textContent = fmtCount(state.items.length);
}

fileInput.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{
    const maxW = 1920; 
    // CHANGED: Always preserve orientation for single capture (pass false)
    pendingCanvas = await normalizeImage(f, maxW, false);
    // NEW: Create blob immediately
    pendingBlob = await canvasToBlob(pendingCanvas, 0.9);

    // NEW: Extract EXIF Data (Date & Location)
    let exifGPS = null;
    let exifDate = null;
    try {
      const tags = await getExifData(f);
      exifDate = parseExifDate(tags);
      const loc = parseExifLocation(tags);
      if (loc) {
        // CHANGED: mirror single capture EXIF â†’ BNG logic
        try {
          const bng = latLonToBNG(loc.lat, loc.lon);
          exifGPS = { lat: loc.lat, lon: loc.lon, accuracy: 0, bngE: bng.easting, bngN: bng.northing, source: 'exif' };
        } catch (convErr) {
          console.warn('Bulk EXIF BNG conversion failed, falling back to lat/lon', convErr);
          exifGPS = { lat: loc.lat, lon: loc.lon, accuracy: 0, source: 'exif' };
        }
      }
    } catch(ex) { console.warn('EXIF extraction failed', ex); }

    // NEW: Location handling differs for camera vs gallery imports (respect explicit mode)
    const isGalleryCapture = captureMode === 'gallery';
    const isCameraCapture = !isGalleryCapture;
    pendingGPS = null;
    locationTaskID++;
    const myTaskID = locationTaskID;
    shutterGPSPromise = isCameraCapture ? (shutterGPSPromise || captureShutterLocation()) : null;

    if (isGalleryCapture) {
      isLocationPending = false;
      // Gallery imports should ONLY use existing photo metadata, never live GPS
      if (exifGPS) {
        pendingGPS = exifGPS;
        if (descPosition) descPosition.value = fmtBNGDisplay(exifGPS);
      } else if (descPosition) {
        descPosition.value = 'No location data available';
      }
    } else {
      isLocationPending = true;
      if (descPosition) descPosition.value = 'Pending location...';

      (async () => {
        try{
          const perm = navigator.permissions ? await navigator.permissions.query({ name:'geolocation' }) : null;
          if (perm && perm.state === 'denied') {
            if (exifGPS) {
              pendingGPS = exifGPS;
              if(locationTaskID === myTaskID && descPosition) descPosition.value = fmtBNGDisplay(exifGPS);
            } else if(locationTaskID === myTaskID && descPosition) {
              descPosition.value = 'No location data available';
            }
            if (locationTaskID === myTaskID) isLocationPending = false;
            return;
          }

          const livePos = await (shutterGPSPromise || captureShutterLocation());
          shutterGPSPromise = null;
          if(locationTaskID !== myTaskID) return;

          if(livePos){
            pendingGPS = livePos;
            lastKnownPos = livePos;
          } else if (exifGPS){
            pendingGPS = exifGPS;
          }

          if(locationTaskID === myTaskID && descPosition){
            if (pendingGPS) {
              descPosition.value = fmtBNGDisplay(pendingGPS);
            } else {
              descPosition.value = 'No location data available';
            }
          }
        }catch(e){
          console.warn('Permission check / geolocation failed', e);
        }finally{
          if(locationTaskID === myTaskID) {
            isLocationPending = false;
          }
        }
      })();
    }
    
    // NEW: Reset edit state for new capture
    editingItem = null;

    // CHANGED: Unlock fields for live updates (new capture)
    if(descWhen) {
      descWhen.disabled = false;
      descWhen.style.opacity = '1';
    }
    if(descPosition) {
      descPosition.disabled = false;
      descPosition.style.opacity = '1';
      descPosition.readOnly = true; // Keep readonly for auto-fill
    }
    // Hide lock button for new captures
    if(btnUnlockMeta) btnUnlockMeta.style.display = 'none';

    const header = descDialog.querySelector('header strong');
    if(header) header.textContent = 'Add description';

    if(descText) descText.value='';
    if(descInitials) descInitials.value = state.photographerInitials || ''; // NEW: Auto-fill from memory
    
    // CHANGED: Use EXIF date if available, else now
    const dateToUse = exifDate || new Date();
    if(descWhen) descWhen.value = new Date(dateToUse.getTime()-dateToUse.getTimezoneOffset()*60000).toISOString().slice(0,19);
    
    descDialog.showModal();
  }catch(err){ alert('Failed to process image: '+err); }
  finally{ fileInput.value=''; }
});

// NEW: Bulk upload handlers
if (btnBulkUpload && bulkInput) {
  btnBulkUpload.addEventListener('click', () => bulkInput.click());
  
  bulkInput.addEventListener('change', (e) => {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;
    
    pendingBulkFiles = files;
    if(bulkMsg) bulkMsg.textContent = `Selected ${files.length} photo${files.length===1?'':'s'}.`;
    
    // Load preference
    const saved = localStorage.getItem('cfgRotate');
    if (saved !== null && chkBulkRotate) chkBulkRotate.checked = (saved === 'true');
    
    if(bulkDialog) bulkDialog.showModal();
  });
}

if (btnBulkCancel) {
    btnBulkCancel.addEventListener('click', () => {
        pendingBulkFiles = [];
        bulkInput.value = '';
        bulkDialog.close();
    });
}

if (btnBulkOk) {
    btnBulkOk.addEventListener('click', async () => {
        bulkDialog.close();
        const files = pendingBulkFiles;
        if (files.length === 0) return;

        // Save preference
        if(chkBulkRotate) localStorage.setItem('cfgRotate', chkBulkRotate.checked);

        // Ensure active session
        if(!activeSessionId || !sessions[activeSessionId]){
            try{
                activeSessionId = await createNewSession();
            }catch(err){
                alert('Could not create session.');
                return;
            }
        }

        let processed = 0;
        const total = files.length;
        const originalContent = btnBulkUpload.innerHTML;
        btnBulkUpload.textContent = `Processing 0/${total}...`;
        btnBulkUpload.disabled = true;

        try {
            for (const f of files) {
                try {
                    const maxW = 1920;
                    // Use checkbox state
                    const rotate = chkBulkRotate ? chkBulkRotate.checked : false;
                    const canvas = await normalizeImage(f, maxW, rotate);
                    
                    // NEW: Extract EXIF Data
                    let itemGPS = null;
                    let itemDate = new Date();
                    try {
                        const tags = await getExifData(f);
                        const eDate = parseExifDate(tags);
                        if(eDate) itemDate = eDate;
                        
                        const loc = parseExifLocation(tags);
                        if(loc) {
                            // CHANGED: mirror single capture EXIF â†’ BNG logic
                            try {
                                const bng = latLonToBNG(loc.lat, loc.lon);
                                itemGPS = { lat: loc.lat, lon: loc.lon, accuracy: 0, bngE: bng.easting, bngN: bng.northing, source: 'exif' };
                            } catch (convErr) {
                                console.warn('Bulk EXIF BNG conversion failed, falling back to lat/lon', convErr);
                                itemGPS = { lat: loc.lat, lon: loc.lon, accuracy: 0, source: 'exif' };
                            }
                        }
                    } catch(e) { console.warn('Bulk EXIF fail', e); }

                    // CHANGED: Store as Blob
                    const blob = await canvasToBlob(canvas, 0.9);
                    
                    const item = {
                        blob: blob, // Store blob
                        w: canvas.width,
                        h: canvas.height,
                        desc: '', 
                        whenISO: itemDate.toISOString(), // CHANGED: Use EXIF date
                        tech: state.photographerInitials || '',
                        loc: '',
                        created: new Date().toISOString(),
                        gps: itemGPS // CHANGED: Use EXIF GPS
                    };

                    const id = await idbAdd(item);
                    item.id = id;
                    item._preview = createThumbnailFromCanvas(canvas); // CHANGED: Store thumbnail only
                    
                    // CHANGED: Add to state so it appears in gallery and session save
                    state.items.push(item);
                    
                    renderGallery();
                    processed++;
                    btnBulkUpload.textContent = `Processing ${processed}/${total}...`;
                    await new Promise(r => setTimeout(r, 10));
                } catch (err) {
                    console.error('Failed to process a file in bulk upload', err);
                }
            }
            saveGlobalsToSession(activeSessionId); // Save ID list once
            renderGallery();
        } catch (err) {
            alert('Error during bulk upload: ' + err.message);
        } finally {
            btnBulkUpload.innerHTML = originalContent;
            btnBulkUpload.disabled = false;
            bulkInput.value = '';
            pendingBulkFiles = [];
        }
    });
}

descCancel.addEventListener('click', ()=>{ pendingCanvas=null; pendingBlob=null; pendingGPS=null; editingItem=null; descDialog.close(); });
descOK.addEventListener('click', async ()=>{
  // NEW: Handle edit save
  if (editingItem) {
    editingItem.desc = descText.value.trim();
    
    // Update initials and sync to global state (remember for next time)
    const newInitials = descInitials.value.trim();
    editingItem.tech = newInitials;
    if(newInitials) {
      state.photographerInitials = newInitials;
    }

    if (descWhen.value) editingItem.whenISO = new Date(descWhen.value).toISOString();
    
    // CHANGED: Patch item only (Optimized)
    await saveItem(editingItem);
    renderGallery();
    
    editingItem = null;
    descDialog.close();
    return;
  }

  if(!pendingCanvas) { descDialog.close(); return; }

  // NEW: Check for pending location
  if(isLocationPending) {
    if (!confirm('Location information is still being acquired. Save without location?')) {
        return;
    }
    // If user confirms, proceed to save (pendingGPS will be null or partial)
  }

  // Ensure we have an active session to save into. Create one if needed.
  if(!activeSessionId || !sessions[activeSessionId]){
    try{
      // createNewSession activates the session and returns its id
      activeSessionId = await createNewSession();
    }catch(err){
      console.error('Failed to create a new collection/session', err);
      alert('Unable to save image: could not create a collection.');
      return;
    }
  }

  // Update global state with whatever is in the box now (remember for next time)
  const currentInitials = descInitials.value.trim();
  if(currentInitials) {
      state.photographerInitials = currentInitials;
  }

  // CHANGED: Use pendingBlob
  const item = {
    blob: pendingBlob,
    w: pendingCanvas.width,
    h: pendingCanvas.height,
    desc: descText.value.trim(),
    whenISO: descWhen.value? new Date(descWhen.value).toISOString(): null,
    // CHANGED: Use the dialog value
    tech: currentInitials,
    loc: '', // free-text location removed â€” keep empty, GPS stored under gps    
    created: new Date().toISOString(),
    gps: pendingGPS // may be null if unavailable
  };

  // Legacy store write
  const id = await idbAdd(item);
  item.id = id;
  item._preview = createThumbnailFromCanvas(pendingCanvas); // CHANGED: Store thumbnail only

  // Add to in-memory state and persist into the active session
  state.items.push(item);
  saveGlobalsToSession(activeSessionId); // Persist session (ID list)
  renderGallery();

  pendingCanvas = null;
  pendingBlob = null;
  pendingGPS = null;
  descDialog.close();
});
 
// do NOT start watching automatically â€” require user gesture
async function openCollectionsPanel() {
  const panel = document.getElementById('collections');
  if (!panel) {
    console.error('Collections panel not found');
    return;
  }
  panel.classList.add('open');
  panel.setAttribute('aria-hidden', 'false');
  document.body.classList.add('collections-open');
}

async function closeCollectionsPanel() {
  const panel = document.getElementById('collections');
  if (!panel) {
    console.error('Collections panel not found');
    return;
  }
  panel.classList.remove('open');
  panel.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('collections-open');
}

/* ---------- Startup ---------- */
document.addEventListener('DOMContentLoaded', () => {
  (async function init(){
    await loadPersistedSessions();
       // NEW: check for saved directory handle on startup
    if ('showDirectoryPicker' in window) {
      const savedHandle = await getDirectoryHandle();
      if (savedHandle) {
        // Verify we still have permission. This doesn't prompt the user.
        try {
          const permStatus = await savedHandle.requestPermission({ mode: "readwrite" });
          if (permStatus === "granted") {
            // And verify the handle is still usable by trying a non-destructive read.
            try {
              // `keys()` is a simple async iterator to check usability.
              // We don't need to do anything with the result.
              // If this fails, the handle is stale.
              await savedHandle.keys().next(); 
              dirHandle = savedHandle;
              folderStatus.textContent = `Status: Saving to "${dirHandle.name}" folder.`;
            } catch (e) {
              console.warn('Stale directory handle, re-selection needed.', e);
              folderStatus.textContent = `Status: Re-select "${savedHandle.name}" to grant access.`;
              dirHandle = null;
            }
          } else {
            // Permission was not persisted or was revoked. User must re-grant it.
            folderStatus.textContent = `Status: Permission needed for "${savedHandle.name}". Click "Choose Folder" to re-enable.`;
            dirHandle = null; // Clear the stale handle.
          }
        } catch (err) {
          console.error('Failed to check saved directory handle:', err);
        }
      }
    }
  })();

  const headerRow1 = document.querySelector('.header-row-1');
  window.addEventListener('scroll', () => {
    if (!headerRow1) return;
    if (window.scrollY > 80) headerRow1.classList.add('is-hidden');

    else headerRow1.classList.remove('is-hidden');
  });
});


btnClear?.addEventListener('click', async ()=>{
  if(!confirm('Clear all images from the current collection?')) return;
  // CHANGED: Revoke all URLs before clearing
  state.items.forEach(i => { if(i._objectURL) URL.revokeObjectURL(i._objectURL); });
  state.items = [];
  saveGlobalsToSession(activeSessionId);
  renderGallery();
});

/* ---------- Export helpers that return Blobs ---------- */
async function buildPPTXBlob(fileName){
  const includeTimestamp    = attrTimestampChk?.checked !== false;
  const includePosition     = attrPositionChk?.checked !== false;
  const includeAccuracy     = attrAccuracyChk?.checked !== false;
  const includePhotographer = attrPhotographerChk?.checked !== false;
  const autoSortEnabled     = !!(chkAutoSort && chkAutoSort.checked);
  const noMixEnabled        = autoSortEnabled && !!(chkNoMix && chkNoMix.checked);
  const photographerInitials = (state.photographerInitials || '').trim();

  if(state.items.length===0) { alert('Nothing to export.'); return null; }
  
  // Ensure current session data is saved before export
  saveGlobalsToSession(activeSessionId);

  // NEW: Prepare items list (sorted or original)
  let exportItems = [...state.items];
  if (autoSortEnabled) {
    // Sort by aspect ratio (descending: Wide -> Square -> Tall)
    // This groups Landscape images together and Portrait images together
    exportItems.sort((a, b) => {
      const ratioA = (a.w || 1) / (a.h || 1);
      const ratioB = (b.w || 1) / (b.h || 1);
      return ratioB - ratioA;
    });
  }

  const layout = parseInt(layoutSel.value,10); // 1,2,4
  const perSlide = layout;
  
  // CHANGED: Grouping logic to support NoMix
  const groups = []; 
  if (noMixEnabled) {
    let currentGroup = [];
    let currentType = null; // 'L' or 'P'
    
    for (const item of exportItems) {
      const type = (item.w >= item.h) ? 'L' : 'P';
      
      // If group is full OR (group has items AND orientation changes), flush group
      if (currentGroup.length > 0 && (currentGroup.length >= perSlide || type !== currentType)) {
        groups.push(currentGroup);
        currentGroup = [];
      }
      
      if (currentGroup.length === 0) {
        currentType = type;
      }
      currentGroup.push(item);
    }
    if (currentGroup.length > 0) groups.push(currentGroup);
  } else {
    for(let i=0;i<exportItems.length;i+=perSlide) groups.push(exportItems.slice(i,i+perSlide));
  }

  // Create a fresh presentation (do not attempt to load a template)
  const pptx = new PptxGenJS();
  try{
    pptx.defineLayout({ name:'A4PORTRAIT', width:8.27, height:11.69 });
    pptx.defineLayout({ name:'A4LANDSCAPE', width:11.69, height:8.27 });
  }catch(e){/*ignore*/}

  const isLandscape = (orientationSel && orientationSel.value === 'landscape');
  try{ pptx.layout = isLandscape ? 'A4LANDSCAPE' : 'A4PORTRAIT'; }catch(e){}

  // Use margins from settings (mm -> inches)
  const marginsMM = 10; // REMOVED: Number(marginsInput.value) || 10;
  const margin = Math.max(0.05, marginsMM / 25.4); // in

  // Slide dimensions based on chosen layout
  const slideW = isLandscape ? 11.69 : 8.27;
  const slideH = isLandscape ? 8.27 : 11.69;

  // Side panel width as proportion of slide width so it scales with orientation
  const sideW = Math.min(2.4, Math.max(1.6, slideW * 0.24)); // clamp to reasonable bounds
  const contentW = slideW - margin*2 - sideW - 0.12; // small gap before side panel
  const contentH = slideH - margin*2;

  // Grid selection: make 2-up side-by-side in landscape, stacked in portrait
  const grid = layout === 1 ? { rows: 1, cols: 1 } : (layout === 2 ? (isLandscape ? { rows: 1, cols: 2 } : { rows: 2, cols: 1 }) : { rows: 2, cols: 2 });
  const cellW = contentW / grid.cols;
  const cellH = contentH / grid.rows;

  // Visual style values
  const blueBar = '8DB2E8';
  const lightGrey = 'F6F8FA';
  const textGrey = '444444';

  // Attempt to load logo data URL once (best-effort). Keep it simple and non-blocking.
  let logoDataUrl = null;
  let logoRatio = null; // NEW: Store aspect ratio
  try{
    const r = await fetch('./brownfield_logo.png', { cache:'no-store' });
    if(r.ok){
      const blob = await r.blob();
      logoDataUrl = await new Promise(res=>{
        const fr = new FileReader();
        fr.onload = ()=>res(fr.result);
        fr.onerror = ()=>res(null);
        fr.readAsDataURL(blob);
      });
      // NEW: Calculate aspect ratio
      if (logoDataUrl) {
        await new Promise(resolve => {
          const img = new Image();
          img.onload = () => { logoRatio = img.width / img.height; resolve(); };
          img.onerror = () => resolve();
          img.src = logoDataUrl;
        });
      }
    }
  }catch(e){ logoDataUrl = null; }

  let slideIndex = 0;
  let globalPhotoIndex = 0; // sequential numbering across slides

  // Insert helper to draw the entire right panel (logo, desc rows, footer fields)
  function addRightPanel(slide, {
    pptx,
    sideX,
    sideW,
    panelTopY,
    panelH,
    textGrey,
    borderBlue,
    panelFill,
    logoDataUrl,
    logoRatio, // NEW: Accept ratio
    pageNumber,
    descItems,        // array of up to 4 { num: 1-based index, text: 'desc...' }
    client,
    project,
    collection,
    photographer,
    includeAccuracy   // NEW: accept accuracy flag
  }) {
    // Internal layout constants
    const innerPadX     = 0.18;
    const innerW        = sideW - (innerPadX * 2);
    const headingFontSize = 12;
    const labelFontSize   = 8;
    const fieldFontSize   = 9;
    const descRowH     = 0.4;
    const descGapY     = 0.08;
    const logoBlockH   = 0.9;
    const postLogoGap  = 0.25;
    const footerLabelH = 0.1;
    const footerBoxH   = 0.27;
    const footerGapY   = 0.15;
    const labelBoxGap  = 0.075; // Increased by 50% from 0.05 to reduce overlap

    // 1. Panel background
    slide.addShape(pptx.ShapeType.rect, { x: sideX, y: panelTopY, w: sideW, h: panelH, fill: { color: panelFill } });

    // --- Top 50% section (Descriptions) ---
    let yCursor = panelTopY + 0.2;
    slide.addText('Photo Descriptions', { x: sideX + innerPadX, y: yCursor, w: innerW, h: 0.3, fontSize: headingFontSize, bold: true, color: textGrey, align: 'left', valign: 'top' });
    yCursor += 0.4;

    // NEW: Dynamic height estimation constants
    const charsPerLine = Math.floor(innerW * 14); // Conservative estimate (approx 14 chars/inch for 9pt)
    const lineHeight = 0.15; 
    const boxPadding = 0.1;

    for (let i = 0; i < 4; i++) {
      const item = descItems[i];
      
      // CHANGED: Prepare text payload as array to support bold number + colon
      let textPayload = '';
      let totalLen = 0;

      if (item) {
        textPayload = [
          { text: `${item.num}: `, options: { bold: true } },
          { text: item.text || '' }
        ];
        totalLen = String(item.num).length + 2 + (item.text || '').length;
      }
      
      // NEW: Calculate height based on text length to auto-expand
      let boxH = descRowH;
      if (totalLen > 0) {
        const lines = Math.ceil(totalLen / charsPerLine);
        // If text needs more than 2 lines (approx capacity of standard box), expand
        if (lines > 2) {
          boxH = Math.max(descRowH, (lines * lineHeight) + boxPadding);
        }
      }

      // CHANGED: Use addText with shape property so text is part of the box
      slide.addText(textPayload, {
        shape: pptx.ShapeType.rect,
        x: sideX + innerPadX,
        y: yCursor,
        w: innerW,
        h: boxH,
        fill: { color: 'FFFFFF' },
        line: { color: borderBlue },
        color: textGrey,
        fontSize: fieldFontSize,
        align: 'left',
        valign: 'top',
        inset: 0.05
      });
      
      yCursor += boxH + descGapY;
    }

    // NEW: Add GPS note below descriptions ONLY if accuracy is enabled
    if (includeAccuracy) {
      slide.addText("Positions are collected via GPS with the approximate accuracy shown in square brackets", {
        x: sideX + innerPadX,
        y: yCursor,
        w: innerW,
        h: 0.3,
        fontSize: 7,
        color: textGrey,
        align: 'left',
        valign: 'top'
      });
      yCursor += 0.3;
    }

    // --- Bottom 50% section (Logo and Footer Fields) ---
    
    // Helper to calc height for footer fields (uses charsPerLine/lineHeight from descriptions logic)
    const calcFieldH = (val) => {
      const len = (val || '').length;
      if (len === 0) return footerBoxH;
      const lines = Math.ceil(len / charsPerLine);
      // Expand if text wraps (approx > 1 line). 0.27 is base.
      return Math.max(footerBoxH, (lines * lineHeight) + boxPadding);
    };

    const hClient = calcFieldH(client);
    const hProject = calcFieldH(project);
    const hCollection = calcFieldH(collection);
    const hPhotographer = calcFieldH(photographer);

    // Calculate total footer height dynamically
    const getBlockH = (boxH) => footerLabelH + labelBoxGap + boxH + footerGapY;
    
    const totalFooterH = (logoBlockH + postLogoGap) 
                       + getBlockH(hClient) 
                       + getBlockH(hProject) 
                       + getBlockH(hCollection) 
                       + getBlockH(hPhotographer);

    // Target start Y: Bottom of panel minus page number space (approx 0.5) minus visual height
    // (visual height is totalFooterH minus the trailing gap from the last field)
    const targetFooterStartY = (panelTopY + panelH) - 0.5 - (totalFooterH - footerGapY);
    
    // Use the calculated bottom-aligned Y, unless descriptions push it further down
    let footerCursor = Math.max(targetFooterStartY, yCursor + 0.1);

    // Logo
    if (logoDataUrl) {
      let w = innerW;
      let h = logoBlockH;
      // CHANGED: Maintain aspect ratio if known to prevent stretching
      if (logoRatio) {
        h = w / logoRatio;
        if (h > logoBlockH) {
          h = logoBlockH;
          w = h * logoRatio;
        }
      }
      slide.addImage({ data: logoDataUrl, x: sideX + innerPadX, y: footerCursor, w: w, h: h });
    } else {
      slide.addText('BROWNFIELD\nSOLUTIONS', { x: sideX + innerPadX, y: footerCursor + 0.1, w: innerW, h: logoBlockH, fontSize: 12, bold: true, color: textGrey, align: 'left', valign: 'top' });
    }
    footerCursor += logoBlockH + postLogoGap;

    // Footer Fields
    function drawFooterField(label, value, height) {
      slide.addText(label, { x: sideX + innerPadX, y: footerCursor, w: innerW, h: footerLabelH, fontSize: labelFontSize, bold: true, color: textGrey, align: 'left', valign: 'top' });
      const boxY = footerCursor + footerLabelH + labelBoxGap;
      
      // CHANGED: Use addText with shape property so text is part of the box
      slide.addText(value || '', {
        shape: pptx.ShapeType.rect,
        x: sideX + innerPadX,
        y: boxY,
        w: innerW,
        h: height,
        fill: { color: 'FFFFFF' },
        line: { color: borderBlue },
        color: textGrey,
        fontSize: fieldFontSize,
        align: 'left',
        valign: 'top',
        inset: 0.05
      });

      footerCursor += footerLabelH + labelBoxGap + height + footerGapY;
    }

    // CHANGED LABELS FOR EXPORT FOOTER
    drawFooterField('CLIENT', client || '', hClient);
    drawFooterField('JOB NO.', project || '', hProject);
    drawFooterField('JOB NAME', collection || '', hCollection);
    drawFooterField('PHOTOBOARD TITLE', photographer || '', hPhotographer);

    // Page number (remains at the absolute bottom of the panel)
    slide.addText(`Page ${pageNumber}`, { x: sideX, y: panelTopY + panelH - 0.3, w: sideW - 0.1, h: 0.2, fontSize: 8, color: textGrey, align: 'right' });
   }

  const activeSession = sessions[activeSessionId] || {};
  for(const group of groups){
    slideIndex++;
    const slide = pptx.addSlide();

    // Background
    try{ slide.addShape(pptx.ShapeType.rect, { x:0, y:0, w:slideW, h:slideH, fill:{ color:'FFFFFF' } }); }catch(e){}

    // Right-hand panel background (keep panel background creation for compatibility)
    const sideX = slideW - margin - sideW;
    try{ slide.addShape(pptx.ShapeType.rect, { x: sideX, y: margin, w: sideW, h: contentH, fill:{ color: lightGrey } }); }catch(e){}

    // NEW: Check if all images in this group are portrait to optimize vertical space
    const allPortrait = group.every(i => (i.h > i.w));

    // Add images to the slide
    // CHANGED: Use for...of loop to support await
    for (const [idx, item] of group.entries()) {
      const r = Math.floor(idx / grid.cols);
      const c = idx % grid.cols;
      const cellX = margin + c * cellW;
      const cellY = margin + r * cellH;

      // CHANGED: Optimize maxImageH for portrait-only pages
      // Standard: 80% of cell height.
      // Optimized: Cell height minus fixed text allowance (approx 0.65 inches for caption + gap)
      // This allows portrait images in 4-up grids to be taller.
      const textAllowance = 0.65; 
      const maxImageH = allPortrait ? Math.max(cellH * 0.8, cellH - textAllowance) : (cellH * 0.8);
      
      // Calculate scaled image size to fit within cellW and maxImageH, preserving aspect ratio
      const imgAspect = item.w / item.h;
      let imgW = cellW;
      let imgH = imgW / imgAspect;
      
      // Fit to height constraint
      if (imgH > maxImageH) {
        imgH = maxImageH;
        imgW = imgH * imgAspect;
      }
      // Fit to width constraint (safety check)
      if (imgW > cellW) {
        imgW = cellW;
        imgH = imgW / imgAspect;
      }

      // Center the image horizontally
      const imgX = cellX + (cellW - imgW) / 2;
      
      // CHANGED: Center the image vertically within the allocated image area
      // This ensures portrait images float in the middle rather than sticking to the top
      const imgY = cellY + (maxImageH - imgH) / 2;
      
      try {
        // CHANGED: Convert Blob to DataURL for PPTX generation if needed
        let imgData = item.dataURL;
        if (!imgData && item.blob) {
          imgData = await blobToDataURL(item.blob);
        }
        if (imgData) {
          slide.addImage({ data: imgData, x: imgX, y: imgY, w: imgW, h: imgH });
        }
      } catch (e) {
        console.warn('Failed to add image to slide', e);
      }

      // --- NEW caption logic: two lines (Photo + timestamp, then BNG/coords) ---
      globalPhotoIndex++;
      const dt = item.whenISO ? new Date(item.whenISO) : (item.created ? new Date(item.created) : new Date());
      // Locale-friendly compact timestamp (DD/MM/YYYY HH:MM)
      const ts = dt.toLocaleString(undefined, {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      }).replace(',', '');

      // Line 1: Photo number + optional timestamp + optional photographer initials
      let line1 = `Photo ${globalPhotoIndex}`;
      if (includeTimestamp) {
        line1 += ` â€“ ${ts}`;
        if (includePhotographer && photographerInitials) {
          line1 += ` â€“ ${photographerInitials}`;
        }
      }

      // Line 2 (position + optional accuracy)
      let line2 = '';
      if (item.gps) {
        const isImport = isImportedGPS(item.gps);
        const suffix = isImport ? ' *' : '';

        if (includePosition) {
          if (typeof item.gps.bngE !== 'undefined') {
            line2 = `BNG: E ${item.gps.bngE} N ${item.gps.bngN}${suffix}`;
          } else if (typeof item.gps.lat === 'number' && typeof item.gps.lon === 'number') {
            line2 = `Lat ${item.gps.lat.toFixed(6)}, Lon ${item.gps.lon.toFixed(6)}${suffix}`;
          }
        }
        
        // CHANGED: Only show accuracy if NOT imported
        if (!isImport && includeAccuracy && typeof item.gps.accuracy === 'number' && !isNaN(item.gps.accuracy)) {
          const accStr = `[~${Math.round(item.gps.accuracy)} m]`;
          line2 = line2 ? `${line2} ${accStr}` : accStr;
        }
      }

      const captionText = line2 ? `${line1}\n${line2}` : line1;

      // Calculate text position relative to the actual image position
      const textY = imgY + imgH + 0.05;
      // Ensure text box doesn't exceed cell bounds
      const textH = Math.max(0.3, (cellY + cellH) - textY);

      slide.addText(captionText, {
        x: cellX + 0.05,
        y: textY,
        w: cellW - 0.1,
        h: textH,
        fontSize: 8,
        color: textGrey,
        align: 'center',
        valign: 'top'
      });
    } // End group loop

    // Build descItems for this slide using the sequential globalPhotoIndex.
    // globalPhotoIndex was incremented while adding images above.
    const startNum = Math.max(1, globalPhotoIndex - group.length + 1);
    const descItems = group.map((item, idx) => ({
      num: startNum + idx,
      text: (item.desc || '').replace(/\r?\n/g, ' ')
    }));

    // Draw the entire right panel using the helper (logo, desc rows, footer fields, page number)
    addRightPanel(slide, {
      pptx,
      sideX,
      sideW,
      panelTopY: margin,
      panelH: contentH,
      textGrey,
      borderBlue: blueBar,
      panelFill: lightGrey,
      logoDataUrl,
      logoRatio, // NEW: Pass ratio
      pageNumber: slideIndex,
      descItems,
      // CHANGED: Force uppercase for project details
      client:       (activeSession.client || '').toUpperCase(),
      project:      (activeSession.project || '').toUpperCase(),
      collection:   (activeSession.name || '').toUpperCase(),
      photographer: (activeSession.photographer || '').toUpperCase(),
      includeAccuracy // NEW: pass the flag
    });

    // Slide number bottom-right outside panel is now handled by addRightPanel; if you still
    // want an extra page text outside, keep previous call (optional).
  }

  // Write blob and ensure PPTX MIME

  try{
    const rawBlob = await pptx.write('blob');
    const pptxMime = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';

    let outBlob = rawBlob;
    try{ if(!rawBlob.type || !rawBlob.type.includes('presentation')) outBlob = new Blob([rawBlob], { type: pptxMime }); }catch(e){ outBlob = rawBlob; }
    
    // NEW: If we have a directory handle, save directly to the file system.
    if (dirHandle && (await dirHandle.queryPermission({ mode: 'readwrite' })) === 'granted') {
      try {
        const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(outBlob);
        await writable.close();
        alert(`Successfully saved "${fileName}" to your chosen directory.`);
        return null; // Indicate that download is not needed
      } catch (err) {
        console.error('Failed to save file directly:', err);
        alert(`Failed to save to directory. Falling back to download.\nError: ${err.message}`);
        // Fall through to return blob for normal download
      }
    }
    
    return outBlob;
  }catch(err){
    console.warn('pptx write(blob) failed, trying fallback writeFile/save', err);
    try{
      const name = fileName || `evidence_${new Date().toISOString().slice(0,10)}_${layoutSel.value}ppA4.pptx`;
      if(typeof pptx.writeFile === 'function'){ await pptx.writeFile({ fileName: name }); return null; }
      else if(typeof pptx.save === 'function'){ await pptx.save(name); return null; }
      else throw err;
    }catch(e){ console.error('pptx fallback failed', e); throw e; }
  }
}
/* local downloads for manual export */
if(btnConfirmExport) {
  btnConfirmExport.addEventListener('click', async ()=>{
    // NEW: Warn about missing logo if not installed
   
    if (!computeInstalled()) {
      if (!confirm("Warning: When running in the browser (not installed), the company logo may not be included in the PowerPoint export due to browser security restrictions.\n\nDo you want to continue?")) {
        return;
      }
    }

    try {
      // Close settings panel on start
      settingsPanel.style.right = '-320px';
      
           
      const fileName = `evidence_${new Date().toISOString().slice(0,10)}_${layoutSel.value}ppA4.pptx`;
      const blob = await buildPPTXBlob(fileName);
      if(!blob) return; // fallback handled download
      const a=document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = fileName;
      a.click();
    } catch (err) {
      alert('PPTX export failed: ' + err.message);
      console.error('PPTX export error:', err);
    }
  });
}
</script>

<script>
/* ---------- Session Manager (clean implementation) ---------------- */
const sessions = {};           // id -> session object
let activeSessionId = null;

// NEW: Helper to save current global state into the session object
// CHANGED: Now saves only metadata and item IDs (lightweight)
async function saveGlobalsToSession(id) {
  if (!id || !sessions[id]) return;
  const s = sessions[id];
  
  // Sync state to session object
  // CHANGED: Map items to IDs only
  s.items = state.items.map(i => i.id);
  
  s.client = state.client;
  s.project = state.project;
  s.photographer = state.photographer;
  s.photographerInitials = state.photographerInitials;
  
  // Ensure title is synced if this is the active session
  if (id === activeSessionId && collectionTitleInput) {
    s.name = collectionTitleInput.value.trim() || s.name;
  }

  s.lastModified = Date.now(); // NEW: Update timestamp on save

  await persistSession(s);
}

async function persistSession(session) {
  // ensure session has an id
  if (!session || !session.id) throw new Error('Invalid session');
  await idbAddSession(session);
}

async function createNewSession(fromData = null) {
  const id = Date.now(); // CHANGED: Use numeric ID to play nice with autoIncrement
  const name = fromData?.name || `Collection ${new Date().toLocaleString()}`;
  
  const newSession = {
    id,
    name,
    client: fromData?.client || '',
    project: fromData?.project || '',
    photographer: fromData?.photographer || '',
    photographerInitials: fromData?.photographerInitials || '',
    lastModified: Date.now(), // NEW: Init timestamp
    items: fromData?.items ? fromData.items.slice() : []
  };
  sessions[id] = newSession;
  await persistSession(newSession);
  await activateSession(id);
  return id;
}

async function importSession(data) {
  const id = Date.now(); // CHANGED: Use numeric ID
  const name = `${data.name || 'Untitled'} (Imported)`;

  // Ensure items array exists and normalise them
  const rawItems = Array.isArray(data.items) 
    ? data.items.map(i => normaliseLegacyItem({ ...i })) 
    : [];

  // NEW: Save items to IDB and get new IDs to ensure persistence works
  const itemIds = [];
  for (const item of rawItems) {
    // Strip old ID to ensure a new one is generated
    delete item.id; 
    // Ensure created date exists
    if (!item.created) item.created = new Date().toISOString();
    
    // OPTIONAL: Convert dataURL to Blob to save space/memory
    if (item.dataURL && !item.blob) {
      try {
        // Ensure dataURLtoBlob is available (defined in previous script block)
        if (typeof dataURLtoBlob === 'function') {
          item.blob = dataURLtoBlob(item.dataURL);
          delete item.dataURL;
        }
      } catch(e) { console.warn('Blob conversion failed', e); }
    }

    // Save to IDB
    const newId = await idbAdd(item);
    itemIds.push(newId);
  }

  // Construct the session object with IDs
  const newSession = {
    id,
    name,
    created: Date.now(),
    lastModified: Date.now(), // NEW: Init timestamp
    items: itemIds, // Contains IDs now
    client: data.client || '',
    project: data.project || '',
    photographer: data.photographer || '',
    photographerInitials: data.photographerInitials || ''
  };

  // 1. INJECT INTO MEMORY
  sessions[id] = newSession;
  
  // 2. INJECT INTO INDEXEDDB
  await idbAddSession(newSession);
  
  // 3. TRIGGER UI UPDATE
  await activateSession(id);
  
  alert(`Imported "${name}" with ${itemIds.length} items.`);
}

async function activateSession(id) {
  if (!id || !sessions[id] || id === activeSessionId) return;
  
  // Persist current session first before switching
  if (activeSessionId && sessions[activeSessionId]) {
    saveGlobalsToSession(activeSessionId);
       // CHANGED: Revoke URLs from the old session to free memory
    state.items.forEach(i => {
      if (i._objectURL) URL.revokeObjectURL(i._objectURL);
    });
  }
  
  await loadSessionToGlobals(id);
}

async function loadSessionToGlobals(id) {
  if (!id || !sessions[id]) return;
 
  const s = sessions[id];
  activeSessionId = id;

  // CHANGED: Hydrate items from IDs
  state.items = [];
  if (s.items && s.items.length > 0) {
    // Check if items are IDs or legacy objects
    if (typeof s.items[0] === 'object') {
      // Legacy: items are embedded
      state.items = s.items.map(i => ({ ...i }));
    } else {
      // New: items are IDs, fetch them
      // We fetch in parallel for speed
      const promises = s.items.map(itemId => idbGet(STORE, itemId));
      const results = await Promise.all(promises);
      state.items = results.filter(i => i); // filter out any missing
    }
  }
  
  // Populate text inputs
  state.client = s.client || '';
  state.project = s.project || '';
  state.photographer = s.photographer || '';
  state.photographerInitials = s.photographerInitials || '';

  collectionTitleInput.value = s.name || '';
  clientNameInput.value = state.client;
  projectTitleInput.value = state.project;
  photographerNameInput.value = state.photographer;
  // REMOVED: photographerInitialsInput.value = state.photographerInitials;

  // PREPARE FOR UI: Mark items for lazy loading
  state.items.forEach(item => {
    // CHANGED: Check for blob OR dataURL
    if ((item.blob || item.dataURL) && !item._preview) {
      item._needsPreview = true; // This triggers createPreviewCanvas() in renderGallery
    }
  });

  // UPDATE UI
  renderGallery();   // Re-draws the grid of photos
  renderSessions();  // Updates the sidebar list
}

function renderSessions() {
  const listEl = document.getElementById('collectionsList');
  if (!listEl) return;
  listEl.innerHTML = '';

  Object.values(sessions).forEach(s => {
    const li = document.createElement('li');
    li.className = 'session-tab' + (s.id == activeSessionId ? ' active' : ''); // CHANGED: Loose equality for ID match

    const albumBtn = document.createElement('button');
    albumBtn.type = 'button';
    albumBtn.className = 'album-btn';
    albumBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
               <rect x="3" y="5" width="18" height="14" rx="2"></rect>
               <path d="M7 11h4l1.5-2 4 5"></path>
               <circle cx="9" cy="14.5" r="2.1"></circle>
             </svg>`;
    if (s.id == activeSessionId) { // CHANGED: Loose equality
      albumBtn.classList.add('active');
      albumBtn.title = 'Current collection';
    } else {
      albumBtn.title = 'Set as current collection';
    }
    albumBtn.addEventListener('click', async ev => {
      ev.stopPropagation();
      if (s.id != activeSessionId) await activateSession(s.id); // CHANGED: Loose equality
    });

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = s.name || '(untitled)';
    nameInput.className = 'tab-name'; // CHANGED class
    // nameInput.style.flex = '1'; // Handled by CSS class now
    nameInput.title = 'Edit collection name';
    nameInput.addEventListener('change', async (ev) => {
      s.name = nameInput.value.trim() || s.name;
      await persistSession(s);
      if (s.id == activeSessionId) collectionTitleInput.value = s.name; // CHANGED: Loose equality
      renderSessions();
    });
    nameInput.addEventListener('click', ev => ev.stopPropagation());

    // NEW: Action buttons container
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'session-actions';

    const exportBtn = document.createElement('button');
    exportBtn.type = 'button';
    exportBtn.className = 'btn-action'; // CHANGED class
    exportBtn.title = 'Export this collection to JSON';
    // CHANGED: Updated SVG to match "external link" style icon
    exportBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>`;
    exportBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      handleExportCollection(s.id);
    });

    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'btn-action delete'; // CHANGED class
    closeBtn.innerHTML = `<svg viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`; // CHANGED to SVG icon
    closeBtn.title = 'Delete collection';
    closeBtn.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      const hasData = s.items && s.items.length > 0;
      const promptMsg = hasData ? 'Delete this collection and all its photos? This cannot be undone.' : 'Delete this empty collection?';
      if (!confirm(promptMsg)) return;
      // delete from memory and IDB
      delete sessions[s.id];
      await idbDeleteSession(s.id);
      // if it was active, pick another or create default
      if (activeSessionId == s.id) { // CHANGED: Loose equality
        const keys = Object.keys(sessions);
        if (keys.length) await activateSession(keys[0]);
        else await createNewSession();
      } else {
        renderSessions();
      }
    });

    li.addEventListener('click', () => { activateSession(s.id); });

    li.appendChild(albumBtn);
    li.appendChild(nameInput);
    
    actionsDiv.appendChild(exportBtn);
    actionsDiv.appendChild(closeBtn); // Moved inside actionsDiv
    li.appendChild(actionsDiv);

    listEl.appendChild(li);
  });

  // Emphasised header summary with album icon that opens Collections panel
  const summary = document.getElementById('tabsSummary');
  if (summary) {
    const name = sessions[activeSessionId]?.name || '';
    summary.innerHTML = name
      ? `<button id="activeCollectionChip" class="collection-chip" title="Open collections">
             <svg viewBox="0 0 24 24" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
               <rect x="3" y="5" width="18" height="14" rx="2"></rect>
               <path d="M7 11h4l1.5-2 4 5"></path>
               <circle cx="9" cy="14.5" r="2.1"></circle>
             </svg>
             <span>${escapeHTML(name)}</span>
           </button>`
        : '';
      const chip = document.getElementById('activeCollectionChip');
      if (chip) {
        chip.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          // open Collections panel
          openCollectionsPanel?.();
        });
      }
    }
  }

  async function loadPersistedSessions() {
    // read all sessions from indexeddb
    const arr = await idbAllSessions();
    if (Array.isArray(arr) && arr.length) {
      arr.forEach(s => { sessions[s.id] = s; }); // CHANGED: Use raw ID (Number)
      
      // NEW: Sort by lastModified (descending) so most recent is first
      // Fallback to ID (creation time) if lastModified is missing
      arr.sort((a, b) => (b.lastModified || b.id) - (a.lastModified || a.id));

      // pick first session as active
      const firstId = arr[0].id; // CHANGED: Use raw ID
      await activateSession(firstId);
    } else {
      // create default session and activate it
      await createNewSession({ name: 'Default Collection' });
    }
    renderSessions();
  }

  /* Wire session UI controls (Collections panel new/close already wired elsewhere) */
  const collectionsPanel = document.getElementById('collections');
  const collectionsClose = document.getElementById('collectionsClose');
  const newCollectionBtn = document.getElementById('newCollectionBtn');
  // NEW: Import button refs
  const importCollectionBtn = document.getElementById('importCollectionBtn');
  const importCollectionInput = document.getElementById('importCollectionInput');

  if (collectionsClose) {
    collectionsClose.addEventListener('click', () => {
      collectionsPanel.classList.remove('open');
      collectionsPanel.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('collections-open');
    });
  }
  if (newCollectionBtn) {
    newCollectionBtn.addEventListener('click', async () => {
      await createNewSession();
      collectionsPanel.classList.remove('open');
      collectionsPanel.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('collections-open');
      collectionTitleInput.focus();
    });
  }

  /* ensure global save on unload */
  window.addEventListener('beforeunload', () => { if (activeSessionId) saveGlobalsToSession(activeSessionId); });

  /* ensure sessions load once DOM is ready (mobile reliable) */
  document.addEventListener('DOMContentLoaded', () => {
    loadPersistedSessions().catch(err => console.error('loadPersistedSessions failed', err));
  });
</script>

<script>
// Save client, project title, and photographer to state on input change
// CHANGED: Apply debounce to all text inputs
const debouncedSave = debounce(() => {
  if (activeSessionId && sessions[activeSessionId]) {
    saveGlobalsToSession(activeSessionId);
  }
}, 500);

clientNameInput.addEventListener('input', () => {
  state.client = (clientNameInput.value || '').trim();
  debouncedSave();
});

projectTitleInput.addEventListener('input', () => {
  state.project = (projectTitleInput.value || '').trim();
  debouncedSave();
});

photographerNameInput.addEventListener('input', () => {
  state.photographer = (photographerNameInput.value || '').trim();
  debouncedSave();
});

collectionTitleInput.addEventListener('input', () => {
  const name = (collectionTitleInput.value || '').trim();
  if (activeSessionId && sessions[activeSessionId]) {
    sessions[activeSessionId].name = name || sessions[activeSessionId].name;
    debouncedSave();
    // update the sessions UI to reflect the new name (immediate feedback)
    renderSessions();
  }
});

// NEW: Import/Export handlers
async function handleExportCollection(sessionId) {
  const session = sessions[sessionId];
  if (!session) {
    alert('Collection not found.');
    return;
  }
  // Ensure the latest data is in the session object before exporting
  if (sessionId === activeSessionId) {
    saveGlobalsToSession(sessionId);
  }
  
  // CHANGED: Deep clone and convert blobs to base64 for JSON export
  const sessionData = JSON.parse(JSON.stringify(sessions[sessionId])); // Clone structure
  
  // Re-attach items from source because JSON.stringify dropped blobs
  // We need to manually convert blobs to dataURLs
  // CHANGED: Handle ID-based items for export
  let itemsToExport = [];
  if (sessions[sessionId].items) {
    if (typeof sessions[sessionId].items[0] === 'number') {
       // Fetch items if they are IDs
       const promises = sessions[sessionId].items.map(id => idbGet(STORE, id));
       itemsToExport = (await Promise.all(promises)).filter(i=>i);
    } else {
       itemsToExport = sessions[sessionId].items;
    }
  }

  if (itemsToExport.length) {
    sessionData.items = await Promise.all(itemsToExport.map(async (item) => {
      const exportItem = { ...item };
      delete exportItem._preview;
      delete exportItem._objectURL;
      
      if (exportItem.blob) {
        exportItem.dataURL = await blobToDataURL(exportItem.blob);
        delete exportItem.blob; // Remove blob from export
      }
      return exportItem;
    }));
  }

  const jsonString = JSON.stringify(sessionData, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;

  const safeName = (sessionData.name || 'untitled').replace(/[^a-z0-9]/gi, '_').toLowerCase();
  a.download = `collection-export-${safeName}-${new Date().toISOString().slice(0,10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function handleImportCollection(event) {
  const file = event.target.files?.[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async (e) => {
       try {
      const json = e.target.result;
      const data = JSON.parse(json);
      
      // Basic validation
      if (!data || typeof data !== 'object') throw new Error('Invalid JSON file');
      
      await importSession(data);
      
      // Reset input so the same file can be selected again if needed
      event.target.value = '';
    } catch (err) {
      console.error('Import failed', err);
      alert('Failed to import collection: ' + err.message);
    }
  };
  reader.readAsText(file);
}

// NEW: Wire up import functionality (placed here to ensure handleImportCollection is defined)
// CHANGED: Run immediately to ensure listeners attach even if DOMContentLoaded already fired
(function wireImport() {
  const btn = document.getElementById('importCollectionBtn');
  const inp = document.getElementById('importCollectionInput');
  if (btn && inp) {
    btn.onclick = () => inp.click();
    inp.onchange = handleImportCollection;
  }
})();

document.addEventListener('DOMContentLoaded', () => {
  // (Optional) Re-check wiring if needed, but the IIFE above covers it.
});
</script>

<footer class="app-footer">
  <div class="wrap">
    <span id="appStatusFooter" class="footer-chip not-installed">
      <span class="dot" aria-hidden="true"></span>
      <span class="txt">v2.02 â€¢ Not installed</span>
    </span>
  </div>
</footer>

<script>
  // App version and install status footer updater
  const APP_VERSION = 'v2.02';
  let deferredPrompt = null; // Store the install prompt event

  function computeInstalled() {
    return (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches)
      || (navigator.standalone === true); // iOS Safari
  }

  function updateInstallStatus() {
    const el = document.getElementById('appStatusFooter');
    if (!el) return;
    const installed = computeInstalled();
    
    // Reset classes
    el.classList.remove('installed', 'not-installed', 'install-ready');
    
    const txt = el.querySelector('.txt');
    if (!txt) return;

    if (installed) {
      el.classList.add('installed');
      txt.textContent = `${APP_VERSION} â€¢ Installed`;
      el.onclick = null;
      el.style.cursor = 'default';
    } else if (deferredPrompt) {
      // If not installed and we have a prompt, make it an install button
      el.classList.add('install-ready');
      txt.textContent = `${APP_VERSION} â€¢ Install App`;
      el.onclick = async () => {
        if (deferredPrompt) {
          deferredPrompt.prompt();
          const { outcome } = await deferredPrompt.userChoice;
          if (outcome === 'accepted') {
            deferredPrompt = null;
          }
          updateInstallStatus();
        }
      };
    } else {
      // Not installed, no prompt available
      el.classList.add('not-installed');
      txt.textContent = `${APP_VERSION} â€¢ Not installed`;
      el.onclick = null;
      el.style.cursor = 'default';
    }
  }

  // Capture the install prompt
  window.addEventListener('beforeinstallprompt', (e) => {
    console.log('Install prompt captured'); // Check console if this appears
    e.preventDefault();
    deferredPrompt = e;
    updateInstallStatus();
  });

  window.addEventListener('DOMContentLoaded', updateInstallStatus);
  window.addEventListener('appinstalled', () => {
    deferredPrompt = null;
    updateInstallStatus();
  });
  
    
  try {
    const dm = window.matchMedia && window.matchMedia('(display-mode: standalone)');
    dm && dm.addEventListener && dm.addEventListener('change', updateInstallStatus);
  } catch (_) {}

  // Theme toggle logic
  const btnTheme = document.getElementById('btnTheme');

  function setTheme(isLight) {
    document.documentElement.setAttribute('data-theme', isLight ? 'light' : 'dark');
    if(btnTheme) btnTheme.textContent = isLight ? 'â˜€ï¸' : 'ðŸŒ™';
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
    const meta = document.querySelector('meta[name="theme-color"]');
    if(meta) meta.setAttribute('content', isLight ? '#f8fafc' : '#0f172a');
  }
  btnTheme?.addEventListener('click', () => {
    const isLight = document.documentElement.getAttribute('data-theme') === 'light';
    setTheme(!isLight);
  });
  // Init theme
  if (localStorage.getItem('theme') === 'light') setTheme(true);
</script>
</body>
</html>









